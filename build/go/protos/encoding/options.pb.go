// Code generated by protoc-gen-go. DO NOT EDIT.
// source: options.proto

package encoding

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Type int32

const (
	Type_None        Type = 0
	Type_JSON        Type = 1
	Type_JSON_SCHEMA Type = 2
	Type_PROTOBUF    Type = 3
	Type_AVRO        Type = 4
	Type_THRIFT      Type = 5
	Type_FLATBUFFER  Type = 6
)

var Type_name = map[int32]string{
	0: "None",
	1: "JSON",
	2: "JSON_SCHEMA",
	3: "PROTOBUF",
	4: "AVRO",
	5: "THRIFT",
	6: "FLATBUFFER",
}

var Type_value = map[string]int32{
	"None":        0,
	"JSON":        1,
	"JSON_SCHEMA": 2,
	"PROTOBUF":    3,
	"AVRO":        4,
	"THRIFT":      5,
	"FLATBUFFER":  6,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_110d40819f1994f9, []int{0}
}

type EncodeOptions struct {
	// The type of decoder selected determines which Encoding should be used (if any).
	// NOTE: This type will also determine which metadata k:v's need to be set.
	// @gotags: kong:"name=encoder,help='How to encode input'"
	Type Type `protobuf:"varint,1,opt,name=type,proto3,enum=protos.encoding.Type" json:"type,omitempty" kong:"name=encoder,help='How to encode input'"`
	// Specify an existing stored schema to use instead of specifying a Encoding payload
	// @gotags: kong:"-"
	SchemaId string `protobuf:"bytes,2,opt,name=schema_id,json=schemaId,proto3" json:"schema_id,omitempty" kong:"-"`
	// Valid input keys: dir, file, string, github, zip
	// TODO: Help needs to outline all of the available options here
	// @gotags: name:"encoder-input"
	Input map[string]string `protobuf:"bytes,3,rep,name=input,proto3" json:"input,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" name:"encoder-input"`
	// Valid input keys:
	// TODO: Help needs to outline all of the available options here
	// @gotags: name:"encoder-metadata"
	Metadata             map[string]string `protobuf:"bytes,4,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" name:"encoder-metadata"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EncodeOptions) Reset()         { *m = EncodeOptions{} }
func (m *EncodeOptions) String() string { return proto.CompactTextString(m) }
func (*EncodeOptions) ProtoMessage()    {}
func (*EncodeOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_110d40819f1994f9, []int{0}
}

func (m *EncodeOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EncodeOptions.Unmarshal(m, b)
}
func (m *EncodeOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EncodeOptions.Marshal(b, m, deterministic)
}
func (m *EncodeOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncodeOptions.Merge(m, src)
}
func (m *EncodeOptions) XXX_Size() int {
	return xxx_messageInfo_EncodeOptions.Size(m)
}
func (m *EncodeOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_EncodeOptions.DiscardUnknown(m)
}

var xxx_messageInfo_EncodeOptions proto.InternalMessageInfo

func (m *EncodeOptions) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_None
}

func (m *EncodeOptions) GetSchemaId() string {
	if m != nil {
		return m.SchemaId
	}
	return ""
}

func (m *EncodeOptions) GetInput() map[string]string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *EncodeOptions) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type DecodeOptions struct {
	// The type of decoder selected determines which Encoding should be used (if any)
	// NOTE: This type will also determine which metadata k:v's need to be set.
	// @gotags: kong:"name=decoder,help='How to decode output (valid TYPEs: 1 = JSON, 2 = JSON_SCHEMA, 3 = PROTOBUF, 4 = AVRO, 5 = THRIFT, 6 = FLATBUFFER)'"
	// TODO: ^ This sucks and needs to be improved. Not sure how yet.
	Type Type `protobuf:"varint,1,opt,name=type,proto3,enum=protos.encoding.Type" json:"type,omitempty" kong:"name=decoder,help='How to decode output (valid TYPEs: 1 = JSON, 2 = JSON_SCHEMA, 3 = PROTOBUF, 4 = AVRO, 5 = THRIFT, 6 = FLATBUFFER)'"`
	// Specify an existing stored schema to use instead of specifying a Encoding payload
	// @gotags: kong:"-"
	SchemaId string `protobuf:"bytes,2,opt,name=schema_id,json=schemaId,proto3" json:"schema_id,omitempty" kong:"-"`
	// Valid input keys: dir, file, string, github, zip
	// TODO: Help needs to outline all of the available options here
	// TODO: This needs to improve as well. Probably new 'map_keys' tag?
	// @gotags: kong:"name='decoder-input',required"
	Input map[string]string `protobuf:"bytes,3,rep,name=input,proto3" json:"input,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" kong:"name='decoder-input',required"`
	// Valid input keys:
	// TODO: Help needs to outline all of the available options here
	// TODO: Same, needs to be improved? Not sure how.
	// @gotags: name:"decoder-metadata"
	Metadata             map[string]string `protobuf:"bytes,4,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" name:"decoder-metadata"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DecodeOptions) Reset()         { *m = DecodeOptions{} }
func (m *DecodeOptions) String() string { return proto.CompactTextString(m) }
func (*DecodeOptions) ProtoMessage()    {}
func (*DecodeOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_110d40819f1994f9, []int{1}
}

func (m *DecodeOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DecodeOptions.Unmarshal(m, b)
}
func (m *DecodeOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DecodeOptions.Marshal(b, m, deterministic)
}
func (m *DecodeOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecodeOptions.Merge(m, src)
}
func (m *DecodeOptions) XXX_Size() int {
	return xxx_messageInfo_DecodeOptions.Size(m)
}
func (m *DecodeOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_DecodeOptions.DiscardUnknown(m)
}

var xxx_messageInfo_DecodeOptions proto.InternalMessageInfo

func (m *DecodeOptions) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_None
}

func (m *DecodeOptions) GetSchemaId() string {
	if m != nil {
		return m.SchemaId
	}
	return ""
}

func (m *DecodeOptions) GetInput() map[string]string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *DecodeOptions) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func init() {
	proto.RegisterEnum("protos.encoding.Type", Type_name, Type_value)
	proto.RegisterType((*EncodeOptions)(nil), "protos.encoding.EncodeOptions")
	proto.RegisterMapType((map[string]string)(nil), "protos.encoding.EncodeOptions.InputEntry")
	proto.RegisterMapType((map[string]string)(nil), "protos.encoding.EncodeOptions.MetadataEntry")
	proto.RegisterType((*DecodeOptions)(nil), "protos.encoding.DecodeOptions")
	proto.RegisterMapType((map[string]string)(nil), "protos.encoding.DecodeOptions.InputEntry")
	proto.RegisterMapType((map[string]string)(nil), "protos.encoding.DecodeOptions.MetadataEntry")
}

func init() { proto.RegisterFile("options.proto", fileDescriptor_110d40819f1994f9) }

var fileDescriptor_110d40819f1994f9 = []byte{
	// 377 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x91, 0x4f, 0x6b, 0xdb, 0x40,
	0x10, 0xc5, 0xab, 0x3f, 0x36, 0xf2, 0xb8, 0xb6, 0x97, 0xa5, 0x05, 0xe1, 0x5e, 0x4c, 0x4f, 0x76,
	0x69, 0x25, 0x70, 0x2f, 0xa6, 0xa5, 0x18, 0xbb, 0x95, 0xb0, 0x4b, 0x6c, 0x85, 0xb5, 0x9c, 0x43,
	0x2e, 0x46, 0x7f, 0x16, 0x5b, 0xc4, 0xd2, 0x0a, 0x69, 0x15, 0xd0, 0x47, 0xcd, 0xb7, 0x09, 0x92,
	0x9c, 0x04, 0x25, 0x87, 0x90, 0x5c, 0x92, 0xd3, 0xce, 0x0c, 0xef, 0xbd, 0x61, 0x7e, 0x0b, 0x1d,
	0x16, 0xf3, 0x80, 0x45, 0xa9, 0x16, 0x27, 0x8c, 0x33, 0xdc, 0x2b, 0x9f, 0x54, 0xa3, 0x91, 0xc7,
	0xfc, 0x20, 0xda, 0x7f, 0xbd, 0x11, 0xa1, 0x63, 0x14, 0x0d, 0xb5, 0x2a, 0x21, 0x1e, 0x81, 0xcc,
	0xf3, 0x98, 0xaa, 0xc2, 0x40, 0x18, 0x76, 0xc7, 0x9f, 0xb5, 0x47, 0x0e, 0xcd, 0xce, 0x63, 0x4a,
	0x4a, 0x09, 0xfe, 0x02, 0xad, 0xd4, 0x3b, 0xd0, 0xd0, 0xd9, 0x05, 0xbe, 0x2a, 0x0e, 0x84, 0x61,
	0x8b, 0x28, 0xd5, 0x60, 0xe9, 0xe3, 0x29, 0x34, 0x82, 0x28, 0xce, 0xb8, 0x2a, 0x0d, 0xa4, 0x61,
	0x7b, 0x3c, 0x7a, 0x12, 0x54, 0x5b, 0xab, 0x2d, 0x0b, 0xad, 0x11, 0xf1, 0x24, 0x27, 0x95, 0x0f,
	0x2f, 0x40, 0x09, 0x29, 0x77, 0x7c, 0x87, 0x3b, 0xaa, 0x5c, 0x66, 0x7c, 0x7f, 0x26, 0x63, 0x75,
	0x92, 0x57, 0x31, 0xf7, 0xee, 0xfe, 0x04, 0xe0, 0x21, 0x1e, 0x23, 0x90, 0xae, 0x68, 0x5e, 0xde,
	0xd7, 0x22, 0x45, 0x89, 0x3f, 0x41, 0xe3, 0xda, 0x39, 0x66, 0xf4, 0x74, 0x43, 0xd5, 0xfc, 0x12,
	0x27, 0x42, 0xff, 0x37, 0x74, 0x6a, 0xa1, 0x2f, 0x31, 0x97, 0x6c, 0xff, 0xd1, 0x37, 0x61, 0x5b,
	0x5b, 0xfb, 0x4a, 0xb6, 0xf5, 0x8c, 0xf7, 0xc5, 0xf6, 0xdb, 0x0e, 0xe4, 0x02, 0x16, 0x56, 0x40,
	0x5e, 0xb3, 0x88, 0xa2, 0x0f, 0x45, 0xf5, 0x7f, 0x63, 0xad, 0x91, 0x80, 0x7b, 0xd0, 0x2e, 0xaa,
	0xdd, 0xe6, 0xef, 0xc2, 0x58, 0xcd, 0x90, 0x88, 0x3f, 0x82, 0x72, 0x4e, 0x2c, 0xdb, 0x9a, 0x6f,
	0x4d, 0x24, 0x15, 0xc2, 0xd9, 0x05, 0xb1, 0x90, 0x8c, 0x01, 0x9a, 0xf6, 0x82, 0x2c, 0x4d, 0x1b,
	0x35, 0x70, 0x17, 0xc0, 0x3c, 0x9b, 0xd9, 0xf3, 0xad, 0x69, 0x1a, 0x04, 0x35, 0xe7, 0xd3, 0xcb,
	0x3f, 0xfb, 0x80, 0x1f, 0x32, 0x57, 0xf3, 0x58, 0xa8, 0xbb, 0x0e, 0xf7, 0x0e, 0x1e, 0x4b, 0x62,
	0x3d, 0x3e, 0x66, 0xa1, 0x4b, 0x93, 0x1f, 0xd5, 0x5f, 0xa4, 0xba, 0x9b, 0x05, 0x47, 0x5f, 0xdf,
	0x33, 0xbd, 0xc2, 0xa7, 0xdf, 0xe1, 0x73, 0x9b, 0xe5, 0xe0, 0xe7, 0x6d, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x2c, 0x05, 0xef, 0xc0, 0x82, 0x03, 0x00, 0x00,
}
