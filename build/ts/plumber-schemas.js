/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.protos = (function() {

    /**
     * Namespace protos.
     * @exports protos
     * @namespace
     */
    var protos = {};

    protos.GetAlertRequest = (function() {

        /**
         * Properties of a GetAlertRequest.
         * @memberof protos
         * @interface IGetAlertRequest
         * @property {protos.common.IAuth|null} [auth] GetAlertRequest auth
         * @property {string|null} [alertId] GetAlertRequest alertId
         */

        /**
         * Constructs a new GetAlertRequest.
         * @memberof protos
         * @classdesc Represents a GetAlertRequest.
         * @implements IGetAlertRequest
         * @constructor
         * @param {protos.IGetAlertRequest=} [properties] Properties to set
         */
        function GetAlertRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAlertRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAlertRequest
         * @instance
         */
        GetAlertRequest.prototype.auth = null;

        /**
         * GetAlertRequest alertId.
         * @member {string} alertId
         * @memberof protos.GetAlertRequest
         * @instance
         */
        GetAlertRequest.prototype.alertId = "";

        /**
         * Creates a new GetAlertRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAlertRequest
         * @static
         * @param {protos.IGetAlertRequest=} [properties] Properties to set
         * @returns {protos.GetAlertRequest} GetAlertRequest instance
         */
        GetAlertRequest.create = function create(properties) {
            return new GetAlertRequest(properties);
        };

        /**
         * Encodes the specified GetAlertRequest message. Does not implicitly {@link protos.GetAlertRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAlertRequest
         * @static
         * @param {protos.IGetAlertRequest} message GetAlertRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAlertRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alertId != null && Object.hasOwnProperty.call(message, "alertId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.alertId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAlertRequest message, length delimited. Does not implicitly {@link protos.GetAlertRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAlertRequest
         * @static
         * @param {protos.IGetAlertRequest} message GetAlertRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAlertRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAlertRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAlertRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAlertRequest} GetAlertRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAlertRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAlertRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.alertId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAlertRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAlertRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAlertRequest} GetAlertRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAlertRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAlertRequest message.
         * @function verify
         * @memberof protos.GetAlertRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAlertRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.alertId != null && message.hasOwnProperty("alertId"))
                if (!$util.isString(message.alertId))
                    return "alertId: string expected";
            return null;
        };

        /**
         * Creates a GetAlertRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAlertRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAlertRequest} GetAlertRequest
         */
        GetAlertRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAlertRequest)
                return object;
            var message = new $root.protos.GetAlertRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAlertRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.alertId != null)
                message.alertId = String(object.alertId);
            return message;
        };

        /**
         * Creates a plain object from a GetAlertRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAlertRequest
         * @static
         * @param {protos.GetAlertRequest} message GetAlertRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAlertRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.alertId = "";
                object.auth = null;
            }
            if (message.alertId != null && message.hasOwnProperty("alertId"))
                object.alertId = message.alertId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAlertRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAlertRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAlertRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAlertRequest;
    })();

    protos.GetAlertResponse = (function() {

        /**
         * Properties of a GetAlertResponse.
         * @memberof protos
         * @interface IGetAlertResponse
         * @property {protos.opts.IAlertOptions|null} [alert] GetAlertResponse alert
         * @property {protos.common.IStatus|null} [status] GetAlertResponse status
         */

        /**
         * Constructs a new GetAlertResponse.
         * @memberof protos
         * @classdesc Represents a GetAlertResponse.
         * @implements IGetAlertResponse
         * @constructor
         * @param {protos.IGetAlertResponse=} [properties] Properties to set
         */
        function GetAlertResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAlertResponse alert.
         * @member {protos.opts.IAlertOptions|null|undefined} alert
         * @memberof protos.GetAlertResponse
         * @instance
         */
        GetAlertResponse.prototype.alert = null;

        /**
         * GetAlertResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetAlertResponse
         * @instance
         */
        GetAlertResponse.prototype.status = null;

        /**
         * Creates a new GetAlertResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAlertResponse
         * @static
         * @param {protos.IGetAlertResponse=} [properties] Properties to set
         * @returns {protos.GetAlertResponse} GetAlertResponse instance
         */
        GetAlertResponse.create = function create(properties) {
            return new GetAlertResponse(properties);
        };

        /**
         * Encodes the specified GetAlertResponse message. Does not implicitly {@link protos.GetAlertResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAlertResponse
         * @static
         * @param {protos.IGetAlertResponse} message GetAlertResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAlertResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alert != null && Object.hasOwnProperty.call(message, "alert"))
                $root.protos.opts.AlertOptions.encode(message.alert, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAlertResponse message, length delimited. Does not implicitly {@link protos.GetAlertResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAlertResponse
         * @static
         * @param {protos.IGetAlertResponse} message GetAlertResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAlertResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAlertResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAlertResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAlertResponse} GetAlertResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAlertResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAlertResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.alert = $root.protos.opts.AlertOptions.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAlertResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAlertResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAlertResponse} GetAlertResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAlertResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAlertResponse message.
         * @function verify
         * @memberof protos.GetAlertResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAlertResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.alert != null && message.hasOwnProperty("alert")) {
                var error = $root.protos.opts.AlertOptions.verify(message.alert);
                if (error)
                    return "alert." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a GetAlertResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAlertResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAlertResponse} GetAlertResponse
         */
        GetAlertResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAlertResponse)
                return object;
            var message = new $root.protos.GetAlertResponse();
            if (object.alert != null) {
                if (typeof object.alert !== "object")
                    throw TypeError(".protos.GetAlertResponse.alert: object expected");
                message.alert = $root.protos.opts.AlertOptions.fromObject(object.alert);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetAlertResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAlertResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAlertResponse
         * @static
         * @param {protos.GetAlertResponse} message GetAlertResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAlertResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.alert = null;
                object.status = null;
            }
            if (message.alert != null && message.hasOwnProperty("alert"))
                object.alert = $root.protos.opts.AlertOptions.toObject(message.alert, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetAlertResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAlertResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAlertResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAlertResponse;
    })();

    protos.CreateAlertRequest = (function() {

        /**
         * Properties of a CreateAlertRequest.
         * @memberof protos
         * @interface ICreateAlertRequest
         * @property {protos.common.IAuth|null} [auth] CreateAlertRequest auth
         * @property {protos.opts.IAlertOptions|null} [alert] CreateAlertRequest alert
         */

        /**
         * Constructs a new CreateAlertRequest.
         * @memberof protos
         * @classdesc Represents a CreateAlertRequest.
         * @implements ICreateAlertRequest
         * @constructor
         * @param {protos.ICreateAlertRequest=} [properties] Properties to set
         */
        function CreateAlertRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateAlertRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateAlertRequest
         * @instance
         */
        CreateAlertRequest.prototype.auth = null;

        /**
         * CreateAlertRequest alert.
         * @member {protos.opts.IAlertOptions|null|undefined} alert
         * @memberof protos.CreateAlertRequest
         * @instance
         */
        CreateAlertRequest.prototype.alert = null;

        /**
         * Creates a new CreateAlertRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateAlertRequest
         * @static
         * @param {protos.ICreateAlertRequest=} [properties] Properties to set
         * @returns {protos.CreateAlertRequest} CreateAlertRequest instance
         */
        CreateAlertRequest.create = function create(properties) {
            return new CreateAlertRequest(properties);
        };

        /**
         * Encodes the specified CreateAlertRequest message. Does not implicitly {@link protos.CreateAlertRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateAlertRequest
         * @static
         * @param {protos.ICreateAlertRequest} message CreateAlertRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAlertRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alert != null && Object.hasOwnProperty.call(message, "alert"))
                $root.protos.opts.AlertOptions.encode(message.alert, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateAlertRequest message, length delimited. Does not implicitly {@link protos.CreateAlertRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateAlertRequest
         * @static
         * @param {protos.ICreateAlertRequest} message CreateAlertRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAlertRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateAlertRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateAlertRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateAlertRequest} CreateAlertRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAlertRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateAlertRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.alert = $root.protos.opts.AlertOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateAlertRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateAlertRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateAlertRequest} CreateAlertRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAlertRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateAlertRequest message.
         * @function verify
         * @memberof protos.CreateAlertRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateAlertRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.alert != null && message.hasOwnProperty("alert")) {
                var error = $root.protos.opts.AlertOptions.verify(message.alert);
                if (error)
                    return "alert." + error;
            }
            return null;
        };

        /**
         * Creates a CreateAlertRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateAlertRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateAlertRequest} CreateAlertRequest
         */
        CreateAlertRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateAlertRequest)
                return object;
            var message = new $root.protos.CreateAlertRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateAlertRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.alert != null) {
                if (typeof object.alert !== "object")
                    throw TypeError(".protos.CreateAlertRequest.alert: object expected");
                message.alert = $root.protos.opts.AlertOptions.fromObject(object.alert);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateAlertRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateAlertRequest
         * @static
         * @param {protos.CreateAlertRequest} message CreateAlertRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateAlertRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.alert = null;
                object.auth = null;
            }
            if (message.alert != null && message.hasOwnProperty("alert"))
                object.alert = $root.protos.opts.AlertOptions.toObject(message.alert, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateAlertRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateAlertRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateAlertRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateAlertRequest;
    })();

    protos.CreateAlertResponse = (function() {

        /**
         * Properties of a CreateAlertResponse.
         * @memberof protos
         * @interface ICreateAlertResponse
         * @property {protos.opts.IAlertOptions|null} [alert] CreateAlertResponse alert
         * @property {protos.common.IStatus|null} [status] CreateAlertResponse status
         */

        /**
         * Constructs a new CreateAlertResponse.
         * @memberof protos
         * @classdesc Represents a CreateAlertResponse.
         * @implements ICreateAlertResponse
         * @constructor
         * @param {protos.ICreateAlertResponse=} [properties] Properties to set
         */
        function CreateAlertResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateAlertResponse alert.
         * @member {protos.opts.IAlertOptions|null|undefined} alert
         * @memberof protos.CreateAlertResponse
         * @instance
         */
        CreateAlertResponse.prototype.alert = null;

        /**
         * CreateAlertResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.CreateAlertResponse
         * @instance
         */
        CreateAlertResponse.prototype.status = null;

        /**
         * Creates a new CreateAlertResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateAlertResponse
         * @static
         * @param {protos.ICreateAlertResponse=} [properties] Properties to set
         * @returns {protos.CreateAlertResponse} CreateAlertResponse instance
         */
        CreateAlertResponse.create = function create(properties) {
            return new CreateAlertResponse(properties);
        };

        /**
         * Encodes the specified CreateAlertResponse message. Does not implicitly {@link protos.CreateAlertResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateAlertResponse
         * @static
         * @param {protos.ICreateAlertResponse} message CreateAlertResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAlertResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alert != null && Object.hasOwnProperty.call(message, "alert"))
                $root.protos.opts.AlertOptions.encode(message.alert, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateAlertResponse message, length delimited. Does not implicitly {@link protos.CreateAlertResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateAlertResponse
         * @static
         * @param {protos.ICreateAlertResponse} message CreateAlertResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAlertResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateAlertResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateAlertResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateAlertResponse} CreateAlertResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAlertResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateAlertResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.alert = $root.protos.opts.AlertOptions.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateAlertResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateAlertResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateAlertResponse} CreateAlertResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAlertResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateAlertResponse message.
         * @function verify
         * @memberof protos.CreateAlertResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateAlertResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.alert != null && message.hasOwnProperty("alert")) {
                var error = $root.protos.opts.AlertOptions.verify(message.alert);
                if (error)
                    return "alert." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a CreateAlertResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateAlertResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateAlertResponse} CreateAlertResponse
         */
        CreateAlertResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateAlertResponse)
                return object;
            var message = new $root.protos.CreateAlertResponse();
            if (object.alert != null) {
                if (typeof object.alert !== "object")
                    throw TypeError(".protos.CreateAlertResponse.alert: object expected");
                message.alert = $root.protos.opts.AlertOptions.fromObject(object.alert);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.CreateAlertResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateAlertResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateAlertResponse
         * @static
         * @param {protos.CreateAlertResponse} message CreateAlertResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateAlertResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.alert = null;
                object.status = null;
            }
            if (message.alert != null && message.hasOwnProperty("alert"))
                object.alert = $root.protos.opts.AlertOptions.toObject(message.alert, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this CreateAlertResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateAlertResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateAlertResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateAlertResponse;
    })();

    protos.DeleteAlertRequest = (function() {

        /**
         * Properties of a DeleteAlertRequest.
         * @memberof protos
         * @interface IDeleteAlertRequest
         * @property {protos.common.IAuth|null} [auth] DeleteAlertRequest auth
         * @property {string|null} [alertId] DeleteAlertRequest alertId
         */

        /**
         * Constructs a new DeleteAlertRequest.
         * @memberof protos
         * @classdesc Represents a DeleteAlertRequest.
         * @implements IDeleteAlertRequest
         * @constructor
         * @param {protos.IDeleteAlertRequest=} [properties] Properties to set
         */
        function DeleteAlertRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteAlertRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteAlertRequest
         * @instance
         */
        DeleteAlertRequest.prototype.auth = null;

        /**
         * DeleteAlertRequest alertId.
         * @member {string} alertId
         * @memberof protos.DeleteAlertRequest
         * @instance
         */
        DeleteAlertRequest.prototype.alertId = "";

        /**
         * Creates a new DeleteAlertRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteAlertRequest
         * @static
         * @param {protos.IDeleteAlertRequest=} [properties] Properties to set
         * @returns {protos.DeleteAlertRequest} DeleteAlertRequest instance
         */
        DeleteAlertRequest.create = function create(properties) {
            return new DeleteAlertRequest(properties);
        };

        /**
         * Encodes the specified DeleteAlertRequest message. Does not implicitly {@link protos.DeleteAlertRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteAlertRequest
         * @static
         * @param {protos.IDeleteAlertRequest} message DeleteAlertRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAlertRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alertId != null && Object.hasOwnProperty.call(message, "alertId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.alertId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteAlertRequest message, length delimited. Does not implicitly {@link protos.DeleteAlertRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteAlertRequest
         * @static
         * @param {protos.IDeleteAlertRequest} message DeleteAlertRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAlertRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteAlertRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteAlertRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteAlertRequest} DeleteAlertRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAlertRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteAlertRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.alertId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteAlertRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteAlertRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteAlertRequest} DeleteAlertRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAlertRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteAlertRequest message.
         * @function verify
         * @memberof protos.DeleteAlertRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteAlertRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.alertId != null && message.hasOwnProperty("alertId"))
                if (!$util.isString(message.alertId))
                    return "alertId: string expected";
            return null;
        };

        /**
         * Creates a DeleteAlertRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteAlertRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteAlertRequest} DeleteAlertRequest
         */
        DeleteAlertRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteAlertRequest)
                return object;
            var message = new $root.protos.DeleteAlertRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteAlertRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.alertId != null)
                message.alertId = String(object.alertId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteAlertRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteAlertRequest
         * @static
         * @param {protos.DeleteAlertRequest} message DeleteAlertRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteAlertRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.alertId = "";
                object.auth = null;
            }
            if (message.alertId != null && message.hasOwnProperty("alertId"))
                object.alertId = message.alertId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteAlertRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteAlertRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteAlertRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteAlertRequest;
    })();

    protos.DeleteAlertResponse = (function() {

        /**
         * Properties of a DeleteAlertResponse.
         * @memberof protos
         * @interface IDeleteAlertResponse
         * @property {protos.common.IStatus|null} [status] DeleteAlertResponse status
         */

        /**
         * Constructs a new DeleteAlertResponse.
         * @memberof protos
         * @classdesc Represents a DeleteAlertResponse.
         * @implements IDeleteAlertResponse
         * @constructor
         * @param {protos.IDeleteAlertResponse=} [properties] Properties to set
         */
        function DeleteAlertResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteAlertResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteAlertResponse
         * @instance
         */
        DeleteAlertResponse.prototype.status = null;

        /**
         * Creates a new DeleteAlertResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteAlertResponse
         * @static
         * @param {protos.IDeleteAlertResponse=} [properties] Properties to set
         * @returns {protos.DeleteAlertResponse} DeleteAlertResponse instance
         */
        DeleteAlertResponse.create = function create(properties) {
            return new DeleteAlertResponse(properties);
        };

        /**
         * Encodes the specified DeleteAlertResponse message. Does not implicitly {@link protos.DeleteAlertResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteAlertResponse
         * @static
         * @param {protos.IDeleteAlertResponse} message DeleteAlertResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAlertResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteAlertResponse message, length delimited. Does not implicitly {@link protos.DeleteAlertResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteAlertResponse
         * @static
         * @param {protos.IDeleteAlertResponse} message DeleteAlertResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAlertResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteAlertResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteAlertResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteAlertResponse} DeleteAlertResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAlertResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteAlertResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteAlertResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteAlertResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteAlertResponse} DeleteAlertResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAlertResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteAlertResponse message.
         * @function verify
         * @memberof protos.DeleteAlertResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteAlertResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteAlertResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteAlertResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteAlertResponse} DeleteAlertResponse
         */
        DeleteAlertResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteAlertResponse)
                return object;
            var message = new $root.protos.DeleteAlertResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteAlertResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteAlertResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteAlertResponse
         * @static
         * @param {protos.DeleteAlertResponse} message DeleteAlertResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteAlertResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteAlertResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteAlertResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteAlertResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteAlertResponse;
    })();

    protos.UpdateAlertRequest = (function() {

        /**
         * Properties of an UpdateAlertRequest.
         * @memberof protos
         * @interface IUpdateAlertRequest
         * @property {protos.common.IAuth|null} [auth] UpdateAlertRequest auth
         * @property {protos.opts.IAlertOptions|null} [alert] UpdateAlertRequest alert
         */

        /**
         * Constructs a new UpdateAlertRequest.
         * @memberof protos
         * @classdesc Represents an UpdateAlertRequest.
         * @implements IUpdateAlertRequest
         * @constructor
         * @param {protos.IUpdateAlertRequest=} [properties] Properties to set
         */
        function UpdateAlertRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateAlertRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateAlertRequest
         * @instance
         */
        UpdateAlertRequest.prototype.auth = null;

        /**
         * UpdateAlertRequest alert.
         * @member {protos.opts.IAlertOptions|null|undefined} alert
         * @memberof protos.UpdateAlertRequest
         * @instance
         */
        UpdateAlertRequest.prototype.alert = null;

        /**
         * Creates a new UpdateAlertRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateAlertRequest
         * @static
         * @param {protos.IUpdateAlertRequest=} [properties] Properties to set
         * @returns {protos.UpdateAlertRequest} UpdateAlertRequest instance
         */
        UpdateAlertRequest.create = function create(properties) {
            return new UpdateAlertRequest(properties);
        };

        /**
         * Encodes the specified UpdateAlertRequest message. Does not implicitly {@link protos.UpdateAlertRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateAlertRequest
         * @static
         * @param {protos.IUpdateAlertRequest} message UpdateAlertRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateAlertRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alert != null && Object.hasOwnProperty.call(message, "alert"))
                $root.protos.opts.AlertOptions.encode(message.alert, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateAlertRequest message, length delimited. Does not implicitly {@link protos.UpdateAlertRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateAlertRequest
         * @static
         * @param {protos.IUpdateAlertRequest} message UpdateAlertRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateAlertRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateAlertRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateAlertRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateAlertRequest} UpdateAlertRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAlertRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateAlertRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.alert = $root.protos.opts.AlertOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateAlertRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateAlertRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateAlertRequest} UpdateAlertRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAlertRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateAlertRequest message.
         * @function verify
         * @memberof protos.UpdateAlertRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateAlertRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.alert != null && message.hasOwnProperty("alert")) {
                var error = $root.protos.opts.AlertOptions.verify(message.alert);
                if (error)
                    return "alert." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateAlertRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateAlertRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateAlertRequest} UpdateAlertRequest
         */
        UpdateAlertRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateAlertRequest)
                return object;
            var message = new $root.protos.UpdateAlertRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateAlertRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.alert != null) {
                if (typeof object.alert !== "object")
                    throw TypeError(".protos.UpdateAlertRequest.alert: object expected");
                message.alert = $root.protos.opts.AlertOptions.fromObject(object.alert);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateAlertRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateAlertRequest
         * @static
         * @param {protos.UpdateAlertRequest} message UpdateAlertRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateAlertRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.alert = null;
                object.auth = null;
            }
            if (message.alert != null && message.hasOwnProperty("alert"))
                object.alert = $root.protos.opts.AlertOptions.toObject(message.alert, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateAlertRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateAlertRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateAlertRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateAlertRequest;
    })();

    protos.UpdateAlertResponse = (function() {

        /**
         * Properties of an UpdateAlertResponse.
         * @memberof protos
         * @interface IUpdateAlertResponse
         * @property {protos.opts.IAlertOptions|null} [alert] UpdateAlertResponse alert
         * @property {protos.common.IStatus|null} [status] UpdateAlertResponse status
         */

        /**
         * Constructs a new UpdateAlertResponse.
         * @memberof protos
         * @classdesc Represents an UpdateAlertResponse.
         * @implements IUpdateAlertResponse
         * @constructor
         * @param {protos.IUpdateAlertResponse=} [properties] Properties to set
         */
        function UpdateAlertResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateAlertResponse alert.
         * @member {protos.opts.IAlertOptions|null|undefined} alert
         * @memberof protos.UpdateAlertResponse
         * @instance
         */
        UpdateAlertResponse.prototype.alert = null;

        /**
         * UpdateAlertResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateAlertResponse
         * @instance
         */
        UpdateAlertResponse.prototype.status = null;

        /**
         * Creates a new UpdateAlertResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateAlertResponse
         * @static
         * @param {protos.IUpdateAlertResponse=} [properties] Properties to set
         * @returns {protos.UpdateAlertResponse} UpdateAlertResponse instance
         */
        UpdateAlertResponse.create = function create(properties) {
            return new UpdateAlertResponse(properties);
        };

        /**
         * Encodes the specified UpdateAlertResponse message. Does not implicitly {@link protos.UpdateAlertResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateAlertResponse
         * @static
         * @param {protos.IUpdateAlertResponse} message UpdateAlertResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateAlertResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alert != null && Object.hasOwnProperty.call(message, "alert"))
                $root.protos.opts.AlertOptions.encode(message.alert, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateAlertResponse message, length delimited. Does not implicitly {@link protos.UpdateAlertResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateAlertResponse
         * @static
         * @param {protos.IUpdateAlertResponse} message UpdateAlertResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateAlertResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateAlertResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateAlertResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateAlertResponse} UpdateAlertResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAlertResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateAlertResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.alert = $root.protos.opts.AlertOptions.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateAlertResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateAlertResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateAlertResponse} UpdateAlertResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAlertResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateAlertResponse message.
         * @function verify
         * @memberof protos.UpdateAlertResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateAlertResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.alert != null && message.hasOwnProperty("alert")) {
                var error = $root.protos.opts.AlertOptions.verify(message.alert);
                if (error)
                    return "alert." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateAlertResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateAlertResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateAlertResponse} UpdateAlertResponse
         */
        UpdateAlertResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateAlertResponse)
                return object;
            var message = new $root.protos.UpdateAlertResponse();
            if (object.alert != null) {
                if (typeof object.alert !== "object")
                    throw TypeError(".protos.UpdateAlertResponse.alert: object expected");
                message.alert = $root.protos.opts.AlertOptions.fromObject(object.alert);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateAlertResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateAlertResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateAlertResponse
         * @static
         * @param {protos.UpdateAlertResponse} message UpdateAlertResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateAlertResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.alert = null;
                object.status = null;
            }
            if (message.alert != null && message.hasOwnProperty("alert"))
                object.alert = $root.protos.opts.AlertOptions.toObject(message.alert, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateAlertResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateAlertResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateAlertResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateAlertResponse;
    })();

    protos.common = (function() {

        /**
         * Namespace common.
         * @memberof protos
         * @namespace
         */
        var common = {};

        common.Auth = (function() {

            /**
             * Properties of an Auth.
             * @memberof protos.common
             * @interface IAuth
             * @property {string|null} [token] Auth token
             */

            /**
             * Constructs a new Auth.
             * @memberof protos.common
             * @classdesc Represents an Auth.
             * @implements IAuth
             * @constructor
             * @param {protos.common.IAuth=} [properties] Properties to set
             */
            function Auth(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Auth token.
             * @member {string} token
             * @memberof protos.common.Auth
             * @instance
             */
            Auth.prototype.token = "";

            /**
             * Creates a new Auth instance using the specified properties.
             * @function create
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth=} [properties] Properties to set
             * @returns {protos.common.Auth} Auth instance
             */
            Auth.create = function create(properties) {
                return new Auth(properties);
            };

            /**
             * Encodes the specified Auth message. Does not implicitly {@link protos.common.Auth.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                return writer;
            };

            /**
             * Encodes the specified Auth message, length delimited. Does not implicitly {@link protos.common.Auth.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Auth message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Auth();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Auth message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Auth message.
             * @function verify
             * @memberof protos.common.Auth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Auth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            /**
             * Creates an Auth message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Auth
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Auth} Auth
             */
            Auth.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Auth)
                    return object;
                var message = new $root.protos.common.Auth();
                if (object.token != null)
                    message.token = String(object.token);
                return message;
            };

            /**
             * Creates a plain object from an Auth message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.Auth} message Auth
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Auth.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.token = "";
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                return object;
            };

            /**
             * Converts this Auth to JSON.
             * @function toJSON
             * @memberof protos.common.Auth
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Auth.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Auth;
        })();

        /**
         * Code enum.
         * @name protos.common.Code
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} CANCELLED=1 CANCELLED value
         * @property {number} UNKNOWN=2 UNKNOWN value
         * @property {number} INVALID_ARGUMENT=3 INVALID_ARGUMENT value
         * @property {number} DEADLINE_EXCEEDED=4 DEADLINE_EXCEEDED value
         * @property {number} NOT_FOUND=5 NOT_FOUND value
         * @property {number} ALREADY_EXISTS=6 ALREADY_EXISTS value
         * @property {number} PERMISSION_DENIED=7 PERMISSION_DENIED value
         * @property {number} UNAUTHENTICATED=16 UNAUTHENTICATED value
         * @property {number} RESOURCE_EXHAUSTED=8 RESOURCE_EXHAUSTED value
         * @property {number} FAILED_PRECONDITION=9 FAILED_PRECONDITION value
         * @property {number} ABORTED=10 ABORTED value
         * @property {number} OUT_OF_RANGE=11 OUT_OF_RANGE value
         * @property {number} UNIMPLEMENTED=12 UNIMPLEMENTED value
         * @property {number} INTERNAL=13 INTERNAL value
         * @property {number} UNAVAILABLE=14 UNAVAILABLE value
         * @property {number} DATA_LOSS=15 DATA_LOSS value
         */
        common.Code = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "CANCELLED"] = 1;
            values[valuesById[2] = "UNKNOWN"] = 2;
            values[valuesById[3] = "INVALID_ARGUMENT"] = 3;
            values[valuesById[4] = "DEADLINE_EXCEEDED"] = 4;
            values[valuesById[5] = "NOT_FOUND"] = 5;
            values[valuesById[6] = "ALREADY_EXISTS"] = 6;
            values[valuesById[7] = "PERMISSION_DENIED"] = 7;
            values[valuesById[16] = "UNAUTHENTICATED"] = 16;
            values[valuesById[8] = "RESOURCE_EXHAUSTED"] = 8;
            values[valuesById[9] = "FAILED_PRECONDITION"] = 9;
            values[valuesById[10] = "ABORTED"] = 10;
            values[valuesById[11] = "OUT_OF_RANGE"] = 11;
            values[valuesById[12] = "UNIMPLEMENTED"] = 12;
            values[valuesById[13] = "INTERNAL"] = 13;
            values[valuesById[14] = "UNAVAILABLE"] = 14;
            values[valuesById[15] = "DATA_LOSS"] = 15;
            return values;
        })();

        common.Status = (function() {

            /**
             * Properties of a Status.
             * @memberof protos.common
             * @interface IStatus
             * @property {protos.common.Code|null} [code] Status code
             * @property {string|null} [message] Status message
             * @property {string|null} [requestId] Status requestId
             */

            /**
             * Constructs a new Status.
             * @memberof protos.common
             * @classdesc Represents a Status.
             * @implements IStatus
             * @constructor
             * @param {protos.common.IStatus=} [properties] Properties to set
             */
            function Status(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Status code.
             * @member {protos.common.Code} code
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.code = 0;

            /**
             * Status message.
             * @member {string} message
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.message = "";

            /**
             * Status requestId.
             * @member {string} requestId
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.requestId = "";

            /**
             * Creates a new Status instance using the specified properties.
             * @function create
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus=} [properties] Properties to set
             * @returns {protos.common.Status} Status instance
             */
            Status.create = function create(properties) {
                return new Status(properties);
            };

            /**
             * Encodes the specified Status message. Does not implicitly {@link protos.common.Status.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.requestId);
                return writer;
            };

            /**
             * Encodes the specified Status message, length delimited. Does not implicitly {@link protos.common.Status.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Status message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Status();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.requestId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Status message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Status message.
             * @function verify
             * @memberof protos.common.Status
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Status.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 16:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    if (!$util.isString(message.requestId))
                        return "requestId: string expected";
                return null;
            };

            /**
             * Creates a Status message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Status
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Status} Status
             */
            Status.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Status)
                    return object;
                var message = new $root.protos.common.Status();
                switch (object.code) {
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "CANCELLED":
                case 1:
                    message.code = 1;
                    break;
                case "UNKNOWN":
                case 2:
                    message.code = 2;
                    break;
                case "INVALID_ARGUMENT":
                case 3:
                    message.code = 3;
                    break;
                case "DEADLINE_EXCEEDED":
                case 4:
                    message.code = 4;
                    break;
                case "NOT_FOUND":
                case 5:
                    message.code = 5;
                    break;
                case "ALREADY_EXISTS":
                case 6:
                    message.code = 6;
                    break;
                case "PERMISSION_DENIED":
                case 7:
                    message.code = 7;
                    break;
                case "UNAUTHENTICATED":
                case 16:
                    message.code = 16;
                    break;
                case "RESOURCE_EXHAUSTED":
                case 8:
                    message.code = 8;
                    break;
                case "FAILED_PRECONDITION":
                case 9:
                    message.code = 9;
                    break;
                case "ABORTED":
                case 10:
                    message.code = 10;
                    break;
                case "OUT_OF_RANGE":
                case 11:
                    message.code = 11;
                    break;
                case "UNIMPLEMENTED":
                case 12:
                    message.code = 12;
                    break;
                case "INTERNAL":
                case 13:
                    message.code = 13;
                    break;
                case "UNAVAILABLE":
                case 14:
                    message.code = 14;
                    break;
                case "DATA_LOSS":
                case 15:
                    message.code = 15;
                    break;
                }
                if (object.message != null)
                    message.message = String(object.message);
                if (object.requestId != null)
                    message.requestId = String(object.requestId);
                return message;
            };

            /**
             * Creates a plain object from a Status message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.Status} message Status
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Status.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.message = "";
                    object.requestId = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.protos.common.Code[message.code] : message.code;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    object.requestId = message.requestId;
                return object;
            };

            /**
             * Converts this Status to JSON.
             * @function toJSON
             * @memberof protos.common.Status
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Status.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Status;
        })();

        common.Validation = (function() {

            /**
             * Properties of a Validation.
             * @memberof protos.common
             * @interface IValidation
             * @property {string|null} [_id] Validation _id
             * @property {string|null} [schemaId] Validation schemaId
             * @property {Array.<protos.common.Validation.IField>|null} [fields] Validation fields
             */

            /**
             * Constructs a new Validation.
             * @memberof protos.common
             * @classdesc Represents a Validation.
             * @implements IValidation
             * @constructor
             * @param {protos.common.IValidation=} [properties] Properties to set
             */
            function Validation(properties) {
                this.fields = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Validation _id.
             * @member {string} _id
             * @memberof protos.common.Validation
             * @instance
             */
            Validation.prototype._id = "";

            /**
             * Validation schemaId.
             * @member {string} schemaId
             * @memberof protos.common.Validation
             * @instance
             */
            Validation.prototype.schemaId = "";

            /**
             * Validation fields.
             * @member {Array.<protos.common.Validation.IField>} fields
             * @memberof protos.common.Validation
             * @instance
             */
            Validation.prototype.fields = $util.emptyArray;

            /**
             * Creates a new Validation instance using the specified properties.
             * @function create
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.IValidation=} [properties] Properties to set
             * @returns {protos.common.Validation} Validation instance
             */
            Validation.create = function create(properties) {
                return new Validation(properties);
            };

            /**
             * Encodes the specified Validation message. Does not implicitly {@link protos.common.Validation.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.IValidation} message Validation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Validation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message._id);
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
                if (message.fields != null && message.fields.length)
                    for (var i = 0; i < message.fields.length; ++i)
                        $root.protos.common.Validation.Field.encode(message.fields[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Validation message, length delimited. Does not implicitly {@link protos.common.Validation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.IValidation} message Validation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Validation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Validation message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Validation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Validation} Validation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Validation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Validation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._id = reader.string();
                        break;
                    case 2:
                        message.schemaId = reader.string();
                        break;
                    case 3:
                        if (!(message.fields && message.fields.length))
                            message.fields = [];
                        message.fields.push($root.protos.common.Validation.Field.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Validation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Validation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Validation} Validation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Validation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Validation message.
             * @function verify
             * @memberof protos.common.Validation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Validation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!Array.isArray(message.fields))
                        return "fields: array expected";
                    for (var i = 0; i < message.fields.length; ++i) {
                        var error = $root.protos.common.Validation.Field.verify(message.fields[i]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Validation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Validation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Validation} Validation
             */
            Validation.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Validation)
                    return object;
                var message = new $root.protos.common.Validation();
                if (object._id != null)
                    message._id = String(object._id);
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                if (object.fields) {
                    if (!Array.isArray(object.fields))
                        throw TypeError(".protos.common.Validation.fields: array expected");
                    message.fields = [];
                    for (var i = 0; i < object.fields.length; ++i) {
                        if (typeof object.fields[i] !== "object")
                            throw TypeError(".protos.common.Validation.fields: object expected");
                        message.fields[i] = $root.protos.common.Validation.Field.fromObject(object.fields[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Validation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.Validation} message Validation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Validation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fields = [];
                if (options.defaults) {
                    object._id = "";
                    object.schemaId = "";
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.fields && message.fields.length) {
                    object.fields = [];
                    for (var j = 0; j < message.fields.length; ++j)
                        object.fields[j] = $root.protos.common.Validation.Field.toObject(message.fields[j], options);
                }
                return object;
            };

            /**
             * Converts this Validation to JSON.
             * @function toJSON
             * @memberof protos.common.Validation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Validation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Validation.Field = (function() {

                /**
                 * Properties of a Field.
                 * @memberof protos.common.Validation
                 * @interface IField
                 * @property {string|null} [path] Field path
                 * @property {string|null} [validationType] Field validationType
                 * @property {string|null} [matchValue] Field matchValue
                 */

                /**
                 * Constructs a new Field.
                 * @memberof protos.common.Validation
                 * @classdesc Represents a Field.
                 * @implements IField
                 * @constructor
                 * @param {protos.common.Validation.IField=} [properties] Properties to set
                 */
                function Field(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Field path.
                 * @member {string} path
                 * @memberof protos.common.Validation.Field
                 * @instance
                 */
                Field.prototype.path = "";

                /**
                 * Field validationType.
                 * @member {string} validationType
                 * @memberof protos.common.Validation.Field
                 * @instance
                 */
                Field.prototype.validationType = "";

                /**
                 * Field matchValue.
                 * @member {string} matchValue
                 * @memberof protos.common.Validation.Field
                 * @instance
                 */
                Field.prototype.matchValue = "";

                /**
                 * Creates a new Field instance using the specified properties.
                 * @function create
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.IField=} [properties] Properties to set
                 * @returns {protos.common.Validation.Field} Field instance
                 */
                Field.create = function create(properties) {
                    return new Field(properties);
                };

                /**
                 * Encodes the specified Field message. Does not implicitly {@link protos.common.Validation.Field.verify|verify} messages.
                 * @function encode
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.IField} message Field message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Field.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                    if (message.validationType != null && Object.hasOwnProperty.call(message, "validationType"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.validationType);
                    if (message.matchValue != null && Object.hasOwnProperty.call(message, "matchValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.matchValue);
                    return writer;
                };

                /**
                 * Encodes the specified Field message, length delimited. Does not implicitly {@link protos.common.Validation.Field.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.IField} message Field message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Field.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Field message from the specified reader or buffer.
                 * @function decode
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {protos.common.Validation.Field} Field
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Field.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Validation.Field();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.path = reader.string();
                            break;
                        case 2:
                            message.validationType = reader.string();
                            break;
                        case 3:
                            message.matchValue = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Field message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {protos.common.Validation.Field} Field
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Field.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Field message.
                 * @function verify
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Field.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    if (message.validationType != null && message.hasOwnProperty("validationType"))
                        if (!$util.isString(message.validationType))
                            return "validationType: string expected";
                    if (message.matchValue != null && message.hasOwnProperty("matchValue"))
                        if (!$util.isString(message.matchValue))
                            return "matchValue: string expected";
                    return null;
                };

                /**
                 * Creates a Field message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {protos.common.Validation.Field} Field
                 */
                Field.fromObject = function fromObject(object) {
                    if (object instanceof $root.protos.common.Validation.Field)
                        return object;
                    var message = new $root.protos.common.Validation.Field();
                    if (object.path != null)
                        message.path = String(object.path);
                    if (object.validationType != null)
                        message.validationType = String(object.validationType);
                    if (object.matchValue != null)
                        message.matchValue = String(object.matchValue);
                    return message;
                };

                /**
                 * Creates a plain object from a Field message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.Field} message Field
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Field.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.path = "";
                        object.validationType = "";
                        object.matchValue = "";
                    }
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    if (message.validationType != null && message.hasOwnProperty("validationType"))
                        object.validationType = message.validationType;
                    if (message.matchValue != null && message.hasOwnProperty("matchValue"))
                        object.matchValue = message.matchValue;
                    return object;
                };

                /**
                 * Converts this Field to JSON.
                 * @function toJSON
                 * @memberof protos.common.Validation.Field
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Field.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Field;
            })();

            return Validation;
        })();

        /**
         * BackendType enum.
         * @name protos.common.BackendType
         * @enum {number}
         * @property {number} BACKEND_TYPE_UNSET=0 BACKEND_TYPE_UNSET value
         * @property {number} BACKEND_TYPE_KAFKA=1 BACKEND_TYPE_KAFKA value
         * @property {number} BACKEND_TYPE_RABBIT=2 BACKEND_TYPE_RABBIT value
         * @property {number} BACKEND_TYPE_RABBIT_STREAMS=3 BACKEND_TYPE_RABBIT_STREAMS value
         * @property {number} BACKEND_TYPE_NSQ=4 BACKEND_TYPE_NSQ value
         * @property {number} BACKEND_TYPE_NATS=5 BACKEND_TYPE_NATS value
         * @property {number} BACKEND_TYPE_NATS_STREAMING=6 BACKEND_TYPE_NATS_STREAMING value
         * @property {number} BACKEND_TYPE_GCP_PUBSUB=7 BACKEND_TYPE_GCP_PUBSUB value
         * @property {number} BACKEND_TYPE_AZURE_SERVICE_BUS=8 BACKEND_TYPE_AZURE_SERVICE_BUS value
         * @property {number} BACKEND_TYPE_AZURE_EVENT_HUB=9 BACKEND_TYPE_AZURE_EVENT_HUB value
         * @property {number} BACKEND_TYPE_AWS_SQS=10 BACKEND_TYPE_AWS_SQS value
         * @property {number} BACKEND_TYPE_AWS_SNS=11 BACKEND_TYPE_AWS_SNS value
         * @property {number} BACKEND_TYPE_REDIS_PUBSUB=12 BACKEND_TYPE_REDIS_PUBSUB value
         * @property {number} BACKEND_TYPE_REDIS_STREAMS=13 BACKEND_TYPE_REDIS_STREAMS value
         * @property {number} BACKEND_TYPE_ACTIVEMQ=14 BACKEND_TYPE_ACTIVEMQ value
         * @property {number} BACKEND_TYPE_PULSAR=15 BACKEND_TYPE_PULSAR value
         * @property {number} BACKEND_TYPE_MQTT=16 BACKEND_TYPE_MQTT value
         * @property {number} BACKEND_TYPE_POSTGRES_CDC=17 BACKEND_TYPE_POSTGRES_CDC value
         * @property {number} BACKEND_TYPE_MONGODB_CDC=18 BACKEND_TYPE_MONGODB_CDC value
         * @property {number} BACKEND_TYPE_KUBE_MQ=19 BACKEND_TYPE_KUBE_MQ value
         */
        common.BackendType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "BACKEND_TYPE_UNSET"] = 0;
            values[valuesById[1] = "BACKEND_TYPE_KAFKA"] = 1;
            values[valuesById[2] = "BACKEND_TYPE_RABBIT"] = 2;
            values[valuesById[3] = "BACKEND_TYPE_RABBIT_STREAMS"] = 3;
            values[valuesById[4] = "BACKEND_TYPE_NSQ"] = 4;
            values[valuesById[5] = "BACKEND_TYPE_NATS"] = 5;
            values[valuesById[6] = "BACKEND_TYPE_NATS_STREAMING"] = 6;
            values[valuesById[7] = "BACKEND_TYPE_GCP_PUBSUB"] = 7;
            values[valuesById[8] = "BACKEND_TYPE_AZURE_SERVICE_BUS"] = 8;
            values[valuesById[9] = "BACKEND_TYPE_AZURE_EVENT_HUB"] = 9;
            values[valuesById[10] = "BACKEND_TYPE_AWS_SQS"] = 10;
            values[valuesById[11] = "BACKEND_TYPE_AWS_SNS"] = 11;
            values[valuesById[12] = "BACKEND_TYPE_REDIS_PUBSUB"] = 12;
            values[valuesById[13] = "BACKEND_TYPE_REDIS_STREAMS"] = 13;
            values[valuesById[14] = "BACKEND_TYPE_ACTIVEMQ"] = 14;
            values[valuesById[15] = "BACKEND_TYPE_PULSAR"] = 15;
            values[valuesById[16] = "BACKEND_TYPE_MQTT"] = 16;
            values[valuesById[17] = "BACKEND_TYPE_POSTGRES_CDC"] = 17;
            values[valuesById[18] = "BACKEND_TYPE_MONGODB_CDC"] = 18;
            values[valuesById[19] = "BACKEND_TYPE_KUBE_MQ"] = 19;
            return values;
        })();

        return common;
    })();

    protos.opts = (function() {

        /**
         * Namespace opts.
         * @memberof protos
         * @namespace
         */
        var opts = {};

        /**
         * Weekday enum.
         * @name protos.opts.Weekday
         * @enum {number}
         * @property {number} WEEKDAY_SUNDAY=0 WEEKDAY_SUNDAY value
         * @property {number} WEEKDAY_MONDAY=1 WEEKDAY_MONDAY value
         * @property {number} WEEKDAY_TUESDAY=2 WEEKDAY_TUESDAY value
         * @property {number} WEEKDAY_WEDNESDAY=3 WEEKDAY_WEDNESDAY value
         * @property {number} WEEKDAY_THURSDAY=4 WEEKDAY_THURSDAY value
         * @property {number} WEEKDAY_FRIDAY=5 WEEKDAY_FRIDAY value
         * @property {number} WEEKDAY_SATURDAY=6 WEEKDAY_SATURDAY value
         */
        opts.Weekday = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "WEEKDAY_SUNDAY"] = 0;
            values[valuesById[1] = "WEEKDAY_MONDAY"] = 1;
            values[valuesById[2] = "WEEKDAY_TUESDAY"] = 2;
            values[valuesById[3] = "WEEKDAY_WEDNESDAY"] = 3;
            values[valuesById[4] = "WEEKDAY_THURSDAY"] = 4;
            values[valuesById[5] = "WEEKDAY_FRIDAY"] = 5;
            values[valuesById[6] = "WEEKDAY_SATURDAY"] = 6;
            return values;
        })();

        opts.AlertTimeRange = (function() {

            /**
             * Properties of an AlertTimeRange.
             * @memberof protos.opts
             * @interface IAlertTimeRange
             * @property {Array.<protos.opts.Weekday>|null} [days] AlertTimeRange days
             * @property {number|null} [fromHour] AlertTimeRange fromHour
             * @property {number|null} [fromMin] AlertTimeRange fromMin
             * @property {number|null} [toHour] AlertTimeRange toHour
             * @property {number|null} [toMin] AlertTimeRange toMin
             */

            /**
             * Constructs a new AlertTimeRange.
             * @memberof protos.opts
             * @classdesc Represents an AlertTimeRange.
             * @implements IAlertTimeRange
             * @constructor
             * @param {protos.opts.IAlertTimeRange=} [properties] Properties to set
             */
            function AlertTimeRange(properties) {
                this.days = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlertTimeRange days.
             * @member {Array.<protos.opts.Weekday>} days
             * @memberof protos.opts.AlertTimeRange
             * @instance
             */
            AlertTimeRange.prototype.days = $util.emptyArray;

            /**
             * AlertTimeRange fromHour.
             * @member {number} fromHour
             * @memberof protos.opts.AlertTimeRange
             * @instance
             */
            AlertTimeRange.prototype.fromHour = 0;

            /**
             * AlertTimeRange fromMin.
             * @member {number} fromMin
             * @memberof protos.opts.AlertTimeRange
             * @instance
             */
            AlertTimeRange.prototype.fromMin = 0;

            /**
             * AlertTimeRange toHour.
             * @member {number} toHour
             * @memberof protos.opts.AlertTimeRange
             * @instance
             */
            AlertTimeRange.prototype.toHour = 0;

            /**
             * AlertTimeRange toMin.
             * @member {number} toMin
             * @memberof protos.opts.AlertTimeRange
             * @instance
             */
            AlertTimeRange.prototype.toMin = 0;

            /**
             * Creates a new AlertTimeRange instance using the specified properties.
             * @function create
             * @memberof protos.opts.AlertTimeRange
             * @static
             * @param {protos.opts.IAlertTimeRange=} [properties] Properties to set
             * @returns {protos.opts.AlertTimeRange} AlertTimeRange instance
             */
            AlertTimeRange.create = function create(properties) {
                return new AlertTimeRange(properties);
            };

            /**
             * Encodes the specified AlertTimeRange message. Does not implicitly {@link protos.opts.AlertTimeRange.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.AlertTimeRange
             * @static
             * @param {protos.opts.IAlertTimeRange} message AlertTimeRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertTimeRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.days != null && message.days.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.days.length; ++i)
                        writer.int32(message.days[i]);
                    writer.ldelim();
                }
                if (message.fromHour != null && Object.hasOwnProperty.call(message, "fromHour"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fromHour);
                if (message.fromMin != null && Object.hasOwnProperty.call(message, "fromMin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.fromMin);
                if (message.toHour != null && Object.hasOwnProperty.call(message, "toHour"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.toHour);
                if (message.toMin != null && Object.hasOwnProperty.call(message, "toMin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.toMin);
                return writer;
            };

            /**
             * Encodes the specified AlertTimeRange message, length delimited. Does not implicitly {@link protos.opts.AlertTimeRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.AlertTimeRange
             * @static
             * @param {protos.opts.IAlertTimeRange} message AlertTimeRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertTimeRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlertTimeRange message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.AlertTimeRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.AlertTimeRange} AlertTimeRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertTimeRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.AlertTimeRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.days && message.days.length))
                            message.days = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.days.push(reader.int32());
                        } else
                            message.days.push(reader.int32());
                        break;
                    case 2:
                        message.fromHour = reader.uint32();
                        break;
                    case 3:
                        message.fromMin = reader.uint32();
                        break;
                    case 4:
                        message.toHour = reader.uint32();
                        break;
                    case 5:
                        message.toMin = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlertTimeRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.AlertTimeRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.AlertTimeRange} AlertTimeRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertTimeRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlertTimeRange message.
             * @function verify
             * @memberof protos.opts.AlertTimeRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlertTimeRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.days != null && message.hasOwnProperty("days")) {
                    if (!Array.isArray(message.days))
                        return "days: array expected";
                    for (var i = 0; i < message.days.length; ++i)
                        switch (message.days[i]) {
                        default:
                            return "days: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                }
                if (message.fromHour != null && message.hasOwnProperty("fromHour"))
                    if (!$util.isInteger(message.fromHour))
                        return "fromHour: integer expected";
                if (message.fromMin != null && message.hasOwnProperty("fromMin"))
                    if (!$util.isInteger(message.fromMin))
                        return "fromMin: integer expected";
                if (message.toHour != null && message.hasOwnProperty("toHour"))
                    if (!$util.isInteger(message.toHour))
                        return "toHour: integer expected";
                if (message.toMin != null && message.hasOwnProperty("toMin"))
                    if (!$util.isInteger(message.toMin))
                        return "toMin: integer expected";
                return null;
            };

            /**
             * Creates an AlertTimeRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.AlertTimeRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.AlertTimeRange} AlertTimeRange
             */
            AlertTimeRange.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.AlertTimeRange)
                    return object;
                var message = new $root.protos.opts.AlertTimeRange();
                if (object.days) {
                    if (!Array.isArray(object.days))
                        throw TypeError(".protos.opts.AlertTimeRange.days: array expected");
                    message.days = [];
                    for (var i = 0; i < object.days.length; ++i)
                        switch (object.days[i]) {
                        default:
                        case "WEEKDAY_SUNDAY":
                        case 0:
                            message.days[i] = 0;
                            break;
                        case "WEEKDAY_MONDAY":
                        case 1:
                            message.days[i] = 1;
                            break;
                        case "WEEKDAY_TUESDAY":
                        case 2:
                            message.days[i] = 2;
                            break;
                        case "WEEKDAY_WEDNESDAY":
                        case 3:
                            message.days[i] = 3;
                            break;
                        case "WEEKDAY_THURSDAY":
                        case 4:
                            message.days[i] = 4;
                            break;
                        case "WEEKDAY_FRIDAY":
                        case 5:
                            message.days[i] = 5;
                            break;
                        case "WEEKDAY_SATURDAY":
                        case 6:
                            message.days[i] = 6;
                            break;
                        }
                }
                if (object.fromHour != null)
                    message.fromHour = object.fromHour >>> 0;
                if (object.fromMin != null)
                    message.fromMin = object.fromMin >>> 0;
                if (object.toHour != null)
                    message.toHour = object.toHour >>> 0;
                if (object.toMin != null)
                    message.toMin = object.toMin >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AlertTimeRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.AlertTimeRange
             * @static
             * @param {protos.opts.AlertTimeRange} message AlertTimeRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlertTimeRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.days = [];
                if (options.defaults) {
                    object.fromHour = 0;
                    object.fromMin = 0;
                    object.toHour = 0;
                    object.toMin = 0;
                }
                if (message.days && message.days.length) {
                    object.days = [];
                    for (var j = 0; j < message.days.length; ++j)
                        object.days[j] = options.enums === String ? $root.protos.opts.Weekday[message.days[j]] : message.days[j];
                }
                if (message.fromHour != null && message.hasOwnProperty("fromHour"))
                    object.fromHour = message.fromHour;
                if (message.fromMin != null && message.hasOwnProperty("fromMin"))
                    object.fromMin = message.fromMin;
                if (message.toHour != null && message.hasOwnProperty("toHour"))
                    object.toHour = message.toHour;
                if (message.toMin != null && message.hasOwnProperty("toMin"))
                    object.toMin = message.toMin;
                return object;
            };

            /**
             * Converts this AlertTimeRange to JSON.
             * @function toJSON
             * @memberof protos.opts.AlertTimeRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlertTimeRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlertTimeRange;
        })();

        opts.AlertSchedule = (function() {

            /**
             * Properties of an AlertSchedule.
             * @memberof protos.opts
             * @interface IAlertSchedule
             * @property {string|null} [timezone] AlertSchedule timezone
             * @property {Array.<protos.opts.IAlertTimeRange>|null} [timeRangeOn] AlertSchedule timeRangeOn
             * @property {Array.<protos.opts.IAlertTimeRange>|null} [timeRangeOff] AlertSchedule timeRangeOff
             */

            /**
             * Constructs a new AlertSchedule.
             * @memberof protos.opts
             * @classdesc Represents an AlertSchedule.
             * @implements IAlertSchedule
             * @constructor
             * @param {protos.opts.IAlertSchedule=} [properties] Properties to set
             */
            function AlertSchedule(properties) {
                this.timeRangeOn = [];
                this.timeRangeOff = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlertSchedule timezone.
             * @member {string} timezone
             * @memberof protos.opts.AlertSchedule
             * @instance
             */
            AlertSchedule.prototype.timezone = "";

            /**
             * AlertSchedule timeRangeOn.
             * @member {Array.<protos.opts.IAlertTimeRange>} timeRangeOn
             * @memberof protos.opts.AlertSchedule
             * @instance
             */
            AlertSchedule.prototype.timeRangeOn = $util.emptyArray;

            /**
             * AlertSchedule timeRangeOff.
             * @member {Array.<protos.opts.IAlertTimeRange>} timeRangeOff
             * @memberof protos.opts.AlertSchedule
             * @instance
             */
            AlertSchedule.prototype.timeRangeOff = $util.emptyArray;

            /**
             * Creates a new AlertSchedule instance using the specified properties.
             * @function create
             * @memberof protos.opts.AlertSchedule
             * @static
             * @param {protos.opts.IAlertSchedule=} [properties] Properties to set
             * @returns {protos.opts.AlertSchedule} AlertSchedule instance
             */
            AlertSchedule.create = function create(properties) {
                return new AlertSchedule(properties);
            };

            /**
             * Encodes the specified AlertSchedule message. Does not implicitly {@link protos.opts.AlertSchedule.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.AlertSchedule
             * @static
             * @param {protos.opts.IAlertSchedule} message AlertSchedule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertSchedule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timezone != null && Object.hasOwnProperty.call(message, "timezone"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.timezone);
                if (message.timeRangeOn != null && message.timeRangeOn.length)
                    for (var i = 0; i < message.timeRangeOn.length; ++i)
                        $root.protos.opts.AlertTimeRange.encode(message.timeRangeOn[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.timeRangeOff != null && message.timeRangeOff.length)
                    for (var i = 0; i < message.timeRangeOff.length; ++i)
                        $root.protos.opts.AlertTimeRange.encode(message.timeRangeOff[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlertSchedule message, length delimited. Does not implicitly {@link protos.opts.AlertSchedule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.AlertSchedule
             * @static
             * @param {protos.opts.IAlertSchedule} message AlertSchedule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertSchedule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlertSchedule message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.AlertSchedule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.AlertSchedule} AlertSchedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertSchedule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.AlertSchedule();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timezone = reader.string();
                        break;
                    case 2:
                        if (!(message.timeRangeOn && message.timeRangeOn.length))
                            message.timeRangeOn = [];
                        message.timeRangeOn.push($root.protos.opts.AlertTimeRange.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.timeRangeOff && message.timeRangeOff.length))
                            message.timeRangeOff = [];
                        message.timeRangeOff.push($root.protos.opts.AlertTimeRange.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlertSchedule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.AlertSchedule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.AlertSchedule} AlertSchedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertSchedule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlertSchedule message.
             * @function verify
             * @memberof protos.opts.AlertSchedule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlertSchedule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timezone != null && message.hasOwnProperty("timezone"))
                    if (!$util.isString(message.timezone))
                        return "timezone: string expected";
                if (message.timeRangeOn != null && message.hasOwnProperty("timeRangeOn")) {
                    if (!Array.isArray(message.timeRangeOn))
                        return "timeRangeOn: array expected";
                    for (var i = 0; i < message.timeRangeOn.length; ++i) {
                        var error = $root.protos.opts.AlertTimeRange.verify(message.timeRangeOn[i]);
                        if (error)
                            return "timeRangeOn." + error;
                    }
                }
                if (message.timeRangeOff != null && message.hasOwnProperty("timeRangeOff")) {
                    if (!Array.isArray(message.timeRangeOff))
                        return "timeRangeOff: array expected";
                    for (var i = 0; i < message.timeRangeOff.length; ++i) {
                        var error = $root.protos.opts.AlertTimeRange.verify(message.timeRangeOff[i]);
                        if (error)
                            return "timeRangeOff." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an AlertSchedule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.AlertSchedule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.AlertSchedule} AlertSchedule
             */
            AlertSchedule.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.AlertSchedule)
                    return object;
                var message = new $root.protos.opts.AlertSchedule();
                if (object.timezone != null)
                    message.timezone = String(object.timezone);
                if (object.timeRangeOn) {
                    if (!Array.isArray(object.timeRangeOn))
                        throw TypeError(".protos.opts.AlertSchedule.timeRangeOn: array expected");
                    message.timeRangeOn = [];
                    for (var i = 0; i < object.timeRangeOn.length; ++i) {
                        if (typeof object.timeRangeOn[i] !== "object")
                            throw TypeError(".protos.opts.AlertSchedule.timeRangeOn: object expected");
                        message.timeRangeOn[i] = $root.protos.opts.AlertTimeRange.fromObject(object.timeRangeOn[i]);
                    }
                }
                if (object.timeRangeOff) {
                    if (!Array.isArray(object.timeRangeOff))
                        throw TypeError(".protos.opts.AlertSchedule.timeRangeOff: array expected");
                    message.timeRangeOff = [];
                    for (var i = 0; i < object.timeRangeOff.length; ++i) {
                        if (typeof object.timeRangeOff[i] !== "object")
                            throw TypeError(".protos.opts.AlertSchedule.timeRangeOff: object expected");
                        message.timeRangeOff[i] = $root.protos.opts.AlertTimeRange.fromObject(object.timeRangeOff[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an AlertSchedule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.AlertSchedule
             * @static
             * @param {protos.opts.AlertSchedule} message AlertSchedule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlertSchedule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.timeRangeOn = [];
                    object.timeRangeOff = [];
                }
                if (options.defaults)
                    object.timezone = "";
                if (message.timezone != null && message.hasOwnProperty("timezone"))
                    object.timezone = message.timezone;
                if (message.timeRangeOn && message.timeRangeOn.length) {
                    object.timeRangeOn = [];
                    for (var j = 0; j < message.timeRangeOn.length; ++j)
                        object.timeRangeOn[j] = $root.protos.opts.AlertTimeRange.toObject(message.timeRangeOn[j], options);
                }
                if (message.timeRangeOff && message.timeRangeOff.length) {
                    object.timeRangeOff = [];
                    for (var j = 0; j < message.timeRangeOff.length; ++j)
                        object.timeRangeOff[j] = $root.protos.opts.AlertTimeRange.toObject(message.timeRangeOff[j], options);
                }
                return object;
            };

            /**
             * Converts this AlertSchedule to JSON.
             * @function toJSON
             * @memberof protos.opts.AlertSchedule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlertSchedule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlertSchedule;
        })();

        opts.AlertOptions = (function() {

            /**
             * Properties of an AlertOptions.
             * @memberof protos.opts
             * @interface IAlertOptions
             * @property {Array.<string>|null} [monitorIds] AlertOptions monitorIds
             * @property {Array.<protos.opts.IAlertOutput>|null} [outputs] AlertOptions outputs
             * @property {protos.opts.IAlertSchedule|null} [schedule] AlertOptions schedule
             */

            /**
             * Constructs a new AlertOptions.
             * @memberof protos.opts
             * @classdesc Represents an AlertOptions.
             * @implements IAlertOptions
             * @constructor
             * @param {protos.opts.IAlertOptions=} [properties] Properties to set
             */
            function AlertOptions(properties) {
                this.monitorIds = [];
                this.outputs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlertOptions monitorIds.
             * @member {Array.<string>} monitorIds
             * @memberof protos.opts.AlertOptions
             * @instance
             */
            AlertOptions.prototype.monitorIds = $util.emptyArray;

            /**
             * AlertOptions outputs.
             * @member {Array.<protos.opts.IAlertOutput>} outputs
             * @memberof protos.opts.AlertOptions
             * @instance
             */
            AlertOptions.prototype.outputs = $util.emptyArray;

            /**
             * AlertOptions schedule.
             * @member {protos.opts.IAlertSchedule|null|undefined} schedule
             * @memberof protos.opts.AlertOptions
             * @instance
             */
            AlertOptions.prototype.schedule = null;

            /**
             * Creates a new AlertOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.AlertOptions
             * @static
             * @param {protos.opts.IAlertOptions=} [properties] Properties to set
             * @returns {protos.opts.AlertOptions} AlertOptions instance
             */
            AlertOptions.create = function create(properties) {
                return new AlertOptions(properties);
            };

            /**
             * Encodes the specified AlertOptions message. Does not implicitly {@link protos.opts.AlertOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.AlertOptions
             * @static
             * @param {protos.opts.IAlertOptions} message AlertOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.monitorIds != null && message.monitorIds.length)
                    for (var i = 0; i < message.monitorIds.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.monitorIds[i]);
                if (message.outputs != null && message.outputs.length)
                    for (var i = 0; i < message.outputs.length; ++i)
                        $root.protos.opts.AlertOutput.encode(message.outputs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.schedule != null && Object.hasOwnProperty.call(message, "schedule"))
                    $root.protos.opts.AlertSchedule.encode(message.schedule, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlertOptions message, length delimited. Does not implicitly {@link protos.opts.AlertOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.AlertOptions
             * @static
             * @param {protos.opts.IAlertOptions} message AlertOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlertOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.AlertOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.AlertOptions} AlertOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.AlertOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.monitorIds && message.monitorIds.length))
                            message.monitorIds = [];
                        message.monitorIds.push(reader.string());
                        break;
                    case 2:
                        if (!(message.outputs && message.outputs.length))
                            message.outputs = [];
                        message.outputs.push($root.protos.opts.AlertOutput.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.schedule = $root.protos.opts.AlertSchedule.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlertOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.AlertOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.AlertOptions} AlertOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlertOptions message.
             * @function verify
             * @memberof protos.opts.AlertOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlertOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.monitorIds != null && message.hasOwnProperty("monitorIds")) {
                    if (!Array.isArray(message.monitorIds))
                        return "monitorIds: array expected";
                    for (var i = 0; i < message.monitorIds.length; ++i)
                        if (!$util.isString(message.monitorIds[i]))
                            return "monitorIds: string[] expected";
                }
                if (message.outputs != null && message.hasOwnProperty("outputs")) {
                    if (!Array.isArray(message.outputs))
                        return "outputs: array expected";
                    for (var i = 0; i < message.outputs.length; ++i) {
                        var error = $root.protos.opts.AlertOutput.verify(message.outputs[i]);
                        if (error)
                            return "outputs." + error;
                    }
                }
                if (message.schedule != null && message.hasOwnProperty("schedule")) {
                    var error = $root.protos.opts.AlertSchedule.verify(message.schedule);
                    if (error)
                        return "schedule." + error;
                }
                return null;
            };

            /**
             * Creates an AlertOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.AlertOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.AlertOptions} AlertOptions
             */
            AlertOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.AlertOptions)
                    return object;
                var message = new $root.protos.opts.AlertOptions();
                if (object.monitorIds) {
                    if (!Array.isArray(object.monitorIds))
                        throw TypeError(".protos.opts.AlertOptions.monitorIds: array expected");
                    message.monitorIds = [];
                    for (var i = 0; i < object.monitorIds.length; ++i)
                        message.monitorIds[i] = String(object.monitorIds[i]);
                }
                if (object.outputs) {
                    if (!Array.isArray(object.outputs))
                        throw TypeError(".protos.opts.AlertOptions.outputs: array expected");
                    message.outputs = [];
                    for (var i = 0; i < object.outputs.length; ++i) {
                        if (typeof object.outputs[i] !== "object")
                            throw TypeError(".protos.opts.AlertOptions.outputs: object expected");
                        message.outputs[i] = $root.protos.opts.AlertOutput.fromObject(object.outputs[i]);
                    }
                }
                if (object.schedule != null) {
                    if (typeof object.schedule !== "object")
                        throw TypeError(".protos.opts.AlertOptions.schedule: object expected");
                    message.schedule = $root.protos.opts.AlertSchedule.fromObject(object.schedule);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlertOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.AlertOptions
             * @static
             * @param {protos.opts.AlertOptions} message AlertOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlertOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.monitorIds = [];
                    object.outputs = [];
                }
                if (options.defaults)
                    object.schedule = null;
                if (message.monitorIds && message.monitorIds.length) {
                    object.monitorIds = [];
                    for (var j = 0; j < message.monitorIds.length; ++j)
                        object.monitorIds[j] = message.monitorIds[j];
                }
                if (message.outputs && message.outputs.length) {
                    object.outputs = [];
                    for (var j = 0; j < message.outputs.length; ++j)
                        object.outputs[j] = $root.protos.opts.AlertOutput.toObject(message.outputs[j], options);
                }
                if (message.schedule != null && message.hasOwnProperty("schedule"))
                    object.schedule = $root.protos.opts.AlertSchedule.toObject(message.schedule, options);
                return object;
            };

            /**
             * Converts this AlertOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.AlertOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlertOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlertOptions;
        })();

        opts.AlertOutput = (function() {

            /**
             * Properties of an AlertOutput.
             * @memberof protos.opts
             * @interface IAlertOutput
             * @property {protos.opts.IAlertEmailOutput|null} [email] AlertOutput email
             * @property {protos.opts.IAlertSlackOutput|null} [slack] AlertOutput slack
             * @property {protos.opts.IAlertPagerdutyOutput|null} [pagerduty] AlertOutput pagerduty
             */

            /**
             * Constructs a new AlertOutput.
             * @memberof protos.opts
             * @classdesc Represents an AlertOutput.
             * @implements IAlertOutput
             * @constructor
             * @param {protos.opts.IAlertOutput=} [properties] Properties to set
             */
            function AlertOutput(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlertOutput email.
             * @member {protos.opts.IAlertEmailOutput|null|undefined} email
             * @memberof protos.opts.AlertOutput
             * @instance
             */
            AlertOutput.prototype.email = null;

            /**
             * AlertOutput slack.
             * @member {protos.opts.IAlertSlackOutput|null|undefined} slack
             * @memberof protos.opts.AlertOutput
             * @instance
             */
            AlertOutput.prototype.slack = null;

            /**
             * AlertOutput pagerduty.
             * @member {protos.opts.IAlertPagerdutyOutput|null|undefined} pagerduty
             * @memberof protos.opts.AlertOutput
             * @instance
             */
            AlertOutput.prototype.pagerduty = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * AlertOutput output.
             * @member {"email"|"slack"|"pagerduty"|undefined} output
             * @memberof protos.opts.AlertOutput
             * @instance
             */
            Object.defineProperty(AlertOutput.prototype, "output", {
                get: $util.oneOfGetter($oneOfFields = ["email", "slack", "pagerduty"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new AlertOutput instance using the specified properties.
             * @function create
             * @memberof protos.opts.AlertOutput
             * @static
             * @param {protos.opts.IAlertOutput=} [properties] Properties to set
             * @returns {protos.opts.AlertOutput} AlertOutput instance
             */
            AlertOutput.create = function create(properties) {
                return new AlertOutput(properties);
            };

            /**
             * Encodes the specified AlertOutput message. Does not implicitly {@link protos.opts.AlertOutput.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.AlertOutput
             * @static
             * @param {protos.opts.IAlertOutput} message AlertOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertOutput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.email != null && Object.hasOwnProperty.call(message, "email"))
                    $root.protos.opts.AlertEmailOutput.encode(message.email, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.slack != null && Object.hasOwnProperty.call(message, "slack"))
                    $root.protos.opts.AlertSlackOutput.encode(message.slack, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.pagerduty != null && Object.hasOwnProperty.call(message, "pagerduty"))
                    $root.protos.opts.AlertPagerdutyOutput.encode(message.pagerduty, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlertOutput message, length delimited. Does not implicitly {@link protos.opts.AlertOutput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.AlertOutput
             * @static
             * @param {protos.opts.IAlertOutput} message AlertOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertOutput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlertOutput message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.AlertOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.AlertOutput} AlertOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertOutput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.AlertOutput();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 100:
                        message.email = $root.protos.opts.AlertEmailOutput.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.slack = $root.protos.opts.AlertSlackOutput.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.pagerduty = $root.protos.opts.AlertPagerdutyOutput.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlertOutput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.AlertOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.AlertOutput} AlertOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertOutput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlertOutput message.
             * @function verify
             * @memberof protos.opts.AlertOutput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlertOutput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.email != null && message.hasOwnProperty("email")) {
                    properties.output = 1;
                    {
                        var error = $root.protos.opts.AlertEmailOutput.verify(message.email);
                        if (error)
                            return "email." + error;
                    }
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    if (properties.output === 1)
                        return "output: multiple values";
                    properties.output = 1;
                    {
                        var error = $root.protos.opts.AlertSlackOutput.verify(message.slack);
                        if (error)
                            return "slack." + error;
                    }
                }
                if (message.pagerduty != null && message.hasOwnProperty("pagerduty")) {
                    if (properties.output === 1)
                        return "output: multiple values";
                    properties.output = 1;
                    {
                        var error = $root.protos.opts.AlertPagerdutyOutput.verify(message.pagerduty);
                        if (error)
                            return "pagerduty." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an AlertOutput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.AlertOutput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.AlertOutput} AlertOutput
             */
            AlertOutput.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.AlertOutput)
                    return object;
                var message = new $root.protos.opts.AlertOutput();
                if (object.email != null) {
                    if (typeof object.email !== "object")
                        throw TypeError(".protos.opts.AlertOutput.email: object expected");
                    message.email = $root.protos.opts.AlertEmailOutput.fromObject(object.email);
                }
                if (object.slack != null) {
                    if (typeof object.slack !== "object")
                        throw TypeError(".protos.opts.AlertOutput.slack: object expected");
                    message.slack = $root.protos.opts.AlertSlackOutput.fromObject(object.slack);
                }
                if (object.pagerduty != null) {
                    if (typeof object.pagerduty !== "object")
                        throw TypeError(".protos.opts.AlertOutput.pagerduty: object expected");
                    message.pagerduty = $root.protos.opts.AlertPagerdutyOutput.fromObject(object.pagerduty);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlertOutput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.AlertOutput
             * @static
             * @param {protos.opts.AlertOutput} message AlertOutput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlertOutput.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.email != null && message.hasOwnProperty("email")) {
                    object.email = $root.protos.opts.AlertEmailOutput.toObject(message.email, options);
                    if (options.oneofs)
                        object.output = "email";
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    object.slack = $root.protos.opts.AlertSlackOutput.toObject(message.slack, options);
                    if (options.oneofs)
                        object.output = "slack";
                }
                if (message.pagerduty != null && message.hasOwnProperty("pagerduty")) {
                    object.pagerduty = $root.protos.opts.AlertPagerdutyOutput.toObject(message.pagerduty, options);
                    if (options.oneofs)
                        object.output = "pagerduty";
                }
                return object;
            };

            /**
             * Converts this AlertOutput to JSON.
             * @function toJSON
             * @memberof protos.opts.AlertOutput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlertOutput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlertOutput;
        })();

        opts.AlertEmailOutput = (function() {

            /**
             * Properties of an AlertEmailOutput.
             * @memberof protos.opts
             * @interface IAlertEmailOutput
             * @property {Array.<string>|null} [emailAddress] AlertEmailOutput emailAddress
             * @property {string|null} [subject] AlertEmailOutput subject
             * @property {Object.<string,string>|null} [metadata] AlertEmailOutput metadata
             * @property {protos.opts.AlertEmailOutput.ISMTPServer|null} [smtpServer] AlertEmailOutput smtpServer
             */

            /**
             * Constructs a new AlertEmailOutput.
             * @memberof protos.opts
             * @classdesc Represents an AlertEmailOutput.
             * @implements IAlertEmailOutput
             * @constructor
             * @param {protos.opts.IAlertEmailOutput=} [properties] Properties to set
             */
            function AlertEmailOutput(properties) {
                this.emailAddress = [];
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlertEmailOutput emailAddress.
             * @member {Array.<string>} emailAddress
             * @memberof protos.opts.AlertEmailOutput
             * @instance
             */
            AlertEmailOutput.prototype.emailAddress = $util.emptyArray;

            /**
             * AlertEmailOutput subject.
             * @member {string} subject
             * @memberof protos.opts.AlertEmailOutput
             * @instance
             */
            AlertEmailOutput.prototype.subject = "";

            /**
             * AlertEmailOutput metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.opts.AlertEmailOutput
             * @instance
             */
            AlertEmailOutput.prototype.metadata = $util.emptyObject;

            /**
             * AlertEmailOutput smtpServer.
             * @member {protos.opts.AlertEmailOutput.ISMTPServer|null|undefined} smtpServer
             * @memberof protos.opts.AlertEmailOutput
             * @instance
             */
            AlertEmailOutput.prototype.smtpServer = null;

            /**
             * Creates a new AlertEmailOutput instance using the specified properties.
             * @function create
             * @memberof protos.opts.AlertEmailOutput
             * @static
             * @param {protos.opts.IAlertEmailOutput=} [properties] Properties to set
             * @returns {protos.opts.AlertEmailOutput} AlertEmailOutput instance
             */
            AlertEmailOutput.create = function create(properties) {
                return new AlertEmailOutput(properties);
            };

            /**
             * Encodes the specified AlertEmailOutput message. Does not implicitly {@link protos.opts.AlertEmailOutput.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.AlertEmailOutput
             * @static
             * @param {protos.opts.IAlertEmailOutput} message AlertEmailOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertEmailOutput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.emailAddress != null && message.emailAddress.length)
                    for (var i = 0; i < message.emailAddress.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.emailAddress[i]);
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.subject);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.smtpServer != null && Object.hasOwnProperty.call(message, "smtpServer"))
                    $root.protos.opts.AlertEmailOutput.SMTPServer.encode(message.smtpServer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlertEmailOutput message, length delimited. Does not implicitly {@link protos.opts.AlertEmailOutput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.AlertEmailOutput
             * @static
             * @param {protos.opts.IAlertEmailOutput} message AlertEmailOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertEmailOutput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlertEmailOutput message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.AlertEmailOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.AlertEmailOutput} AlertEmailOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertEmailOutput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.AlertEmailOutput(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.emailAddress && message.emailAddress.length))
                            message.emailAddress = [];
                        message.emailAddress.push(reader.string());
                        break;
                    case 2:
                        message.subject = reader.string();
                        break;
                    case 3:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 4:
                        message.smtpServer = $root.protos.opts.AlertEmailOutput.SMTPServer.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlertEmailOutput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.AlertEmailOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.AlertEmailOutput} AlertEmailOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertEmailOutput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlertEmailOutput message.
             * @function verify
             * @memberof protos.opts.AlertEmailOutput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlertEmailOutput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.emailAddress != null && message.hasOwnProperty("emailAddress")) {
                    if (!Array.isArray(message.emailAddress))
                        return "emailAddress: array expected";
                    for (var i = 0; i < message.emailAddress.length; ++i)
                        if (!$util.isString(message.emailAddress[i]))
                            return "emailAddress: string[] expected";
                }
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.smtpServer != null && message.hasOwnProperty("smtpServer")) {
                    var error = $root.protos.opts.AlertEmailOutput.SMTPServer.verify(message.smtpServer);
                    if (error)
                        return "smtpServer." + error;
                }
                return null;
            };

            /**
             * Creates an AlertEmailOutput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.AlertEmailOutput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.AlertEmailOutput} AlertEmailOutput
             */
            AlertEmailOutput.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.AlertEmailOutput)
                    return object;
                var message = new $root.protos.opts.AlertEmailOutput();
                if (object.emailAddress) {
                    if (!Array.isArray(object.emailAddress))
                        throw TypeError(".protos.opts.AlertEmailOutput.emailAddress: array expected");
                    message.emailAddress = [];
                    for (var i = 0; i < object.emailAddress.length; ++i)
                        message.emailAddress[i] = String(object.emailAddress[i]);
                }
                if (object.subject != null)
                    message.subject = String(object.subject);
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.opts.AlertEmailOutput.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.smtpServer != null) {
                    if (typeof object.smtpServer !== "object")
                        throw TypeError(".protos.opts.AlertEmailOutput.smtpServer: object expected");
                    message.smtpServer = $root.protos.opts.AlertEmailOutput.SMTPServer.fromObject(object.smtpServer);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlertEmailOutput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.AlertEmailOutput
             * @static
             * @param {protos.opts.AlertEmailOutput} message AlertEmailOutput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlertEmailOutput.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.emailAddress = [];
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    object.subject = "";
                    object.smtpServer = null;
                }
                if (message.emailAddress && message.emailAddress.length) {
                    object.emailAddress = [];
                    for (var j = 0; j < message.emailAddress.length; ++j)
                        object.emailAddress[j] = message.emailAddress[j];
                }
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.smtpServer != null && message.hasOwnProperty("smtpServer"))
                    object.smtpServer = $root.protos.opts.AlertEmailOutput.SMTPServer.toObject(message.smtpServer, options);
                return object;
            };

            /**
             * Converts this AlertEmailOutput to JSON.
             * @function toJSON
             * @memberof protos.opts.AlertEmailOutput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlertEmailOutput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            AlertEmailOutput.SMTPServer = (function() {

                /**
                 * Properties of a SMTPServer.
                 * @memberof protos.opts.AlertEmailOutput
                 * @interface ISMTPServer
                 * @property {string|null} [username] SMTPServer username
                 * @property {string|null} [password] SMTPServer password
                 * @property {string|null} [hostname] SMTPServer hostname
                 * @property {number|null} [port] SMTPServer port
                 * @property {boolean|null} [useTls] SMTPServer useTls
                 * @property {string|null} [fromAddress] SMTPServer fromAddress
                 */

                /**
                 * Constructs a new SMTPServer.
                 * @memberof protos.opts.AlertEmailOutput
                 * @classdesc Represents a SMTPServer.
                 * @implements ISMTPServer
                 * @constructor
                 * @param {protos.opts.AlertEmailOutput.ISMTPServer=} [properties] Properties to set
                 */
                function SMTPServer(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SMTPServer username.
                 * @member {string} username
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @instance
                 */
                SMTPServer.prototype.username = "";

                /**
                 * SMTPServer password.
                 * @member {string} password
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @instance
                 */
                SMTPServer.prototype.password = "";

                /**
                 * SMTPServer hostname.
                 * @member {string} hostname
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @instance
                 */
                SMTPServer.prototype.hostname = "";

                /**
                 * SMTPServer port.
                 * @member {number} port
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @instance
                 */
                SMTPServer.prototype.port = 0;

                /**
                 * SMTPServer useTls.
                 * @member {boolean} useTls
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @instance
                 */
                SMTPServer.prototype.useTls = false;

                /**
                 * SMTPServer fromAddress.
                 * @member {string} fromAddress
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @instance
                 */
                SMTPServer.prototype.fromAddress = "";

                /**
                 * Creates a new SMTPServer instance using the specified properties.
                 * @function create
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @static
                 * @param {protos.opts.AlertEmailOutput.ISMTPServer=} [properties] Properties to set
                 * @returns {protos.opts.AlertEmailOutput.SMTPServer} SMTPServer instance
                 */
                SMTPServer.create = function create(properties) {
                    return new SMTPServer(properties);
                };

                /**
                 * Encodes the specified SMTPServer message. Does not implicitly {@link protos.opts.AlertEmailOutput.SMTPServer.verify|verify} messages.
                 * @function encode
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @static
                 * @param {protos.opts.AlertEmailOutput.ISMTPServer} message SMTPServer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SMTPServer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
                    if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
                    if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.hostname);
                    if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.port);
                    if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.useTls);
                    if (message.fromAddress != null && Object.hasOwnProperty.call(message, "fromAddress"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.fromAddress);
                    return writer;
                };

                /**
                 * Encodes the specified SMTPServer message, length delimited. Does not implicitly {@link protos.opts.AlertEmailOutput.SMTPServer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @static
                 * @param {protos.opts.AlertEmailOutput.ISMTPServer} message SMTPServer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SMTPServer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SMTPServer message from the specified reader or buffer.
                 * @function decode
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {protos.opts.AlertEmailOutput.SMTPServer} SMTPServer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SMTPServer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.AlertEmailOutput.SMTPServer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.username = reader.string();
                            break;
                        case 2:
                            message.password = reader.string();
                            break;
                        case 3:
                            message.hostname = reader.string();
                            break;
                        case 4:
                            message.port = reader.int32();
                            break;
                        case 5:
                            message.useTls = reader.bool();
                            break;
                        case 6:
                            message.fromAddress = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SMTPServer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {protos.opts.AlertEmailOutput.SMTPServer} SMTPServer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SMTPServer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SMTPServer message.
                 * @function verify
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SMTPServer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.username != null && message.hasOwnProperty("username"))
                        if (!$util.isString(message.username))
                            return "username: string expected";
                    if (message.password != null && message.hasOwnProperty("password"))
                        if (!$util.isString(message.password))
                            return "password: string expected";
                    if (message.hostname != null && message.hasOwnProperty("hostname"))
                        if (!$util.isString(message.hostname))
                            return "hostname: string expected";
                    if (message.port != null && message.hasOwnProperty("port"))
                        if (!$util.isInteger(message.port))
                            return "port: integer expected";
                    if (message.useTls != null && message.hasOwnProperty("useTls"))
                        if (typeof message.useTls !== "boolean")
                            return "useTls: boolean expected";
                    if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                        if (!$util.isString(message.fromAddress))
                            return "fromAddress: string expected";
                    return null;
                };

                /**
                 * Creates a SMTPServer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {protos.opts.AlertEmailOutput.SMTPServer} SMTPServer
                 */
                SMTPServer.fromObject = function fromObject(object) {
                    if (object instanceof $root.protos.opts.AlertEmailOutput.SMTPServer)
                        return object;
                    var message = new $root.protos.opts.AlertEmailOutput.SMTPServer();
                    if (object.username != null)
                        message.username = String(object.username);
                    if (object.password != null)
                        message.password = String(object.password);
                    if (object.hostname != null)
                        message.hostname = String(object.hostname);
                    if (object.port != null)
                        message.port = object.port | 0;
                    if (object.useTls != null)
                        message.useTls = Boolean(object.useTls);
                    if (object.fromAddress != null)
                        message.fromAddress = String(object.fromAddress);
                    return message;
                };

                /**
                 * Creates a plain object from a SMTPServer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @static
                 * @param {protos.opts.AlertEmailOutput.SMTPServer} message SMTPServer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SMTPServer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.username = "";
                        object.password = "";
                        object.hostname = "";
                        object.port = 0;
                        object.useTls = false;
                        object.fromAddress = "";
                    }
                    if (message.username != null && message.hasOwnProperty("username"))
                        object.username = message.username;
                    if (message.password != null && message.hasOwnProperty("password"))
                        object.password = message.password;
                    if (message.hostname != null && message.hasOwnProperty("hostname"))
                        object.hostname = message.hostname;
                    if (message.port != null && message.hasOwnProperty("port"))
                        object.port = message.port;
                    if (message.useTls != null && message.hasOwnProperty("useTls"))
                        object.useTls = message.useTls;
                    if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                        object.fromAddress = message.fromAddress;
                    return object;
                };

                /**
                 * Converts this SMTPServer to JSON.
                 * @function toJSON
                 * @memberof protos.opts.AlertEmailOutput.SMTPServer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SMTPServer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SMTPServer;
            })();

            return AlertEmailOutput;
        })();

        opts.AlertSlackOutput = (function() {

            /**
             * Properties of an AlertSlackOutput.
             * @memberof protos.opts
             * @interface IAlertSlackOutput
             * @property {Array.<string>|null} [channelId] AlertSlackOutput channelId
             * @property {string|null} [authToken] AlertSlackOutput authToken
             * @property {Object.<string,string>|null} [metadata] AlertSlackOutput metadata
             */

            /**
             * Constructs a new AlertSlackOutput.
             * @memberof protos.opts
             * @classdesc Represents an AlertSlackOutput.
             * @implements IAlertSlackOutput
             * @constructor
             * @param {protos.opts.IAlertSlackOutput=} [properties] Properties to set
             */
            function AlertSlackOutput(properties) {
                this.channelId = [];
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlertSlackOutput channelId.
             * @member {Array.<string>} channelId
             * @memberof protos.opts.AlertSlackOutput
             * @instance
             */
            AlertSlackOutput.prototype.channelId = $util.emptyArray;

            /**
             * AlertSlackOutput authToken.
             * @member {string} authToken
             * @memberof protos.opts.AlertSlackOutput
             * @instance
             */
            AlertSlackOutput.prototype.authToken = "";

            /**
             * AlertSlackOutput metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.opts.AlertSlackOutput
             * @instance
             */
            AlertSlackOutput.prototype.metadata = $util.emptyObject;

            /**
             * Creates a new AlertSlackOutput instance using the specified properties.
             * @function create
             * @memberof protos.opts.AlertSlackOutput
             * @static
             * @param {protos.opts.IAlertSlackOutput=} [properties] Properties to set
             * @returns {protos.opts.AlertSlackOutput} AlertSlackOutput instance
             */
            AlertSlackOutput.create = function create(properties) {
                return new AlertSlackOutput(properties);
            };

            /**
             * Encodes the specified AlertSlackOutput message. Does not implicitly {@link protos.opts.AlertSlackOutput.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.AlertSlackOutput
             * @static
             * @param {protos.opts.IAlertSlackOutput} message AlertSlackOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertSlackOutput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channelId != null && message.channelId.length)
                    for (var i = 0; i < message.channelId.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId[i]);
                if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.authToken);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlertSlackOutput message, length delimited. Does not implicitly {@link protos.opts.AlertSlackOutput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.AlertSlackOutput
             * @static
             * @param {protos.opts.IAlertSlackOutput} message AlertSlackOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertSlackOutput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlertSlackOutput message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.AlertSlackOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.AlertSlackOutput} AlertSlackOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertSlackOutput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.AlertSlackOutput(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.channelId && message.channelId.length))
                            message.channelId = [];
                        message.channelId.push(reader.string());
                        break;
                    case 2:
                        message.authToken = reader.string();
                        break;
                    case 3:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlertSlackOutput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.AlertSlackOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.AlertSlackOutput} AlertSlackOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertSlackOutput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlertSlackOutput message.
             * @function verify
             * @memberof protos.opts.AlertSlackOutput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlertSlackOutput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channelId != null && message.hasOwnProperty("channelId")) {
                    if (!Array.isArray(message.channelId))
                        return "channelId: array expected";
                    for (var i = 0; i < message.channelId.length; ++i)
                        if (!$util.isString(message.channelId[i]))
                            return "channelId: string[] expected";
                }
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    if (!$util.isString(message.authToken))
                        return "authToken: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an AlertSlackOutput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.AlertSlackOutput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.AlertSlackOutput} AlertSlackOutput
             */
            AlertSlackOutput.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.AlertSlackOutput)
                    return object;
                var message = new $root.protos.opts.AlertSlackOutput();
                if (object.channelId) {
                    if (!Array.isArray(object.channelId))
                        throw TypeError(".protos.opts.AlertSlackOutput.channelId: array expected");
                    message.channelId = [];
                    for (var i = 0; i < object.channelId.length; ++i)
                        message.channelId[i] = String(object.channelId[i]);
                }
                if (object.authToken != null)
                    message.authToken = String(object.authToken);
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.opts.AlertSlackOutput.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlertSlackOutput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.AlertSlackOutput
             * @static
             * @param {protos.opts.AlertSlackOutput} message AlertSlackOutput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlertSlackOutput.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.channelId = [];
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults)
                    object.authToken = "";
                if (message.channelId && message.channelId.length) {
                    object.channelId = [];
                    for (var j = 0; j < message.channelId.length; ++j)
                        object.channelId[j] = message.channelId[j];
                }
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    object.authToken = message.authToken;
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this AlertSlackOutput to JSON.
             * @function toJSON
             * @memberof protos.opts.AlertSlackOutput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlertSlackOutput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlertSlackOutput;
        })();

        opts.AlertPagerdutyOutput = (function() {

            /**
             * Properties of an AlertPagerdutyOutput.
             * @memberof protos.opts
             * @interface IAlertPagerdutyOutput
             */

            /**
             * Constructs a new AlertPagerdutyOutput.
             * @memberof protos.opts
             * @classdesc Represents an AlertPagerdutyOutput.
             * @implements IAlertPagerdutyOutput
             * @constructor
             * @param {protos.opts.IAlertPagerdutyOutput=} [properties] Properties to set
             */
            function AlertPagerdutyOutput(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AlertPagerdutyOutput instance using the specified properties.
             * @function create
             * @memberof protos.opts.AlertPagerdutyOutput
             * @static
             * @param {protos.opts.IAlertPagerdutyOutput=} [properties] Properties to set
             * @returns {protos.opts.AlertPagerdutyOutput} AlertPagerdutyOutput instance
             */
            AlertPagerdutyOutput.create = function create(properties) {
                return new AlertPagerdutyOutput(properties);
            };

            /**
             * Encodes the specified AlertPagerdutyOutput message. Does not implicitly {@link protos.opts.AlertPagerdutyOutput.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.AlertPagerdutyOutput
             * @static
             * @param {protos.opts.IAlertPagerdutyOutput} message AlertPagerdutyOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertPagerdutyOutput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AlertPagerdutyOutput message, length delimited. Does not implicitly {@link protos.opts.AlertPagerdutyOutput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.AlertPagerdutyOutput
             * @static
             * @param {protos.opts.IAlertPagerdutyOutput} message AlertPagerdutyOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlertPagerdutyOutput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlertPagerdutyOutput message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.AlertPagerdutyOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.AlertPagerdutyOutput} AlertPagerdutyOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertPagerdutyOutput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.AlertPagerdutyOutput();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlertPagerdutyOutput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.AlertPagerdutyOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.AlertPagerdutyOutput} AlertPagerdutyOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlertPagerdutyOutput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlertPagerdutyOutput message.
             * @function verify
             * @memberof protos.opts.AlertPagerdutyOutput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlertPagerdutyOutput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AlertPagerdutyOutput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.AlertPagerdutyOutput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.AlertPagerdutyOutput} AlertPagerdutyOutput
             */
            AlertPagerdutyOutput.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.AlertPagerdutyOutput)
                    return object;
                return new $root.protos.opts.AlertPagerdutyOutput();
            };

            /**
             * Creates a plain object from an AlertPagerdutyOutput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.AlertPagerdutyOutput
             * @static
             * @param {protos.opts.AlertPagerdutyOutput} message AlertPagerdutyOutput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlertPagerdutyOutput.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AlertPagerdutyOutput to JSON.
             * @function toJSON
             * @memberof protos.opts.AlertPagerdutyOutput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlertPagerdutyOutput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlertPagerdutyOutput;
        })();

        opts.ConnectionOptions = (function() {

            /**
             * Properties of a ConnectionOptions.
             * @memberof protos.opts
             * @interface IConnectionOptions
             * @property {string|null} [name] ConnectionOptions name
             * @property {string|null} [notes] ConnectionOptions notes
             * @property {protos.args.IKafkaConn|null} [kafka] ConnectionOptions kafka
             * @property {protos.args.IActiveMQConn|null} [activeMq] ConnectionOptions activeMq
             * @property {protos.args.IAWSSQSConn|null} [awssqs] ConnectionOptions awssqs
             * @property {protos.args.IAWSSNSConn|null} [awssns] ConnectionOptions awssns
             * @property {protos.args.IMongoConn|null} [mongo] ConnectionOptions mongo
             * @property {protos.args.INatsConn|null} [nats] ConnectionOptions nats
             * @property {protos.args.INatsStreamingConn|null} [natsStreaming] ConnectionOptions natsStreaming
             * @property {protos.args.INSQConn|null} [nsq] ConnectionOptions nsq
             * @property {protos.args.IPostgresConn|null} [postgres] ConnectionOptions postgres
             * @property {protos.args.IPulsarConn|null} [pulsar] ConnectionOptions pulsar
             * @property {protos.args.IRabbitConn|null} [rabbit] ConnectionOptions rabbit
             * @property {protos.args.IRabbitStreamsConn|null} [rabbitStreams] ConnectionOptions rabbitStreams
             * @property {protos.args.IRedisPubSubConn|null} [redisPubsub] ConnectionOptions redisPubsub
             * @property {protos.args.IRedisStreamsConn|null} [redisStreams] ConnectionOptions redisStreams
             * @property {protos.args.IAzureEventHubConn|null} [azureEventHub] ConnectionOptions azureEventHub
             * @property {protos.args.IAzureServiceBusConn|null} [azureServiceBus] ConnectionOptions azureServiceBus
             * @property {protos.args.IMQTTConn|null} [mqtt] ConnectionOptions mqtt
             * @property {protos.args.IKubeMQQueueConn|null} [kubemqQueue] ConnectionOptions kubemqQueue
             * @property {protos.args.IGCPPubSubConn|null} [gcpPubsub] ConnectionOptions gcpPubsub
             * @property {string|null} [_id] ConnectionOptions _id
             */

            /**
             * Constructs a new ConnectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a ConnectionOptions.
             * @implements IConnectionOptions
             * @constructor
             * @param {protos.opts.IConnectionOptions=} [properties] Properties to set
             */
            function ConnectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConnectionOptions name.
             * @member {string} name
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.name = "";

            /**
             * ConnectionOptions notes.
             * @member {string} notes
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.notes = "";

            /**
             * ConnectionOptions kafka.
             * @member {protos.args.IKafkaConn|null|undefined} kafka
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.kafka = null;

            /**
             * ConnectionOptions activeMq.
             * @member {protos.args.IActiveMQConn|null|undefined} activeMq
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.activeMq = null;

            /**
             * ConnectionOptions awssqs.
             * @member {protos.args.IAWSSQSConn|null|undefined} awssqs
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.awssqs = null;

            /**
             * ConnectionOptions awssns.
             * @member {protos.args.IAWSSNSConn|null|undefined} awssns
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.awssns = null;

            /**
             * ConnectionOptions mongo.
             * @member {protos.args.IMongoConn|null|undefined} mongo
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.mongo = null;

            /**
             * ConnectionOptions nats.
             * @member {protos.args.INatsConn|null|undefined} nats
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.nats = null;

            /**
             * ConnectionOptions natsStreaming.
             * @member {protos.args.INatsStreamingConn|null|undefined} natsStreaming
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.natsStreaming = null;

            /**
             * ConnectionOptions nsq.
             * @member {protos.args.INSQConn|null|undefined} nsq
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.nsq = null;

            /**
             * ConnectionOptions postgres.
             * @member {protos.args.IPostgresConn|null|undefined} postgres
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.postgres = null;

            /**
             * ConnectionOptions pulsar.
             * @member {protos.args.IPulsarConn|null|undefined} pulsar
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.pulsar = null;

            /**
             * ConnectionOptions rabbit.
             * @member {protos.args.IRabbitConn|null|undefined} rabbit
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.rabbit = null;

            /**
             * ConnectionOptions rabbitStreams.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} rabbitStreams
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.rabbitStreams = null;

            /**
             * ConnectionOptions redisPubsub.
             * @member {protos.args.IRedisPubSubConn|null|undefined} redisPubsub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.redisPubsub = null;

            /**
             * ConnectionOptions redisStreams.
             * @member {protos.args.IRedisStreamsConn|null|undefined} redisStreams
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.redisStreams = null;

            /**
             * ConnectionOptions azureEventHub.
             * @member {protos.args.IAzureEventHubConn|null|undefined} azureEventHub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.azureEventHub = null;

            /**
             * ConnectionOptions azureServiceBus.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} azureServiceBus
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.azureServiceBus = null;

            /**
             * ConnectionOptions mqtt.
             * @member {protos.args.IMQTTConn|null|undefined} mqtt
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.mqtt = null;

            /**
             * ConnectionOptions kubemqQueue.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} kubemqQueue
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.kubemqQueue = null;

            /**
             * ConnectionOptions gcpPubsub.
             * @member {protos.args.IGCPPubSubConn|null|undefined} gcpPubsub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.gcpPubsub = null;

            /**
             * ConnectionOptions _id.
             * @member {string} _id
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype._id = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ConnectionOptions conn.
             * @member {"kafka"|"activeMq"|"awssqs"|"awssns"|"mongo"|"nats"|"natsStreaming"|"nsq"|"postgres"|"pulsar"|"rabbit"|"rabbitStreams"|"redisPubsub"|"redisStreams"|"azureEventHub"|"azureServiceBus"|"mqtt"|"kubemqQueue"|"gcpPubsub"|undefined} conn
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            Object.defineProperty(ConnectionOptions.prototype, "conn", {
                get: $util.oneOfGetter($oneOfFields = ["kafka", "activeMq", "awssqs", "awssns", "mongo", "nats", "natsStreaming", "nsq", "postgres", "pulsar", "rabbit", "rabbitStreams", "redisPubsub", "redisStreams", "azureEventHub", "azureServiceBus", "mqtt", "kubemqQueue", "gcpPubsub"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ConnectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions=} [properties] Properties to set
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions instance
             */
            ConnectionOptions.create = function create(properties) {
                return new ConnectionOptions(properties);
            };

            /**
             * Encodes the specified ConnectionOptions message. Does not implicitly {@link protos.opts.ConnectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions} message ConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.notes);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.args.KafkaConn.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activeMq != null && Object.hasOwnProperty.call(message, "activeMq"))
                    $root.protos.args.ActiveMQConn.encode(message.activeMq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.args.AWSSQSConn.encode(message.awssqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awssns != null && Object.hasOwnProperty.call(message, "awssns"))
                    $root.protos.args.AWSSNSConn.encode(message.awssns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.args.MongoConn.encode(message.mongo, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.args.NatsConn.encode(message.nats, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.args.NatsStreamingConn.encode(message.natsStreaming, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.args.NSQConn.encode(message.nsq, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.args.PostgresConn.encode(message.postgres, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.args.PulsarConn.encode(message.pulsar, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.args.RabbitConn.encode(message.rabbit, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.args.RabbitStreamsConn.encode(message.rabbitStreams, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.args.RedisPubSubConn.encode(message.redisPubsub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.args.RedisStreamsConn.encode(message.redisStreams, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.args.AzureEventHubConn.encode(message.azureEventHub, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.args.AzureServiceBusConn.encode(message.azureServiceBus, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.args.MQTTConn.encode(message.mqtt, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.args.KubeMQQueueConn.encode(message.kubemqQueue, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.args.GCPPubSubConn.encode(message.gcpPubsub, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._id);
                return writer;
            };

            /**
             * Encodes the specified ConnectionOptions message, length delimited. Does not implicitly {@link protos.opts.ConnectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions} message ConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConnectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ConnectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.notes = reader.string();
                        break;
                    case 100:
                        message.kafka = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activeMq = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awssqs = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awssns = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.mongo = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.nats = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.natsStreaming = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.nsq = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.postgres = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.pulsar = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.rabbit = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.rabbitStreams = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.redisPubsub = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.redisStreams = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.azureEventHub = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.azureServiceBus = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.mqtt = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.kubemqQueue = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.gcpPubsub = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConnectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConnectionOptions message.
             * @function verify
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.KafkaConn.verify(message.kafka);
                        if (error)
                            return "kafka." + error;
                    }
                }
                if (message.activeMq != null && message.hasOwnProperty("activeMq")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.ActiveMQConn.verify(message.activeMq);
                        if (error)
                            return "activeMq." + error;
                    }
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AWSSQSConn.verify(message.awssqs);
                        if (error)
                            return "awssqs." + error;
                    }
                }
                if (message.awssns != null && message.hasOwnProperty("awssns")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AWSSNSConn.verify(message.awssns);
                        if (error)
                            return "awssns." + error;
                    }
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.MongoConn.verify(message.mongo);
                        if (error)
                            return "mongo." + error;
                    }
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NatsConn.verify(message.nats);
                        if (error)
                            return "nats." + error;
                    }
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NatsStreamingConn.verify(message.natsStreaming);
                        if (error)
                            return "natsStreaming." + error;
                    }
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NSQConn.verify(message.nsq);
                        if (error)
                            return "nsq." + error;
                    }
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.PostgresConn.verify(message.postgres);
                        if (error)
                            return "postgres." + error;
                    }
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.PulsarConn.verify(message.pulsar);
                        if (error)
                            return "pulsar." + error;
                    }
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RabbitConn.verify(message.rabbit);
                        if (error)
                            return "rabbit." + error;
                    }
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RabbitStreamsConn.verify(message.rabbitStreams);
                        if (error)
                            return "rabbitStreams." + error;
                    }
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RedisPubSubConn.verify(message.redisPubsub);
                        if (error)
                            return "redisPubsub." + error;
                    }
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RedisStreamsConn.verify(message.redisStreams);
                        if (error)
                            return "redisStreams." + error;
                    }
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AzureEventHubConn.verify(message.azureEventHub);
                        if (error)
                            return "azureEventHub." + error;
                    }
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AzureServiceBusConn.verify(message.azureServiceBus);
                        if (error)
                            return "azureServiceBus." + error;
                    }
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.MQTTConn.verify(message.mqtt);
                        if (error)
                            return "mqtt." + error;
                    }
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.KubeMQQueueConn.verify(message.kubemqQueue);
                        if (error)
                            return "kubemqQueue." + error;
                    }
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.GCPPubSubConn.verify(message.gcpPubsub);
                        if (error)
                            return "gcpPubsub." + error;
                    }
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                return null;
            };

            /**
             * Creates a ConnectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             */
            ConnectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ConnectionOptions)
                    return object;
                var message = new $root.protos.opts.ConnectionOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.kafka: object expected");
                    message.kafka = $root.protos.args.KafkaConn.fromObject(object.kafka);
                }
                if (object.activeMq != null) {
                    if (typeof object.activeMq !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.activeMq: object expected");
                    message.activeMq = $root.protos.args.ActiveMQConn.fromObject(object.activeMq);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.awssqs: object expected");
                    message.awssqs = $root.protos.args.AWSSQSConn.fromObject(object.awssqs);
                }
                if (object.awssns != null) {
                    if (typeof object.awssns !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.awssns: object expected");
                    message.awssns = $root.protos.args.AWSSNSConn.fromObject(object.awssns);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.mongo: object expected");
                    message.mongo = $root.protos.args.MongoConn.fromObject(object.mongo);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.nats: object expected");
                    message.nats = $root.protos.args.NatsConn.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.args.NatsStreamingConn.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.nsq: object expected");
                    message.nsq = $root.protos.args.NSQConn.fromObject(object.nsq);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.postgres: object expected");
                    message.postgres = $root.protos.args.PostgresConn.fromObject(object.postgres);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.pulsar: object expected");
                    message.pulsar = $root.protos.args.PulsarConn.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.rabbit: object expected");
                    message.rabbit = $root.protos.args.RabbitConn.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.args.RabbitStreamsConn.fromObject(object.rabbitStreams);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.args.RedisPubSubConn.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.args.RedisStreamsConn.fromObject(object.redisStreams);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.args.AzureEventHubConn.fromObject(object.azureEventHub);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.args.AzureServiceBusConn.fromObject(object.azureServiceBus);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.mqtt: object expected");
                    message.mqtt = $root.protos.args.MQTTConn.fromObject(object.mqtt);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.args.KubeMQQueueConn.fromObject(object.kubemqQueue);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.args.GCPPubSubConn.fromObject(object.gcpPubsub);
                }
                if (object._id != null)
                    message._id = String(object._id);
                return message;
            };

            /**
             * Creates a plain object from a ConnectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.ConnectionOptions} message ConnectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.notes = "";
                    object._id = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    object.kafka = $root.protos.args.KafkaConn.toObject(message.kafka, options);
                    if (options.oneofs)
                        object.conn = "kafka";
                }
                if (message.activeMq != null && message.hasOwnProperty("activeMq")) {
                    object.activeMq = $root.protos.args.ActiveMQConn.toObject(message.activeMq, options);
                    if (options.oneofs)
                        object.conn = "activeMq";
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    object.awssqs = $root.protos.args.AWSSQSConn.toObject(message.awssqs, options);
                    if (options.oneofs)
                        object.conn = "awssqs";
                }
                if (message.awssns != null && message.hasOwnProperty("awssns")) {
                    object.awssns = $root.protos.args.AWSSNSConn.toObject(message.awssns, options);
                    if (options.oneofs)
                        object.conn = "awssns";
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    object.mongo = $root.protos.args.MongoConn.toObject(message.mongo, options);
                    if (options.oneofs)
                        object.conn = "mongo";
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    object.nats = $root.protos.args.NatsConn.toObject(message.nats, options);
                    if (options.oneofs)
                        object.conn = "nats";
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    object.natsStreaming = $root.protos.args.NatsStreamingConn.toObject(message.natsStreaming, options);
                    if (options.oneofs)
                        object.conn = "natsStreaming";
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    object.nsq = $root.protos.args.NSQConn.toObject(message.nsq, options);
                    if (options.oneofs)
                        object.conn = "nsq";
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    object.postgres = $root.protos.args.PostgresConn.toObject(message.postgres, options);
                    if (options.oneofs)
                        object.conn = "postgres";
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    object.pulsar = $root.protos.args.PulsarConn.toObject(message.pulsar, options);
                    if (options.oneofs)
                        object.conn = "pulsar";
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    object.rabbit = $root.protos.args.RabbitConn.toObject(message.rabbit, options);
                    if (options.oneofs)
                        object.conn = "rabbit";
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    object.rabbitStreams = $root.protos.args.RabbitStreamsConn.toObject(message.rabbitStreams, options);
                    if (options.oneofs)
                        object.conn = "rabbitStreams";
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    object.redisPubsub = $root.protos.args.RedisPubSubConn.toObject(message.redisPubsub, options);
                    if (options.oneofs)
                        object.conn = "redisPubsub";
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    object.redisStreams = $root.protos.args.RedisStreamsConn.toObject(message.redisStreams, options);
                    if (options.oneofs)
                        object.conn = "redisStreams";
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    object.azureEventHub = $root.protos.args.AzureEventHubConn.toObject(message.azureEventHub, options);
                    if (options.oneofs)
                        object.conn = "azureEventHub";
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    object.azureServiceBus = $root.protos.args.AzureServiceBusConn.toObject(message.azureServiceBus, options);
                    if (options.oneofs)
                        object.conn = "azureServiceBus";
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    object.mqtt = $root.protos.args.MQTTConn.toObject(message.mqtt, options);
                    if (options.oneofs)
                        object.conn = "mqtt";
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    object.kubemqQueue = $root.protos.args.KubeMQQueueConn.toObject(message.kubemqQueue, options);
                    if (options.oneofs)
                        object.conn = "kubemqQueue";
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    object.gcpPubsub = $root.protos.args.GCPPubSubConn.toObject(message.gcpPubsub, options);
                    if (options.oneofs)
                        object.conn = "gcpPubsub";
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                return object;
            };

            /**
             * Converts this ConnectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ConnectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ConnectionOptions;
        })();

        /**
         * ConvertOption enum.
         * @name protos.opts.ConvertOption
         * @enum {number}
         * @property {number} CONVERT_OPTION_UNSET=0 CONVERT_OPTION_UNSET value
         * @property {number} CONVERT_OPTION_BASE64=1 CONVERT_OPTION_BASE64 value
         * @property {number} CONVERT_OPTION_GZIP=2 CONVERT_OPTION_GZIP value
         */
        opts.ConvertOption = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CONVERT_OPTION_UNSET"] = 0;
            values[valuesById[1] = "CONVERT_OPTION_BASE64"] = 1;
            values[valuesById[2] = "CONVERT_OPTION_GZIP"] = 2;
            return values;
        })();

        opts.ReadCLIOptions = (function() {

            /**
             * Properties of a ReadCLIOptions.
             * @memberof protos.opts
             * @interface IReadCLIOptions
             * @property {boolean|null} [verboseOutput] ReadCLIOptions verboseOutput
             * @property {boolean|null} [statsEnable] ReadCLIOptions statsEnable
             * @property {number|null} [statsReportIntervalSec] ReadCLIOptions statsReportIntervalSec
             * @property {boolean|null} [pretty] ReadCLIOptions pretty
             */

            /**
             * Constructs a new ReadCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadCLIOptions.
             * @implements IReadCLIOptions
             * @constructor
             * @param {protos.opts.IReadCLIOptions=} [properties] Properties to set
             */
            function ReadCLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadCLIOptions verboseOutput.
             * @member {boolean} verboseOutput
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.verboseOutput = false;

            /**
             * ReadCLIOptions statsEnable.
             * @member {boolean} statsEnable
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.statsEnable = false;

            /**
             * ReadCLIOptions statsReportIntervalSec.
             * @member {number} statsReportIntervalSec
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.statsReportIntervalSec = 0;

            /**
             * ReadCLIOptions pretty.
             * @member {boolean} pretty
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.pretty = false;

            /**
             * Creates a new ReadCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions instance
             */
            ReadCLIOptions.create = function create(properties) {
                return new ReadCLIOptions(properties);
            };

            /**
             * Encodes the specified ReadCLIOptions message. Does not implicitly {@link protos.opts.ReadCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions} message ReadCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.verboseOutput != null && Object.hasOwnProperty.call(message, "verboseOutput"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.verboseOutput);
                if (message.statsEnable != null && Object.hasOwnProperty.call(message, "statsEnable"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.statsEnable);
                if (message.statsReportIntervalSec != null && Object.hasOwnProperty.call(message, "statsReportIntervalSec"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.statsReportIntervalSec);
                if (message.pretty != null && Object.hasOwnProperty.call(message, "pretty"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.pretty);
                return writer;
            };

            /**
             * Encodes the specified ReadCLIOptions message, length delimited. Does not implicitly {@link protos.opts.ReadCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions} message ReadCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.verboseOutput = reader.bool();
                        break;
                    case 2:
                        message.statsEnable = reader.bool();
                        break;
                    case 3:
                        message.statsReportIntervalSec = reader.int32();
                        break;
                    case 4:
                        message.pretty = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadCLIOptions message.
             * @function verify
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.verboseOutput != null && message.hasOwnProperty("verboseOutput"))
                    if (typeof message.verboseOutput !== "boolean")
                        return "verboseOutput: boolean expected";
                if (message.statsEnable != null && message.hasOwnProperty("statsEnable"))
                    if (typeof message.statsEnable !== "boolean")
                        return "statsEnable: boolean expected";
                if (message.statsReportIntervalSec != null && message.hasOwnProperty("statsReportIntervalSec"))
                    if (!$util.isInteger(message.statsReportIntervalSec))
                        return "statsReportIntervalSec: integer expected";
                if (message.pretty != null && message.hasOwnProperty("pretty"))
                    if (typeof message.pretty !== "boolean")
                        return "pretty: boolean expected";
                return null;
            };

            /**
             * Creates a ReadCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             */
            ReadCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadCLIOptions)
                    return object;
                var message = new $root.protos.opts.ReadCLIOptions();
                if (object.verboseOutput != null)
                    message.verboseOutput = Boolean(object.verboseOutput);
                if (object.statsEnable != null)
                    message.statsEnable = Boolean(object.statsEnable);
                if (object.statsReportIntervalSec != null)
                    message.statsReportIntervalSec = object.statsReportIntervalSec | 0;
                if (object.pretty != null)
                    message.pretty = Boolean(object.pretty);
                return message;
            };

            /**
             * Creates a plain object from a ReadCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.ReadCLIOptions} message ReadCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.verboseOutput = false;
                    object.statsEnable = false;
                    object.statsReportIntervalSec = 0;
                    object.pretty = false;
                }
                if (message.verboseOutput != null && message.hasOwnProperty("verboseOutput"))
                    object.verboseOutput = message.verboseOutput;
                if (message.statsEnable != null && message.hasOwnProperty("statsEnable"))
                    object.statsEnable = message.statsEnable;
                if (message.statsReportIntervalSec != null && message.hasOwnProperty("statsReportIntervalSec"))
                    object.statsReportIntervalSec = message.statsReportIntervalSec;
                if (message.pretty != null && message.hasOwnProperty("pretty"))
                    object.pretty = message.pretty;
                return object;
            };

            /**
             * Converts this ReadCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadCLIOptions;
        })();

        opts.ReadSampleOptions = (function() {

            /**
             * Properties of a ReadSampleOptions.
             * @memberof protos.opts
             * @interface IReadSampleOptions
             * @property {number|null} [sampleRate] ReadSampleOptions sampleRate
             * @property {number|null} [sampleIntervalSeconds] ReadSampleOptions sampleIntervalSeconds
             */

            /**
             * Constructs a new ReadSampleOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadSampleOptions.
             * @implements IReadSampleOptions
             * @constructor
             * @param {protos.opts.IReadSampleOptions=} [properties] Properties to set
             */
            function ReadSampleOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadSampleOptions sampleRate.
             * @member {number} sampleRate
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             */
            ReadSampleOptions.prototype.sampleRate = 0;

            /**
             * ReadSampleOptions sampleIntervalSeconds.
             * @member {number} sampleIntervalSeconds
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             */
            ReadSampleOptions.prototype.sampleIntervalSeconds = 0;

            /**
             * Creates a new ReadSampleOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions instance
             */
            ReadSampleOptions.create = function create(properties) {
                return new ReadSampleOptions(properties);
            };

            /**
             * Encodes the specified ReadSampleOptions message. Does not implicitly {@link protos.opts.ReadSampleOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions} message ReadSampleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSampleOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sampleRate != null && Object.hasOwnProperty.call(message, "sampleRate"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sampleRate);
                if (message.sampleIntervalSeconds != null && Object.hasOwnProperty.call(message, "sampleIntervalSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sampleIntervalSeconds);
                return writer;
            };

            /**
             * Encodes the specified ReadSampleOptions message, length delimited. Does not implicitly {@link protos.opts.ReadSampleOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions} message ReadSampleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSampleOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadSampleOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSampleOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadSampleOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sampleRate = reader.uint32();
                        break;
                    case 2:
                        message.sampleIntervalSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadSampleOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSampleOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadSampleOptions message.
             * @function verify
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadSampleOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                    if (!$util.isInteger(message.sampleRate))
                        return "sampleRate: integer expected";
                if (message.sampleIntervalSeconds != null && message.hasOwnProperty("sampleIntervalSeconds"))
                    if (!$util.isInteger(message.sampleIntervalSeconds))
                        return "sampleIntervalSeconds: integer expected";
                return null;
            };

            /**
             * Creates a ReadSampleOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             */
            ReadSampleOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadSampleOptions)
                    return object;
                var message = new $root.protos.opts.ReadSampleOptions();
                if (object.sampleRate != null)
                    message.sampleRate = object.sampleRate >>> 0;
                if (object.sampleIntervalSeconds != null)
                    message.sampleIntervalSeconds = object.sampleIntervalSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ReadSampleOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.ReadSampleOptions} message ReadSampleOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadSampleOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sampleRate = 0;
                    object.sampleIntervalSeconds = 0;
                }
                if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                    object.sampleRate = message.sampleRate;
                if (message.sampleIntervalSeconds != null && message.hasOwnProperty("sampleIntervalSeconds"))
                    object.sampleIntervalSeconds = message.sampleIntervalSeconds;
                return object;
            };

            /**
             * Converts this ReadSampleOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadSampleOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadSampleOptions;
        })();

        opts.ReadFilterOptions = (function() {

            /**
             * Properties of a ReadFilterOptions.
             * @memberof protos.opts
             * @interface IReadFilterOptions
             * @property {string|null} [query] ReadFilterOptions query
             */

            /**
             * Constructs a new ReadFilterOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadFilterOptions.
             * @implements IReadFilterOptions
             * @constructor
             * @param {protos.opts.IReadFilterOptions=} [properties] Properties to set
             */
            function ReadFilterOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadFilterOptions query.
             * @member {string} query
             * @memberof protos.opts.ReadFilterOptions
             * @instance
             */
            ReadFilterOptions.prototype.query = "";

            /**
             * Creates a new ReadFilterOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.IReadFilterOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions instance
             */
            ReadFilterOptions.create = function create(properties) {
                return new ReadFilterOptions(properties);
            };

            /**
             * Encodes the specified ReadFilterOptions message. Does not implicitly {@link protos.opts.ReadFilterOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.IReadFilterOptions} message ReadFilterOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadFilterOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                return writer;
            };

            /**
             * Encodes the specified ReadFilterOptions message, length delimited. Does not implicitly {@link protos.opts.ReadFilterOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.IReadFilterOptions} message ReadFilterOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadFilterOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadFilterOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadFilterOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadFilterOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadFilterOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadFilterOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadFilterOptions message.
             * @function verify
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadFilterOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                return null;
            };

            /**
             * Creates a ReadFilterOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions
             */
            ReadFilterOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadFilterOptions)
                    return object;
                var message = new $root.protos.opts.ReadFilterOptions();
                if (object.query != null)
                    message.query = String(object.query);
                return message;
            };

            /**
             * Creates a plain object from a ReadFilterOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.ReadFilterOptions} message ReadFilterOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadFilterOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.query = "";
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                return object;
            };

            /**
             * Converts this ReadFilterOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadFilterOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadFilterOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadFilterOptions;
        })();

        opts.ReadOptions = (function() {

            /**
             * Properties of a ReadOptions.
             * @memberof protos.opts
             * @interface IReadOptions
             * @property {string|null} [name] ReadOptions name
             * @property {string|null} [connectionId] ReadOptions connectionId
             * @property {boolean|null} [continuous] ReadOptions continuous
             * @property {protos.opts.IReadSampleOptions|null} [sampleOptions] ReadOptions sampleOptions
             * @property {protos.encoding.IDecodeOptions|null} [decodeOptions] ReadOptions decodeOptions
             * @property {protos.opts.ConvertOption|null} [convertOutput] ReadOptions convertOutput
             * @property {protos.opts.IReadFilterOptions|null} [filter] ReadOptions filter
             * @property {protos.opts.IInferSchemaOptions|null} [inferSchemaOptions] ReadOptions inferSchemaOptions
             * @property {string|null} [_id] ReadOptions _id
             * @property {boolean|null} [_active] ReadOptions _active
             * @property {protos.opts.IReadCLIOptions|null} [_cliOptions] ReadOptions _cliOptions
             * @property {protos.opts.IReadGroupKafkaOptions|null} [kafka] ReadOptions kafka
             * @property {protos.opts.IReadGroupActiveMQOptions|null} [activemq] ReadOptions activemq
             * @property {protos.opts.IReadGroupAWSSQSOptions|null} [awssqs] ReadOptions awssqs
             * @property {protos.opts.IReadGroupMongoOptions|null} [mongo] ReadOptions mongo
             * @property {protos.opts.IReadGroupNatsOptions|null} [nats] ReadOptions nats
             * @property {protos.opts.IReadGroupNatsStreamingOptions|null} [natsStreaming] ReadOptions natsStreaming
             * @property {protos.opts.IReadGroupNSQOptions|null} [nsq] ReadOptions nsq
             * @property {protos.opts.IReadGroupPulsarOptions|null} [pulsar] ReadOptions pulsar
             * @property {protos.opts.IReadGroupRabbitOptions|null} [rabbit] ReadOptions rabbit
             * @property {protos.opts.IReadGroupRabbitStreamsOptions|null} [rabbitStreams] ReadOptions rabbitStreams
             * @property {protos.opts.IReadGroupMQTTOptions|null} [mqtt] ReadOptions mqtt
             * @property {protos.opts.IReadGroupAzureServiceBusOptions|null} [azureServiceBus] ReadOptions azureServiceBus
             * @property {protos.opts.IReadGroupAzureEventHubOptions|null} [azureEventHub] ReadOptions azureEventHub
             * @property {protos.opts.IReadGroupGCPPubSubOptions|null} [gcpPubsub] ReadOptions gcpPubsub
             * @property {protos.opts.IReadGroupKubeMQQueueOptions|null} [kubemqQueue] ReadOptions kubemqQueue
             * @property {protos.opts.IReadGroupRedisPubSubOptions|null} [redisPubsub] ReadOptions redisPubsub
             * @property {protos.opts.IReadGroupRedisStreamsOptions|null} [redisStreams] ReadOptions redisStreams
             * @property {protos.opts.IReadGroupPostgresOptions|null} [postgres] ReadOptions postgres
             */

            /**
             * Constructs a new ReadOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadOptions.
             * @implements IReadOptions
             * @constructor
             * @param {protos.opts.IReadOptions=} [properties] Properties to set
             */
            function ReadOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadOptions name.
             * @member {string} name
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.name = "";

            /**
             * ReadOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.connectionId = "";

            /**
             * ReadOptions continuous.
             * @member {boolean} continuous
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.continuous = false;

            /**
             * ReadOptions sampleOptions.
             * @member {protos.opts.IReadSampleOptions|null|undefined} sampleOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.sampleOptions = null;

            /**
             * ReadOptions decodeOptions.
             * @member {protos.encoding.IDecodeOptions|null|undefined} decodeOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.decodeOptions = null;

            /**
             * ReadOptions convertOutput.
             * @member {protos.opts.ConvertOption} convertOutput
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.convertOutput = 0;

            /**
             * ReadOptions filter.
             * @member {protos.opts.IReadFilterOptions|null|undefined} filter
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.filter = null;

            /**
             * ReadOptions inferSchemaOptions.
             * @member {protos.opts.IInferSchemaOptions|null|undefined} inferSchemaOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.inferSchemaOptions = null;

            /**
             * ReadOptions _id.
             * @member {string} _id
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._id = "";

            /**
             * ReadOptions _active.
             * @member {boolean} _active
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._active = false;

            /**
             * ReadOptions _cliOptions.
             * @member {protos.opts.IReadCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._cliOptions = null;

            /**
             * ReadOptions kafka.
             * @member {protos.opts.IReadGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.kafka = null;

            /**
             * ReadOptions activemq.
             * @member {protos.opts.IReadGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.activemq = null;

            /**
             * ReadOptions awssqs.
             * @member {protos.opts.IReadGroupAWSSQSOptions|null|undefined} awssqs
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.awssqs = null;

            /**
             * ReadOptions mongo.
             * @member {protos.opts.IReadGroupMongoOptions|null|undefined} mongo
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.mongo = null;

            /**
             * ReadOptions nats.
             * @member {protos.opts.IReadGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.nats = null;

            /**
             * ReadOptions natsStreaming.
             * @member {protos.opts.IReadGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.natsStreaming = null;

            /**
             * ReadOptions nsq.
             * @member {protos.opts.IReadGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.nsq = null;

            /**
             * ReadOptions pulsar.
             * @member {protos.opts.IReadGroupPulsarOptions|null|undefined} pulsar
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.pulsar = null;

            /**
             * ReadOptions rabbit.
             * @member {protos.opts.IReadGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.rabbit = null;

            /**
             * ReadOptions rabbitStreams.
             * @member {protos.opts.IReadGroupRabbitStreamsOptions|null|undefined} rabbitStreams
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.rabbitStreams = null;

            /**
             * ReadOptions mqtt.
             * @member {protos.opts.IReadGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.mqtt = null;

            /**
             * ReadOptions azureServiceBus.
             * @member {protos.opts.IReadGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.azureServiceBus = null;

            /**
             * ReadOptions azureEventHub.
             * @member {protos.opts.IReadGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.azureEventHub = null;

            /**
             * ReadOptions gcpPubsub.
             * @member {protos.opts.IReadGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.gcpPubsub = null;

            /**
             * ReadOptions kubemqQueue.
             * @member {protos.opts.IReadGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.kubemqQueue = null;

            /**
             * ReadOptions redisPubsub.
             * @member {protos.opts.IReadGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.redisPubsub = null;

            /**
             * ReadOptions redisStreams.
             * @member {protos.opts.IReadGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.redisStreams = null;

            /**
             * ReadOptions postgres.
             * @member {protos.opts.IReadGroupPostgresOptions|null|undefined} postgres
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.postgres = null;

            /**
             * Creates a new ReadOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadOptions} ReadOptions instance
             */
            ReadOptions.create = function create(properties) {
                return new ReadOptions(properties);
            };

            /**
             * Encodes the specified ReadOptions message. Does not implicitly {@link protos.opts.ReadOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions} message ReadOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.connectionId);
                if (message.continuous != null && Object.hasOwnProperty.call(message, "continuous"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.continuous);
                if (message.sampleOptions != null && Object.hasOwnProperty.call(message, "sampleOptions"))
                    $root.protos.opts.ReadSampleOptions.encode(message.sampleOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.decodeOptions != null && Object.hasOwnProperty.call(message, "decodeOptions"))
                    $root.protos.encoding.DecodeOptions.encode(message.decodeOptions, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.convertOutput != null && Object.hasOwnProperty.call(message, "convertOutput"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.convertOutput);
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    $root.protos.opts.ReadFilterOptions.encode(message.filter, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.inferSchemaOptions != null && Object.hasOwnProperty.call(message, "inferSchemaOptions"))
                    $root.protos.opts.InferSchemaOptions.encode(message.inferSchemaOptions, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.ReadGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.ReadGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.opts.ReadGroupAWSSQSOptions.encode(message.awssqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.opts.ReadGroupMongoOptions.encode(message.mongo, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.ReadGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.ReadGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.ReadGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.opts.ReadGroupPulsarOptions.encode(message.pulsar, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.ReadGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.opts.ReadGroupRabbitStreamsOptions.encode(message.rabbitStreams, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.ReadGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.ReadGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.ReadGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.ReadGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.ReadGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.ReadGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.ReadGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.opts.ReadGroupPostgresOptions.encode(message.postgres, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._id);
                if (message._active != null && Object.hasOwnProperty.call(message, "_active"))
                    writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message._active);
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.ReadCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1002, wireType 2 =*/8018).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadOptions message, length delimited. Does not implicitly {@link protos.opts.ReadOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions} message ReadOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadOptions} ReadOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.connectionId = reader.string();
                        break;
                    case 3:
                        message.continuous = reader.bool();
                        break;
                    case 4:
                        message.sampleOptions = $root.protos.opts.ReadSampleOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.decodeOptions = $root.protos.encoding.DecodeOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.convertOutput = reader.int32();
                        break;
                    case 7:
                        message.filter = $root.protos.opts.ReadFilterOptions.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.inferSchemaOptions = $root.protos.opts.InferSchemaOptions.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._id = reader.string();
                        break;
                    case 1001:
                        message._active = reader.bool();
                        break;
                    case 1002:
                        message._cliOptions = $root.protos.opts.ReadCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.ReadGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.ReadGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awssqs = $root.protos.opts.ReadGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.mongo = $root.protos.opts.ReadGroupMongoOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.ReadGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.ReadGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.pulsar = $root.protos.opts.ReadGroupPulsarOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.rabbit = $root.protos.opts.ReadGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.mqtt = $root.protos.opts.ReadGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.postgres = $root.protos.opts.ReadGroupPostgresOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadOptions} ReadOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadOptions message.
             * @function verify
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.continuous != null && message.hasOwnProperty("continuous"))
                    if (typeof message.continuous !== "boolean")
                        return "continuous: boolean expected";
                if (message.sampleOptions != null && message.hasOwnProperty("sampleOptions")) {
                    var error = $root.protos.opts.ReadSampleOptions.verify(message.sampleOptions);
                    if (error)
                        return "sampleOptions." + error;
                }
                if (message.decodeOptions != null && message.hasOwnProperty("decodeOptions")) {
                    var error = $root.protos.encoding.DecodeOptions.verify(message.decodeOptions);
                    if (error)
                        return "decodeOptions." + error;
                }
                if (message.convertOutput != null && message.hasOwnProperty("convertOutput"))
                    switch (message.convertOutput) {
                    default:
                        return "convertOutput: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.filter != null && message.hasOwnProperty("filter")) {
                    var error = $root.protos.opts.ReadFilterOptions.verify(message.filter);
                    if (error)
                        return "filter." + error;
                }
                if (message.inferSchemaOptions != null && message.hasOwnProperty("inferSchemaOptions")) {
                    var error = $root.protos.opts.InferSchemaOptions.verify(message.inferSchemaOptions);
                    if (error)
                        return "inferSchemaOptions." + error;
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                if (message._active != null && message.hasOwnProperty("_active"))
                    if (typeof message._active !== "boolean")
                        return "_active: boolean expected";
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    var error = $root.protos.opts.ReadCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.ReadGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    var error = $root.protos.opts.ReadGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    var error = $root.protos.opts.ReadGroupAWSSQSOptions.verify(message.awssqs);
                    if (error)
                        return "awssqs." + error;
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    var error = $root.protos.opts.ReadGroupMongoOptions.verify(message.mongo);
                    if (error)
                        return "mongo." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.ReadGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.ReadGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.ReadGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    var error = $root.protos.opts.ReadGroupPulsarOptions.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.ReadGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    var error = $root.protos.opts.ReadGroupRabbitStreamsOptions.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.ReadGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.ReadGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.opts.ReadGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.ReadGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.ReadGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.ReadGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.ReadGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    var error = $root.protos.opts.ReadGroupPostgresOptions.verify(message.postgres);
                    if (error)
                        return "postgres." + error;
                }
                return null;
            };

            /**
             * Creates a ReadOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadOptions} ReadOptions
             */
            ReadOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadOptions)
                    return object;
                var message = new $root.protos.opts.ReadOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.continuous != null)
                    message.continuous = Boolean(object.continuous);
                if (object.sampleOptions != null) {
                    if (typeof object.sampleOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.sampleOptions: object expected");
                    message.sampleOptions = $root.protos.opts.ReadSampleOptions.fromObject(object.sampleOptions);
                }
                if (object.decodeOptions != null) {
                    if (typeof object.decodeOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.decodeOptions: object expected");
                    message.decodeOptions = $root.protos.encoding.DecodeOptions.fromObject(object.decodeOptions);
                }
                switch (object.convertOutput) {
                case "CONVERT_OPTION_UNSET":
                case 0:
                    message.convertOutput = 0;
                    break;
                case "CONVERT_OPTION_BASE64":
                case 1:
                    message.convertOutput = 1;
                    break;
                case "CONVERT_OPTION_GZIP":
                case 2:
                    message.convertOutput = 2;
                    break;
                }
                if (object.filter != null) {
                    if (typeof object.filter !== "object")
                        throw TypeError(".protos.opts.ReadOptions.filter: object expected");
                    message.filter = $root.protos.opts.ReadFilterOptions.fromObject(object.filter);
                }
                if (object.inferSchemaOptions != null) {
                    if (typeof object.inferSchemaOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.inferSchemaOptions: object expected");
                    message.inferSchemaOptions = $root.protos.opts.InferSchemaOptions.fromObject(object.inferSchemaOptions);
                }
                if (object._id != null)
                    message._id = String(object._id);
                if (object._active != null)
                    message._active = Boolean(object._active);
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.ReadCLIOptions.fromObject(object._cliOptions);
                }
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.ReadOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.ReadGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.ReadOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.ReadGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.ReadOptions.awssqs: object expected");
                    message.awssqs = $root.protos.opts.ReadGroupAWSSQSOptions.fromObject(object.awssqs);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.ReadOptions.mongo: object expected");
                    message.mongo = $root.protos.opts.ReadGroupMongoOptions.fromObject(object.mongo);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.ReadOptions.nats: object expected");
                    message.nats = $root.protos.opts.ReadGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.ReadOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.ReadOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.ReadGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.ReadOptions.pulsar: object expected");
                    message.pulsar = $root.protos.opts.ReadGroupPulsarOptions.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.ReadOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.ReadGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.ReadOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.fromObject(object.rabbitStreams);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.ReadOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.ReadGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.ReadOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.ReadOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.ReadOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.ReadOptions.postgres: object expected");
                    message.postgres = $root.protos.opts.ReadGroupPostgresOptions.fromObject(object.postgres);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.ReadOptions} message ReadOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.connectionId = "";
                    object.continuous = false;
                    object.sampleOptions = null;
                    object.decodeOptions = null;
                    object.convertOutput = options.enums === String ? "CONVERT_OPTION_UNSET" : 0;
                    object.filter = null;
                    object.inferSchemaOptions = null;
                    object.kafka = null;
                    object.activemq = null;
                    object.awssqs = null;
                    object.mongo = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.pulsar = null;
                    object.rabbit = null;
                    object.rabbitStreams = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.postgres = null;
                    object._id = "";
                    object._active = false;
                    object._cliOptions = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.continuous != null && message.hasOwnProperty("continuous"))
                    object.continuous = message.continuous;
                if (message.sampleOptions != null && message.hasOwnProperty("sampleOptions"))
                    object.sampleOptions = $root.protos.opts.ReadSampleOptions.toObject(message.sampleOptions, options);
                if (message.decodeOptions != null && message.hasOwnProperty("decodeOptions"))
                    object.decodeOptions = $root.protos.encoding.DecodeOptions.toObject(message.decodeOptions, options);
                if (message.convertOutput != null && message.hasOwnProperty("convertOutput"))
                    object.convertOutput = options.enums === String ? $root.protos.opts.ConvertOption[message.convertOutput] : message.convertOutput;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = $root.protos.opts.ReadFilterOptions.toObject(message.filter, options);
                if (message.inferSchemaOptions != null && message.hasOwnProperty("inferSchemaOptions"))
                    object.inferSchemaOptions = $root.protos.opts.InferSchemaOptions.toObject(message.inferSchemaOptions, options);
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.ReadGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.ReadGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awssqs != null && message.hasOwnProperty("awssqs"))
                    object.awssqs = $root.protos.opts.ReadGroupAWSSQSOptions.toObject(message.awssqs, options);
                if (message.mongo != null && message.hasOwnProperty("mongo"))
                    object.mongo = $root.protos.opts.ReadGroupMongoOptions.toObject(message.mongo, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.ReadGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.ReadGroupNSQOptions.toObject(message.nsq, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.opts.ReadGroupPulsarOptions.toObject(message.pulsar, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.ReadGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.toObject(message.rabbitStreams, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.ReadGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.postgres != null && message.hasOwnProperty("postgres"))
                    object.postgres = $root.protos.opts.ReadGroupPostgresOptions.toObject(message.postgres, options);
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                if (message._active != null && message.hasOwnProperty("_active"))
                    object._active = message._active;
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.ReadCLIOptions.toObject(message._cliOptions, options);
                return object;
            };

            /**
             * Converts this ReadOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadOptions;
        })();

        opts.ReadGroupKafkaOptions = (function() {

            /**
             * Properties of a ReadGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IReadGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] ReadGroupKafkaOptions _conn
             * @property {protos.args.IKafkaReadArgs|null} [args] ReadGroupKafkaOptions args
             */

            /**
             * Constructs a new ReadGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupKafkaOptions.
             * @implements IReadGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IReadGroupKafkaOptions=} [properties] Properties to set
             */
            function ReadGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             */
            ReadGroupKafkaOptions.prototype._conn = null;

            /**
             * ReadGroupKafkaOptions args.
             * @member {protos.args.IKafkaReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             */
            ReadGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions instance
             */
            ReadGroupKafkaOptions.create = function create(properties) {
                return new ReadGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupKafkaOptions message. Does not implicitly {@link protos.opts.ReadGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions} message ReadGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions} message ReadGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             */
            ReadGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.ReadGroupKafkaOptions} message ReadGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupKafkaOptions;
        })();

        opts.ReadGroupActiveMQOptions = (function() {

            /**
             * Properties of a ReadGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IReadGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] ReadGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQReadArgs|null} [args] ReadGroupActiveMQOptions args
             */

            /**
             * Constructs a new ReadGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupActiveMQOptions.
             * @implements IReadGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IReadGroupActiveMQOptions=} [properties] Properties to set
             */
            function ReadGroupActiveMQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             */
            ReadGroupActiveMQOptions.prototype._conn = null;

            /**
             * ReadGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             */
            ReadGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions instance
             */
            ReadGroupActiveMQOptions.create = function create(properties) {
                return new ReadGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupActiveMQOptions message. Does not implicitly {@link protos.opts.ReadGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions} message ReadGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions} message ReadGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupActiveMQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.ActiveMQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             */
            ReadGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupActiveMQOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.ReadGroupActiveMQOptions} message ReadGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupActiveMQOptions;
        })();

        opts.ReadGroupAWSSQSOptions = (function() {

            /**
             * Properties of a ReadGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IReadGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] ReadGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSReadArgs|null} [args] ReadGroupAWSSQSOptions args
             */

            /**
             * Constructs a new ReadGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAWSSQSOptions.
             * @implements IReadGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IReadGroupAWSSQSOptions=} [properties] Properties to set
             */
            function ReadGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             */
            ReadGroupAWSSQSOptions.prototype._conn = null;

            /**
             * ReadGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             */
            ReadGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions instance
             */
            ReadGroupAWSSQSOptions.create = function create(properties) {
                return new ReadGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.ReadGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             */
            ReadGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.ReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAWSSQSOptions;
        })();

        opts.ReadGroupMongoOptions = (function() {

            /**
             * Properties of a ReadGroupMongoOptions.
             * @memberof protos.opts
             * @interface IReadGroupMongoOptions
             * @property {protos.args.IMongoConn|null} [_conn] ReadGroupMongoOptions _conn
             * @property {protos.args.IMongoReadArgs|null} [args] ReadGroupMongoOptions args
             */

            /**
             * Constructs a new ReadGroupMongoOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupMongoOptions.
             * @implements IReadGroupMongoOptions
             * @constructor
             * @param {protos.opts.IReadGroupMongoOptions=} [properties] Properties to set
             */
            function ReadGroupMongoOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupMongoOptions _conn.
             * @member {protos.args.IMongoConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             */
            ReadGroupMongoOptions.prototype._conn = null;

            /**
             * ReadGroupMongoOptions args.
             * @member {protos.args.IMongoReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             */
            ReadGroupMongoOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupMongoOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions instance
             */
            ReadGroupMongoOptions.create = function create(properties) {
                return new ReadGroupMongoOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupMongoOptions message. Does not implicitly {@link protos.opts.ReadGroupMongoOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions} message ReadGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMongoOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MongoConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MongoReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupMongoOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupMongoOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions} message ReadGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMongoOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupMongoOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMongoOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupMongoOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MongoReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupMongoOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMongoOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupMongoOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupMongoOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MongoConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MongoReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupMongoOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             */
            ReadGroupMongoOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupMongoOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupMongoOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupMongoOptions._conn: object expected");
                    message._conn = $root.protos.args.MongoConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupMongoOptions.args: object expected");
                    message.args = $root.protos.args.MongoReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupMongoOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.ReadGroupMongoOptions} message ReadGroupMongoOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupMongoOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MongoConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MongoReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupMongoOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupMongoOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupMongoOptions;
        })();

        opts.ReadGroupNatsOptions = (function() {

            /**
             * Properties of a ReadGroupNatsOptions.
             * @memberof protos.opts
             * @interface IReadGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] ReadGroupNatsOptions _conn
             * @property {protos.args.INatsReadArgs|null} [args] ReadGroupNatsOptions args
             */

            /**
             * Constructs a new ReadGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNatsOptions.
             * @implements IReadGroupNatsOptions
             * @constructor
             * @param {protos.opts.IReadGroupNatsOptions=} [properties] Properties to set
             */
            function ReadGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             */
            ReadGroupNatsOptions.prototype._conn = null;

            /**
             * ReadGroupNatsOptions args.
             * @member {protos.args.INatsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             */
            ReadGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions instance
             */
            ReadGroupNatsOptions.create = function create(properties) {
                return new ReadGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNatsOptions message. Does not implicitly {@link protos.opts.ReadGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions} message ReadGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions} message ReadGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             */
            ReadGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.ReadGroupNatsOptions} message ReadGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNatsOptions;
        })();

        opts.ReadGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a ReadGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IReadGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] ReadGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingReadArgs|null} [args] ReadGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new ReadGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNatsStreamingOptions.
             * @implements IReadGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IReadGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function ReadGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             */
            ReadGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * ReadGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             */
            ReadGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions instance
             */
            ReadGroupNatsStreamingOptions.create = function create(properties) {
                return new ReadGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.ReadGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             */
            ReadGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.ReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNatsStreamingOptions;
        })();

        opts.ReadGroupNSQOptions = (function() {

            /**
             * Properties of a ReadGroupNSQOptions.
             * @memberof protos.opts
             * @interface IReadGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] ReadGroupNSQOptions _conn
             * @property {protos.args.INSQReadArgs|null} [args] ReadGroupNSQOptions args
             */

            /**
             * Constructs a new ReadGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNSQOptions.
             * @implements IReadGroupNSQOptions
             * @constructor
             * @param {protos.opts.IReadGroupNSQOptions=} [properties] Properties to set
             */
            function ReadGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             */
            ReadGroupNSQOptions.prototype._conn = null;

            /**
             * ReadGroupNSQOptions args.
             * @member {protos.args.INSQReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             */
            ReadGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions instance
             */
            ReadGroupNSQOptions.create = function create(properties) {
                return new ReadGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNSQOptions message. Does not implicitly {@link protos.opts.ReadGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions} message ReadGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions} message ReadGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             */
            ReadGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.ReadGroupNSQOptions} message ReadGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNSQOptions;
        })();

        opts.ReadGroupPostgresOptions = (function() {

            /**
             * Properties of a ReadGroupPostgresOptions.
             * @memberof protos.opts
             * @interface IReadGroupPostgresOptions
             * @property {protos.args.IPostgresConn|null} [_conn] ReadGroupPostgresOptions _conn
             * @property {protos.args.IPostgresReadArgs|null} [args] ReadGroupPostgresOptions args
             */

            /**
             * Constructs a new ReadGroupPostgresOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupPostgresOptions.
             * @implements IReadGroupPostgresOptions
             * @constructor
             * @param {protos.opts.IReadGroupPostgresOptions=} [properties] Properties to set
             */
            function ReadGroupPostgresOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupPostgresOptions _conn.
             * @member {protos.args.IPostgresConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             */
            ReadGroupPostgresOptions.prototype._conn = null;

            /**
             * ReadGroupPostgresOptions args.
             * @member {protos.args.IPostgresReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             */
            ReadGroupPostgresOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupPostgresOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions instance
             */
            ReadGroupPostgresOptions.create = function create(properties) {
                return new ReadGroupPostgresOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupPostgresOptions message. Does not implicitly {@link protos.opts.ReadGroupPostgresOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions} message ReadGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPostgresOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PostgresConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PostgresReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupPostgresOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupPostgresOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions} message ReadGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPostgresOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupPostgresOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPostgresOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupPostgresOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PostgresReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupPostgresOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPostgresOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupPostgresOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupPostgresOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PostgresConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PostgresReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupPostgresOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             */
            ReadGroupPostgresOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupPostgresOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupPostgresOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupPostgresOptions._conn: object expected");
                    message._conn = $root.protos.args.PostgresConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupPostgresOptions.args: object expected");
                    message.args = $root.protos.args.PostgresReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupPostgresOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.ReadGroupPostgresOptions} message ReadGroupPostgresOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupPostgresOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PostgresConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PostgresReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupPostgresOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupPostgresOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupPostgresOptions;
        })();

        opts.ReadGroupPulsarOptions = (function() {

            /**
             * Properties of a ReadGroupPulsarOptions.
             * @memberof protos.opts
             * @interface IReadGroupPulsarOptions
             * @property {protos.args.IPulsarConn|null} [_conn] ReadGroupPulsarOptions _conn
             * @property {protos.args.IPulsarReadArgs|null} [args] ReadGroupPulsarOptions args
             */

            /**
             * Constructs a new ReadGroupPulsarOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupPulsarOptions.
             * @implements IReadGroupPulsarOptions
             * @constructor
             * @param {protos.opts.IReadGroupPulsarOptions=} [properties] Properties to set
             */
            function ReadGroupPulsarOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupPulsarOptions _conn.
             * @member {protos.args.IPulsarConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             */
            ReadGroupPulsarOptions.prototype._conn = null;

            /**
             * ReadGroupPulsarOptions args.
             * @member {protos.args.IPulsarReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             */
            ReadGroupPulsarOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupPulsarOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions instance
             */
            ReadGroupPulsarOptions.create = function create(properties) {
                return new ReadGroupPulsarOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupPulsarOptions message. Does not implicitly {@link protos.opts.ReadGroupPulsarOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions} message ReadGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPulsarOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PulsarConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PulsarReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupPulsarOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupPulsarOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions} message ReadGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPulsarOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupPulsarOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPulsarOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupPulsarOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PulsarReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupPulsarOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPulsarOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupPulsarOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupPulsarOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PulsarConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PulsarReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupPulsarOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             */
            ReadGroupPulsarOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupPulsarOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupPulsarOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupPulsarOptions._conn: object expected");
                    message._conn = $root.protos.args.PulsarConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupPulsarOptions.args: object expected");
                    message.args = $root.protos.args.PulsarReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupPulsarOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.ReadGroupPulsarOptions} message ReadGroupPulsarOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupPulsarOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PulsarConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PulsarReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupPulsarOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupPulsarOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupPulsarOptions;
        })();

        opts.ReadGroupRabbitOptions = (function() {

            /**
             * Properties of a ReadGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IReadGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] ReadGroupRabbitOptions _conn
             * @property {protos.args.IRabbitReadArgs|null} [args] ReadGroupRabbitOptions args
             */

            /**
             * Constructs a new ReadGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRabbitOptions.
             * @implements IReadGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IReadGroupRabbitOptions=} [properties] Properties to set
             */
            function ReadGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             */
            ReadGroupRabbitOptions.prototype._conn = null;

            /**
             * ReadGroupRabbitOptions args.
             * @member {protos.args.IRabbitReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             */
            ReadGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions instance
             */
            ReadGroupRabbitOptions.create = function create(properties) {
                return new ReadGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRabbitOptions message. Does not implicitly {@link protos.opts.ReadGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions} message ReadGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions} message ReadGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             */
            ReadGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.ReadGroupRabbitOptions} message ReadGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRabbitOptions;
        })();

        opts.ReadGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a ReadGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IReadGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] ReadGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsReadArgs|null} [args] ReadGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new ReadGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRabbitStreamsOptions.
             * @implements IReadGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IReadGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function ReadGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             */
            ReadGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * ReadGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             */
            ReadGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions instance
             */
            ReadGroupRabbitStreamsOptions.create = function create(properties) {
                return new ReadGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.ReadGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             */
            ReadGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRabbitStreamsOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.ReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRabbitStreamsOptions;
        })();

        opts.ReadGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a ReadGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IReadGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] ReadGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubReadArgs|null} [args] ReadGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new ReadGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRedisPubSubOptions.
             * @implements IReadGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IReadGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function ReadGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             */
            ReadGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * ReadGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             */
            ReadGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions instance
             */
            ReadGroupRedisPubSubOptions.create = function create(properties) {
                return new ReadGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.ReadGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             */
            ReadGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.ReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRedisPubSubOptions;
        })();

        opts.ReadGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a ReadGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IReadGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] ReadGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsReadArgs|null} [args] ReadGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new ReadGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRedisStreamsOptions.
             * @implements IReadGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IReadGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function ReadGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             */
            ReadGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * ReadGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             */
            ReadGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions instance
             */
            ReadGroupRedisStreamsOptions.create = function create(properties) {
                return new ReadGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.ReadGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             */
            ReadGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.ReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRedisStreamsOptions;
        })();

        opts.ReadGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a ReadGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IReadGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] ReadGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubReadArgs|null} [args] ReadGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new ReadGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAzureEventHubOptions.
             * @implements IReadGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IReadGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function ReadGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             */
            ReadGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * ReadGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             */
            ReadGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions instance
             */
            ReadGroupAzureEventHubOptions.create = function create(properties) {
                return new ReadGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.ReadGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureEventHubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             */
            ReadGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAzureEventHubOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.ReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAzureEventHubOptions;
        })();

        opts.ReadGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a ReadGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IReadGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] ReadGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusReadArgs|null} [args] ReadGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new ReadGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAzureServiceBusOptions.
             * @implements IReadGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IReadGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function ReadGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             */
            ReadGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * ReadGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             */
            ReadGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions instance
             */
            ReadGroupAzureServiceBusOptions.create = function create(properties) {
                return new ReadGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.ReadGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             */
            ReadGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.ReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAzureServiceBusOptions;
        })();

        opts.ReadGroupMQTTOptions = (function() {

            /**
             * Properties of a ReadGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IReadGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] ReadGroupMQTTOptions _conn
             * @property {protos.args.IMQTTReadArgs|null} [args] ReadGroupMQTTOptions args
             */

            /**
             * Constructs a new ReadGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupMQTTOptions.
             * @implements IReadGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IReadGroupMQTTOptions=} [properties] Properties to set
             */
            function ReadGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             */
            ReadGroupMQTTOptions.prototype._conn = null;

            /**
             * ReadGroupMQTTOptions args.
             * @member {protos.args.IMQTTReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             */
            ReadGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions instance
             */
            ReadGroupMQTTOptions.create = function create(properties) {
                return new ReadGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupMQTTOptions message. Does not implicitly {@link protos.opts.ReadGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions} message ReadGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions} message ReadGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             */
            ReadGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.ReadGroupMQTTOptions} message ReadGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupMQTTOptions;
        })();

        opts.ReadGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a ReadGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IReadGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] ReadGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubReadArgs|null} [args] ReadGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new ReadGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupGCPPubSubOptions.
             * @implements IReadGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IReadGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function ReadGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             */
            ReadGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * ReadGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             */
            ReadGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions instance
             */
            ReadGroupGCPPubSubOptions.create = function create(properties) {
                return new ReadGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.ReadGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             */
            ReadGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.ReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupGCPPubSubOptions;
        })();

        opts.ReadGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a ReadGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IReadGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] ReadGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueReadArgs|null} [args] ReadGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new ReadGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupKubeMQQueueOptions.
             * @implements IReadGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IReadGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function ReadGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             */
            ReadGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * ReadGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             */
            ReadGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions instance
             */
            ReadGroupKubeMQQueueOptions.create = function create(properties) {
                return new ReadGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.ReadGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             */
            ReadGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.ReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupKubeMQQueueOptions;
        })();

        opts.InferSchemaOptions = (function() {

            /**
             * Properties of an InferSchemaOptions.
             * @memberof protos.opts
             * @interface IInferSchemaOptions
             * @property {protos.opts.InferSchemaOptions.Type|null} [type] InferSchemaOptions type
             * @property {string|null} [schemaId] InferSchemaOptions schemaId
             */

            /**
             * Constructs a new InferSchemaOptions.
             * @memberof protos.opts
             * @classdesc Represents an InferSchemaOptions.
             * @implements IInferSchemaOptions
             * @constructor
             * @param {protos.opts.IInferSchemaOptions=} [properties] Properties to set
             */
            function InferSchemaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InferSchemaOptions type.
             * @member {protos.opts.InferSchemaOptions.Type} type
             * @memberof protos.opts.InferSchemaOptions
             * @instance
             */
            InferSchemaOptions.prototype.type = 0;

            /**
             * InferSchemaOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.opts.InferSchemaOptions
             * @instance
             */
            InferSchemaOptions.prototype.schemaId = "";

            /**
             * Creates a new InferSchemaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.IInferSchemaOptions=} [properties] Properties to set
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions instance
             */
            InferSchemaOptions.create = function create(properties) {
                return new InferSchemaOptions(properties);
            };

            /**
             * Encodes the specified InferSchemaOptions message. Does not implicitly {@link protos.opts.InferSchemaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.IInferSchemaOptions} message InferSchemaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InferSchemaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
                return writer;
            };

            /**
             * Encodes the specified InferSchemaOptions message, length delimited. Does not implicitly {@link protos.opts.InferSchemaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.IInferSchemaOptions} message InferSchemaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InferSchemaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InferSchemaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InferSchemaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.InferSchemaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.schemaId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InferSchemaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InferSchemaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InferSchemaOptions message.
             * @function verify
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InferSchemaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                return null;
            };

            /**
             * Creates an InferSchemaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions
             */
            InferSchemaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.InferSchemaOptions)
                    return object;
                var message = new $root.protos.opts.InferSchemaOptions();
                switch (object.type) {
                case "UNSET":
                case 0:
                    message.type = 0;
                    break;
                case "JSONSchema":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                return message;
            };

            /**
             * Creates a plain object from an InferSchemaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.InferSchemaOptions} message InferSchemaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InferSchemaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSET" : 0;
                    object.schemaId = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.opts.InferSchemaOptions.Type[message.type] : message.type;
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                return object;
            };

            /**
             * Converts this InferSchemaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.InferSchemaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InferSchemaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name protos.opts.InferSchemaOptions.Type
             * @enum {number}
             * @property {number} UNSET=0 UNSET value
             * @property {number} JSONSchema=1 JSONSchema value
             */
            InferSchemaOptions.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSET"] = 0;
                values[valuesById[1] = "JSONSchema"] = 1;
                return values;
            })();

            return InferSchemaOptions;
        })();

        opts.WriteCLIOptions = (function() {

            /**
             * Properties of a WriteCLIOptions.
             * @memberof protos.opts
             * @interface IWriteCLIOptions
             * @property {string|null} [inputFile] WriteCLIOptions inputFile
             * @property {boolean|null} [inputAsJsonArray] WriteCLIOptions inputAsJsonArray
             * @property {Array.<string>|null} [inputStdin] WriteCLIOptions inputStdin
             */

            /**
             * Constructs a new WriteCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteCLIOptions.
             * @implements IWriteCLIOptions
             * @constructor
             * @param {protos.opts.IWriteCLIOptions=} [properties] Properties to set
             */
            function WriteCLIOptions(properties) {
                this.inputStdin = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteCLIOptions inputFile.
             * @member {string} inputFile
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputFile = "";

            /**
             * WriteCLIOptions inputAsJsonArray.
             * @member {boolean} inputAsJsonArray
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputAsJsonArray = false;

            /**
             * WriteCLIOptions inputStdin.
             * @member {Array.<string>} inputStdin
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputStdin = $util.emptyArray;

            /**
             * Creates a new WriteCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions instance
             */
            WriteCLIOptions.create = function create(properties) {
                return new WriteCLIOptions(properties);
            };

            /**
             * Encodes the specified WriteCLIOptions message. Does not implicitly {@link protos.opts.WriteCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions} message WriteCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inputFile != null && Object.hasOwnProperty.call(message, "inputFile"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inputFile);
                if (message.inputAsJsonArray != null && Object.hasOwnProperty.call(message, "inputAsJsonArray"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.inputAsJsonArray);
                if (message.inputStdin != null && message.inputStdin.length)
                    for (var i = 0; i < message.inputStdin.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.inputStdin[i]);
                return writer;
            };

            /**
             * Encodes the specified WriteCLIOptions message, length delimited. Does not implicitly {@link protos.opts.WriteCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions} message WriteCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.inputFile = reader.string();
                        break;
                    case 2:
                        message.inputAsJsonArray = reader.bool();
                        break;
                    case 3:
                        if (!(message.inputStdin && message.inputStdin.length))
                            message.inputStdin = [];
                        message.inputStdin.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteCLIOptions message.
             * @function verify
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inputFile != null && message.hasOwnProperty("inputFile"))
                    if (!$util.isString(message.inputFile))
                        return "inputFile: string expected";
                if (message.inputAsJsonArray != null && message.hasOwnProperty("inputAsJsonArray"))
                    if (typeof message.inputAsJsonArray !== "boolean")
                        return "inputAsJsonArray: boolean expected";
                if (message.inputStdin != null && message.hasOwnProperty("inputStdin")) {
                    if (!Array.isArray(message.inputStdin))
                        return "inputStdin: array expected";
                    for (var i = 0; i < message.inputStdin.length; ++i)
                        if (!$util.isString(message.inputStdin[i]))
                            return "inputStdin: string[] expected";
                }
                return null;
            };

            /**
             * Creates a WriteCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             */
            WriteCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteCLIOptions)
                    return object;
                var message = new $root.protos.opts.WriteCLIOptions();
                if (object.inputFile != null)
                    message.inputFile = String(object.inputFile);
                if (object.inputAsJsonArray != null)
                    message.inputAsJsonArray = Boolean(object.inputAsJsonArray);
                if (object.inputStdin) {
                    if (!Array.isArray(object.inputStdin))
                        throw TypeError(".protos.opts.WriteCLIOptions.inputStdin: array expected");
                    message.inputStdin = [];
                    for (var i = 0; i < object.inputStdin.length; ++i)
                        message.inputStdin[i] = String(object.inputStdin[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.WriteCLIOptions} message WriteCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.inputStdin = [];
                if (options.defaults) {
                    object.inputFile = "";
                    object.inputAsJsonArray = false;
                }
                if (message.inputFile != null && message.hasOwnProperty("inputFile"))
                    object.inputFile = message.inputFile;
                if (message.inputAsJsonArray != null && message.hasOwnProperty("inputAsJsonArray"))
                    object.inputAsJsonArray = message.inputAsJsonArray;
                if (message.inputStdin && message.inputStdin.length) {
                    object.inputStdin = [];
                    for (var j = 0; j < message.inputStdin.length; ++j)
                        object.inputStdin[j] = message.inputStdin[j];
                }
                return object;
            };

            /**
             * Converts this WriteCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteCLIOptions;
        })();

        opts.WriteOptions = (function() {

            /**
             * Properties of a WriteOptions.
             * @memberof protos.opts
             * @interface IWriteOptions
             * @property {string|null} [connectionId] WriteOptions connectionId
             * @property {protos.records.IWriteRecord|null} [record] WriteOptions record
             * @property {protos.encoding.IEncodeOptions|null} [encodeOptions] WriteOptions encodeOptions
             * @property {protos.opts.IWriteCLIOptions|null} [_cliOptions] WriteOptions _cliOptions
             * @property {protos.opts.IWriteGroupKafkaOptions|null} [kafka] WriteOptions kafka
             * @property {protos.opts.IWriteGroupActiveMQOptions|null} [activemq] WriteOptions activemq
             * @property {protos.opts.IWriteGroupAWSSQSOptions|null} [awssqs] WriteOptions awssqs
             * @property {protos.opts.IWriteGroupAWSSNSOptions|null} [awssns] WriteOptions awssns
             * @property {protos.opts.IWriteGroupNatsOptions|null} [nats] WriteOptions nats
             * @property {protos.opts.IWriteGroupNatsStreamingOptions|null} [natsStreaming] WriteOptions natsStreaming
             * @property {protos.opts.IWriteGroupNSQOptions|null} [nsq] WriteOptions nsq
             * @property {protos.opts.IWriteGroupPulsarOptions|null} [pulsar] WriteOptions pulsar
             * @property {protos.opts.IWriteGroupRabbitOptions|null} [rabbit] WriteOptions rabbit
             * @property {protos.opts.IWriteGroupRabbitStreamsOptions|null} [rabbitStreams] WriteOptions rabbitStreams
             * @property {protos.opts.IWriteGroupMQTTOptions|null} [mqtt] WriteOptions mqtt
             * @property {protos.opts.IWriteGroupAzureServiceBusOptions|null} [azureServiceBus] WriteOptions azureServiceBus
             * @property {protos.opts.IWriteGroupAzureEventHubOptions|null} [azureEventHub] WriteOptions azureEventHub
             * @property {protos.opts.IWriteGroupGCPPubSubOptions|null} [gcpPubsub] WriteOptions gcpPubsub
             * @property {protos.opts.IWriteGroupKubeMQQueueOptions|null} [kubemqQueue] WriteOptions kubemqQueue
             * @property {protos.opts.IWriteGroupRedisPubSubOptions|null} [redisPubsub] WriteOptions redisPubsub
             * @property {protos.opts.IWriteGroupRedisStreamsOptions|null} [redisStreams] WriteOptions redisStreams
             */

            /**
             * Constructs a new WriteOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteOptions.
             * @implements IWriteOptions
             * @constructor
             * @param {protos.opts.IWriteOptions=} [properties] Properties to set
             */
            function WriteOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.connectionId = "";

            /**
             * WriteOptions record.
             * @member {protos.records.IWriteRecord|null|undefined} record
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.record = null;

            /**
             * WriteOptions encodeOptions.
             * @member {protos.encoding.IEncodeOptions|null|undefined} encodeOptions
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.encodeOptions = null;

            /**
             * WriteOptions _cliOptions.
             * @member {protos.opts.IWriteCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype._cliOptions = null;

            /**
             * WriteOptions kafka.
             * @member {protos.opts.IWriteGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.kafka = null;

            /**
             * WriteOptions activemq.
             * @member {protos.opts.IWriteGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.activemq = null;

            /**
             * WriteOptions awssqs.
             * @member {protos.opts.IWriteGroupAWSSQSOptions|null|undefined} awssqs
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.awssqs = null;

            /**
             * WriteOptions awssns.
             * @member {protos.opts.IWriteGroupAWSSNSOptions|null|undefined} awssns
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.awssns = null;

            /**
             * WriteOptions nats.
             * @member {protos.opts.IWriteGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.nats = null;

            /**
             * WriteOptions natsStreaming.
             * @member {protos.opts.IWriteGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.natsStreaming = null;

            /**
             * WriteOptions nsq.
             * @member {protos.opts.IWriteGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.nsq = null;

            /**
             * WriteOptions pulsar.
             * @member {protos.opts.IWriteGroupPulsarOptions|null|undefined} pulsar
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.pulsar = null;

            /**
             * WriteOptions rabbit.
             * @member {protos.opts.IWriteGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.rabbit = null;

            /**
             * WriteOptions rabbitStreams.
             * @member {protos.opts.IWriteGroupRabbitStreamsOptions|null|undefined} rabbitStreams
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.rabbitStreams = null;

            /**
             * WriteOptions mqtt.
             * @member {protos.opts.IWriteGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.mqtt = null;

            /**
             * WriteOptions azureServiceBus.
             * @member {protos.opts.IWriteGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.azureServiceBus = null;

            /**
             * WriteOptions azureEventHub.
             * @member {protos.opts.IWriteGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.azureEventHub = null;

            /**
             * WriteOptions gcpPubsub.
             * @member {protos.opts.IWriteGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.gcpPubsub = null;

            /**
             * WriteOptions kubemqQueue.
             * @member {protos.opts.IWriteGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.kubemqQueue = null;

            /**
             * WriteOptions redisPubsub.
             * @member {protos.opts.IWriteGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.redisPubsub = null;

            /**
             * WriteOptions redisStreams.
             * @member {protos.opts.IWriteGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.redisStreams = null;

            /**
             * Creates a new WriteOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteOptions} WriteOptions instance
             */
            WriteOptions.create = function create(properties) {
                return new WriteOptions(properties);
            };

            /**
             * Encodes the specified WriteOptions message. Does not implicitly {@link protos.opts.WriteOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions} message WriteOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
                if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                    $root.protos.records.WriteRecord.encode(message.record, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.encodeOptions != null && Object.hasOwnProperty.call(message, "encodeOptions"))
                    $root.protos.encoding.EncodeOptions.encode(message.encodeOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.WriteGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.WriteGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.opts.WriteGroupAWSSQSOptions.encode(message.awssqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awssns != null && Object.hasOwnProperty.call(message, "awssns"))
                    $root.protos.opts.WriteGroupAWSSNSOptions.encode(message.awssns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.WriteGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.WriteGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.WriteGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.opts.WriteGroupPulsarOptions.encode(message.pulsar, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.WriteGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.opts.WriteGroupRabbitStreamsOptions.encode(message.rabbitStreams, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.WriteGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.WriteGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.WriteGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.WriteGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.WriteGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.WriteGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.WriteGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.WriteCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteOptions message, length delimited. Does not implicitly {@link protos.opts.WriteOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions} message WriteOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteOptions} WriteOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionId = reader.string();
                        break;
                    case 2:
                        message.record = $root.protos.records.WriteRecord.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.encodeOptions = $root.protos.encoding.EncodeOptions.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._cliOptions = $root.protos.opts.WriteCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.WriteGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.WriteGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awssns = $root.protos.opts.WriteGroupAWSSNSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.WriteGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.WriteGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.pulsar = $root.protos.opts.WriteGroupPulsarOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.mqtt = $root.protos.opts.WriteGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteOptions} WriteOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteOptions message.
             * @function verify
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.record != null && message.hasOwnProperty("record")) {
                    var error = $root.protos.records.WriteRecord.verify(message.record);
                    if (error)
                        return "record." + error;
                }
                if (message.encodeOptions != null && message.hasOwnProperty("encodeOptions")) {
                    var error = $root.protos.encoding.EncodeOptions.verify(message.encodeOptions);
                    if (error)
                        return "encodeOptions." + error;
                }
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    var error = $root.protos.opts.WriteCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.WriteGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    var error = $root.protos.opts.WriteGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    var error = $root.protos.opts.WriteGroupAWSSQSOptions.verify(message.awssqs);
                    if (error)
                        return "awssqs." + error;
                }
                if (message.awssns != null && message.hasOwnProperty("awssns")) {
                    var error = $root.protos.opts.WriteGroupAWSSNSOptions.verify(message.awssns);
                    if (error)
                        return "awssns." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.WriteGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.WriteGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.WriteGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    var error = $root.protos.opts.WriteGroupPulsarOptions.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.WriteGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    var error = $root.protos.opts.WriteGroupRabbitStreamsOptions.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.WriteGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.WriteGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.opts.WriteGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.WriteGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.WriteGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.WriteGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.WriteGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                return null;
            };

            /**
             * Creates a WriteOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteOptions} WriteOptions
             */
            WriteOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteOptions)
                    return object;
                var message = new $root.protos.opts.WriteOptions();
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.record != null) {
                    if (typeof object.record !== "object")
                        throw TypeError(".protos.opts.WriteOptions.record: object expected");
                    message.record = $root.protos.records.WriteRecord.fromObject(object.record);
                }
                if (object.encodeOptions != null) {
                    if (typeof object.encodeOptions !== "object")
                        throw TypeError(".protos.opts.WriteOptions.encodeOptions: object expected");
                    message.encodeOptions = $root.protos.encoding.EncodeOptions.fromObject(object.encodeOptions);
                }
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.WriteOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.WriteCLIOptions.fromObject(object._cliOptions);
                }
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.WriteOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.WriteGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.WriteOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.WriteGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.WriteOptions.awssqs: object expected");
                    message.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.fromObject(object.awssqs);
                }
                if (object.awssns != null) {
                    if (typeof object.awssns !== "object")
                        throw TypeError(".protos.opts.WriteOptions.awssns: object expected");
                    message.awssns = $root.protos.opts.WriteGroupAWSSNSOptions.fromObject(object.awssns);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.WriteOptions.nats: object expected");
                    message.nats = $root.protos.opts.WriteGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.WriteOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.WriteOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.WriteGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.WriteOptions.pulsar: object expected");
                    message.pulsar = $root.protos.opts.WriteGroupPulsarOptions.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.WriteOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.WriteOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.fromObject(object.rabbitStreams);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.WriteOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.WriteGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.WriteOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.WriteOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.WriteOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.WriteOptions} message WriteOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.connectionId = "";
                    object.record = null;
                    object.encodeOptions = null;
                    object.kafka = null;
                    object.activemq = null;
                    object.awssqs = null;
                    object.awssns = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.pulsar = null;
                    object.rabbit = null;
                    object.rabbitStreams = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object._cliOptions = null;
                }
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.record != null && message.hasOwnProperty("record"))
                    object.record = $root.protos.records.WriteRecord.toObject(message.record, options);
                if (message.encodeOptions != null && message.hasOwnProperty("encodeOptions"))
                    object.encodeOptions = $root.protos.encoding.EncodeOptions.toObject(message.encodeOptions, options);
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.WriteGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.WriteGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awssqs != null && message.hasOwnProperty("awssqs"))
                    object.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.toObject(message.awssqs, options);
                if (message.awssns != null && message.hasOwnProperty("awssns"))
                    object.awssns = $root.protos.opts.WriteGroupAWSSNSOptions.toObject(message.awssns, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.WriteGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.WriteGroupNSQOptions.toObject(message.nsq, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.opts.WriteGroupPulsarOptions.toObject(message.pulsar, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.WriteGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.toObject(message.rabbitStreams, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.WriteGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.WriteCLIOptions.toObject(message._cliOptions, options);
                return object;
            };

            /**
             * Converts this WriteOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteOptions;
        })();

        opts.WriteGroupKafkaOptions = (function() {

            /**
             * Properties of a WriteGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IWriteGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] WriteGroupKafkaOptions _conn
             * @property {protos.args.IKafkaWriteArgs|null} [args] WriteGroupKafkaOptions args
             */

            /**
             * Constructs a new WriteGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupKafkaOptions.
             * @implements IWriteGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IWriteGroupKafkaOptions=} [properties] Properties to set
             */
            function WriteGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             */
            WriteGroupKafkaOptions.prototype._conn = null;

            /**
             * WriteGroupKafkaOptions args.
             * @member {protos.args.IKafkaWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             */
            WriteGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions instance
             */
            WriteGroupKafkaOptions.create = function create(properties) {
                return new WriteGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupKafkaOptions message. Does not implicitly {@link protos.opts.WriteGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions} message WriteGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions} message WriteGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             */
            WriteGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.WriteGroupKafkaOptions} message WriteGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupKafkaOptions;
        })();

        opts.WriteGroupActiveMQOptions = (function() {

            /**
             * Properties of a WriteGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IWriteGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] WriteGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQWriteArgs|null} [args] WriteGroupActiveMQOptions args
             */

            /**
             * Constructs a new WriteGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupActiveMQOptions.
             * @implements IWriteGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IWriteGroupActiveMQOptions=} [properties] Properties to set
             */
            function WriteGroupActiveMQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             */
            WriteGroupActiveMQOptions.prototype._conn = null;

            /**
             * WriteGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             */
            WriteGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions instance
             */
            WriteGroupActiveMQOptions.create = function create(properties) {
                return new WriteGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupActiveMQOptions message. Does not implicitly {@link protos.opts.WriteGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions} message WriteGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions} message WriteGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupActiveMQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.ActiveMQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             */
            WriteGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupActiveMQOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.WriteGroupActiveMQOptions} message WriteGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupActiveMQOptions;
        })();

        opts.WriteGroupAWSSQSOptions = (function() {

            /**
             * Properties of a WriteGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] WriteGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSWriteArgs|null} [args] WriteGroupAWSSQSOptions args
             */

            /**
             * Constructs a new WriteGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAWSSQSOptions.
             * @implements IWriteGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAWSSQSOptions=} [properties] Properties to set
             */
            function WriteGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             */
            WriteGroupAWSSQSOptions.prototype._conn = null;

            /**
             * WriteGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             */
            WriteGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions instance
             */
            WriteGroupAWSSQSOptions.create = function create(properties) {
                return new WriteGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.WriteGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             */
            WriteGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.WriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAWSSQSOptions;
        })();

        opts.WriteGroupAWSSNSOptions = (function() {

            /**
             * Properties of a WriteGroupAWSSNSOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAWSSNSOptions
             * @property {protos.args.IAWSSNSConn|null} [_conn] WriteGroupAWSSNSOptions _conn
             * @property {protos.args.IAWSSNSWriteArgs|null} [args] WriteGroupAWSSNSOptions args
             */

            /**
             * Constructs a new WriteGroupAWSSNSOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAWSSNSOptions.
             * @implements IWriteGroupAWSSNSOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAWSSNSOptions=} [properties] Properties to set
             */
            function WriteGroupAWSSNSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAWSSNSOptions _conn.
             * @member {protos.args.IAWSSNSConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             */
            WriteGroupAWSSNSOptions.prototype._conn = null;

            /**
             * WriteGroupAWSSNSOptions args.
             * @member {protos.args.IAWSSNSWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             */
            WriteGroupAWSSNSOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAWSSNSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions instance
             */
            WriteGroupAWSSNSOptions.create = function create(properties) {
                return new WriteGroupAWSSNSOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAWSSNSOptions message. Does not implicitly {@link protos.opts.WriteGroupAWSSNSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSNSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSNSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSNSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAWSSNSOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAWSSNSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSNSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAWSSNSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSNSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAWSSNSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSNSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAWSSNSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSNSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAWSSNSOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAWSSNSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSNSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSNSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAWSSNSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             */
            WriteGroupAWSSNSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAWSSNSOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAWSSNSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSNSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSNSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSNSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSNSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAWSSNSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.WriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAWSSNSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSNSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSNSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAWSSNSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAWSSNSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAWSSNSOptions;
        })();

        opts.WriteGroupNatsOptions = (function() {

            /**
             * Properties of a WriteGroupNatsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] WriteGroupNatsOptions _conn
             * @property {protos.args.INatsWriteArgs|null} [args] WriteGroupNatsOptions args
             */

            /**
             * Constructs a new WriteGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNatsOptions.
             * @implements IWriteGroupNatsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNatsOptions=} [properties] Properties to set
             */
            function WriteGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             */
            WriteGroupNatsOptions.prototype._conn = null;

            /**
             * WriteGroupNatsOptions args.
             * @member {protos.args.INatsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             */
            WriteGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions instance
             */
            WriteGroupNatsOptions.create = function create(properties) {
                return new WriteGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNatsOptions message. Does not implicitly {@link protos.opts.WriteGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions} message WriteGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions} message WriteGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             */
            WriteGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.WriteGroupNatsOptions} message WriteGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNatsOptions;
        })();

        opts.WriteGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a WriteGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] WriteGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingWriteArgs|null} [args] WriteGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new WriteGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNatsStreamingOptions.
             * @implements IWriteGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function WriteGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             */
            WriteGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * WriteGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             */
            WriteGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions instance
             */
            WriteGroupNatsStreamingOptions.create = function create(properties) {
                return new WriteGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.WriteGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             */
            WriteGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.WriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNatsStreamingOptions;
        })();

        opts.WriteGroupNSQOptions = (function() {

            /**
             * Properties of a WriteGroupNSQOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] WriteGroupNSQOptions _conn
             * @property {protos.args.INSQWriteArgs|null} [args] WriteGroupNSQOptions args
             */

            /**
             * Constructs a new WriteGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNSQOptions.
             * @implements IWriteGroupNSQOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNSQOptions=} [properties] Properties to set
             */
            function WriteGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             */
            WriteGroupNSQOptions.prototype._conn = null;

            /**
             * WriteGroupNSQOptions args.
             * @member {protos.args.INSQWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             */
            WriteGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions instance
             */
            WriteGroupNSQOptions.create = function create(properties) {
                return new WriteGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNSQOptions message. Does not implicitly {@link protos.opts.WriteGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions} message WriteGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions} message WriteGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             */
            WriteGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.WriteGroupNSQOptions} message WriteGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNSQOptions;
        })();

        opts.WriteGroupPulsarOptions = (function() {

            /**
             * Properties of a WriteGroupPulsarOptions.
             * @memberof protos.opts
             * @interface IWriteGroupPulsarOptions
             * @property {protos.args.IPulsarConn|null} [_conn] WriteGroupPulsarOptions _conn
             * @property {protos.args.IPulsarWriteArgs|null} [args] WriteGroupPulsarOptions args
             */

            /**
             * Constructs a new WriteGroupPulsarOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupPulsarOptions.
             * @implements IWriteGroupPulsarOptions
             * @constructor
             * @param {protos.opts.IWriteGroupPulsarOptions=} [properties] Properties to set
             */
            function WriteGroupPulsarOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupPulsarOptions _conn.
             * @member {protos.args.IPulsarConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             */
            WriteGroupPulsarOptions.prototype._conn = null;

            /**
             * WriteGroupPulsarOptions args.
             * @member {protos.args.IPulsarWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             */
            WriteGroupPulsarOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupPulsarOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions instance
             */
            WriteGroupPulsarOptions.create = function create(properties) {
                return new WriteGroupPulsarOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupPulsarOptions message. Does not implicitly {@link protos.opts.WriteGroupPulsarOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions} message WriteGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupPulsarOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PulsarConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PulsarWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupPulsarOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupPulsarOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions} message WriteGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupPulsarOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupPulsarOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupPulsarOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupPulsarOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PulsarWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupPulsarOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupPulsarOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupPulsarOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupPulsarOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PulsarConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PulsarWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupPulsarOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             */
            WriteGroupPulsarOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupPulsarOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupPulsarOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupPulsarOptions._conn: object expected");
                    message._conn = $root.protos.args.PulsarConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupPulsarOptions.args: object expected");
                    message.args = $root.protos.args.PulsarWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupPulsarOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.WriteGroupPulsarOptions} message WriteGroupPulsarOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupPulsarOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PulsarConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PulsarWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupPulsarOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupPulsarOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupPulsarOptions;
        })();

        opts.WriteGroupRabbitOptions = (function() {

            /**
             * Properties of a WriteGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] WriteGroupRabbitOptions _conn
             * @property {protos.args.IRabbitWriteArgs|null} [args] WriteGroupRabbitOptions args
             */

            /**
             * Constructs a new WriteGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRabbitOptions.
             * @implements IWriteGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRabbitOptions=} [properties] Properties to set
             */
            function WriteGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             */
            WriteGroupRabbitOptions.prototype._conn = null;

            /**
             * WriteGroupRabbitOptions args.
             * @member {protos.args.IRabbitWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             */
            WriteGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions instance
             */
            WriteGroupRabbitOptions.create = function create(properties) {
                return new WriteGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRabbitOptions message. Does not implicitly {@link protos.opts.WriteGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions} message WriteGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions} message WriteGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             */
            WriteGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.WriteGroupRabbitOptions} message WriteGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRabbitOptions;
        })();

        opts.WriteGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a WriteGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] WriteGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsWriteArgs|null} [args] WriteGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new WriteGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRabbitStreamsOptions.
             * @implements IWriteGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function WriteGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             */
            WriteGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * WriteGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             */
            WriteGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions instance
             */
            WriteGroupRabbitStreamsOptions.create = function create(properties) {
                return new WriteGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.WriteGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             */
            WriteGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRabbitStreamsOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.WriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRabbitStreamsOptions;
        })();

        opts.WriteGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a WriteGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] WriteGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubWriteArgs|null} [args] WriteGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new WriteGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRedisPubSubOptions.
             * @implements IWriteGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function WriteGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             */
            WriteGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * WriteGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             */
            WriteGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions instance
             */
            WriteGroupRedisPubSubOptions.create = function create(properties) {
                return new WriteGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.WriteGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             */
            WriteGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.WriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRedisPubSubOptions;
        })();

        opts.WriteGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a WriteGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] WriteGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsWriteArgs|null} [args] WriteGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new WriteGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRedisStreamsOptions.
             * @implements IWriteGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function WriteGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             */
            WriteGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * WriteGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             */
            WriteGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions instance
             */
            WriteGroupRedisStreamsOptions.create = function create(properties) {
                return new WriteGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.WriteGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             */
            WriteGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.WriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRedisStreamsOptions;
        })();

        opts.WriteGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a WriteGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] WriteGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubWriteArgs|null} [args] WriteGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new WriteGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAzureEventHubOptions.
             * @implements IWriteGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function WriteGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             */
            WriteGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * WriteGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             */
            WriteGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions instance
             */
            WriteGroupAzureEventHubOptions.create = function create(properties) {
                return new WriteGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.WriteGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureEventHubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             */
            WriteGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAzureEventHubOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.WriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAzureEventHubOptions;
        })();

        opts.WriteGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a WriteGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] WriteGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusWriteArgs|null} [args] WriteGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new WriteGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAzureServiceBusOptions.
             * @implements IWriteGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function WriteGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             */
            WriteGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * WriteGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             */
            WriteGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions instance
             */
            WriteGroupAzureServiceBusOptions.create = function create(properties) {
                return new WriteGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.WriteGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             */
            WriteGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.WriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAzureServiceBusOptions;
        })();

        opts.WriteGroupMQTTOptions = (function() {

            /**
             * Properties of a WriteGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IWriteGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] WriteGroupMQTTOptions _conn
             * @property {protos.args.IMQTTWriteArgs|null} [args] WriteGroupMQTTOptions args
             */

            /**
             * Constructs a new WriteGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupMQTTOptions.
             * @implements IWriteGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IWriteGroupMQTTOptions=} [properties] Properties to set
             */
            function WriteGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             */
            WriteGroupMQTTOptions.prototype._conn = null;

            /**
             * WriteGroupMQTTOptions args.
             * @member {protos.args.IMQTTWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             */
            WriteGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions instance
             */
            WriteGroupMQTTOptions.create = function create(properties) {
                return new WriteGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupMQTTOptions message. Does not implicitly {@link protos.opts.WriteGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions} message WriteGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions} message WriteGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             */
            WriteGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.WriteGroupMQTTOptions} message WriteGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupMQTTOptions;
        })();

        opts.WriteGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a WriteGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] WriteGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubWriteArgs|null} [args] WriteGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new WriteGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupGCPPubSubOptions.
             * @implements IWriteGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function WriteGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             */
            WriteGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * WriteGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             */
            WriteGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions instance
             */
            WriteGroupGCPPubSubOptions.create = function create(properties) {
                return new WriteGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.WriteGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             */
            WriteGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.WriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupGCPPubSubOptions;
        })();

        opts.WriteGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a WriteGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IWriteGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] WriteGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueWriteArgs|null} [args] WriteGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new WriteGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupKubeMQQueueOptions.
             * @implements IWriteGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function WriteGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             */
            WriteGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * WriteGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             */
            WriteGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions instance
             */
            WriteGroupKubeMQQueueOptions.create = function create(properties) {
                return new WriteGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.WriteGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             */
            WriteGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.WriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupKubeMQQueueOptions;
        })();

        opts.RelayCLIOptions = (function() {

            /**
             * Properties of a RelayCLIOptions.
             * @memberof protos.opts
             * @interface IRelayCLIOptions
             * @property {string|null} [httpListenAddress] RelayCLIOptions httpListenAddress
             */

            /**
             * Constructs a new RelayCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayCLIOptions.
             * @implements IRelayCLIOptions
             * @constructor
             * @param {protos.opts.IRelayCLIOptions=} [properties] Properties to set
             */
            function RelayCLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayCLIOptions httpListenAddress.
             * @member {string} httpListenAddress
             * @memberof protos.opts.RelayCLIOptions
             * @instance
             */
            RelayCLIOptions.prototype.httpListenAddress = "";

            /**
             * Creates a new RelayCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions instance
             */
            RelayCLIOptions.create = function create(properties) {
                return new RelayCLIOptions(properties);
            };

            /**
             * Encodes the specified RelayCLIOptions message. Does not implicitly {@link protos.opts.RelayCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions} message RelayCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.httpListenAddress != null && Object.hasOwnProperty.call(message, "httpListenAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.httpListenAddress);
                return writer;
            };

            /**
             * Encodes the specified RelayCLIOptions message, length delimited. Does not implicitly {@link protos.opts.RelayCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions} message RelayCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.httpListenAddress = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayCLIOptions message.
             * @function verify
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    if (!$util.isString(message.httpListenAddress))
                        return "httpListenAddress: string expected";
                return null;
            };

            /**
             * Creates a RelayCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             */
            RelayCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayCLIOptions)
                    return object;
                var message = new $root.protos.opts.RelayCLIOptions();
                if (object.httpListenAddress != null)
                    message.httpListenAddress = String(object.httpListenAddress);
                return message;
            };

            /**
             * Creates a plain object from a RelayCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.RelayCLIOptions} message RelayCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.httpListenAddress = "";
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    object.httpListenAddress = message.httpListenAddress;
                return object;
            };

            /**
             * Converts this RelayCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayCLIOptions;
        })();

        opts.RelayOptions = (function() {

            /**
             * Properties of a RelayOptions.
             * @memberof protos.opts
             * @interface IRelayOptions
             * @property {string|null} [collectionToken] RelayOptions collectionToken
             * @property {number|null} [batchSize] RelayOptions batchSize
             * @property {number|null} [batchMaxRetry] RelayOptions batchMaxRetry
             * @property {string|null} [connectionId] RelayOptions connectionId
             * @property {number|null} [numWorkers] RelayOptions numWorkers
             * @property {string|null} [_batchshGrpcAddress] RelayOptions _batchshGrpcAddress
             * @property {boolean|null} [_batchshGrpcDisableTls] RelayOptions _batchshGrpcDisableTls
             * @property {number|null} [_batchshGrpcTimeoutSeconds] RelayOptions _batchshGrpcTimeoutSeconds
             * @property {string|null} [_relayId] RelayOptions _relayId
             * @property {protos.opts.IRelayCLIOptions|null} [_cliOptions] RelayOptions _cliOptions
             * @property {protos.opts.IRelayGroupKafkaOptions|null} [kafka] RelayOptions kafka
             * @property {protos.opts.IRelayGroupAWSSQSOptions|null} [awssqs] RelayOptions awssqs
             * @property {protos.opts.IRelayGroupMongoOptions|null} [mongo] RelayOptions mongo
             * @property {protos.opts.IRelayGroupNSQOptions|null} [nsq] RelayOptions nsq
             * @property {protos.opts.IRelayGroupRabbitOptions|null} [rabbit] RelayOptions rabbit
             * @property {protos.opts.IRelayGroupMQTTOptions|null} [mqtt] RelayOptions mqtt
             * @property {protos.opts.IRelayGroupAzureServiceBusOptions|null} [azureServiceBus] RelayOptions azureServiceBus
             * @property {protos.opts.IRelayGroupGCPPubSubOptions|null} [gcpPubsub] RelayOptions gcpPubsub
             * @property {protos.opts.IRelayGroupKubeMQQueueOptions|null} [kubemqQueue] RelayOptions kubemqQueue
             * @property {protos.opts.IRelayGroupRedisPubSubOptions|null} [redisPubsub] RelayOptions redisPubsub
             * @property {protos.opts.IRelayGroupRedisStreamsOptions|null} [redisStreams] RelayOptions redisStreams
             * @property {protos.opts.IRelayGroupPostgresOptions|null} [postgres] RelayOptions postgres
             */

            /**
             * Constructs a new RelayOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayOptions.
             * @implements IRelayOptions
             * @constructor
             * @param {protos.opts.IRelayOptions=} [properties] Properties to set
             */
            function RelayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayOptions collectionToken.
             * @member {string} collectionToken
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.collectionToken = "";

            /**
             * RelayOptions batchSize.
             * @member {number} batchSize
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.batchSize = 0;

            /**
             * RelayOptions batchMaxRetry.
             * @member {number} batchMaxRetry
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.batchMaxRetry = 0;

            /**
             * RelayOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.connectionId = "";

            /**
             * RelayOptions numWorkers.
             * @member {number} numWorkers
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.numWorkers = 0;

            /**
             * RelayOptions _batchshGrpcAddress.
             * @member {string} _batchshGrpcAddress
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._batchshGrpcAddress = "";

            /**
             * RelayOptions _batchshGrpcDisableTls.
             * @member {boolean} _batchshGrpcDisableTls
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._batchshGrpcDisableTls = false;

            /**
             * RelayOptions _batchshGrpcTimeoutSeconds.
             * @member {number} _batchshGrpcTimeoutSeconds
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._batchshGrpcTimeoutSeconds = 0;

            /**
             * RelayOptions _relayId.
             * @member {string} _relayId
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._relayId = "";

            /**
             * RelayOptions _cliOptions.
             * @member {protos.opts.IRelayCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._cliOptions = null;

            /**
             * RelayOptions kafka.
             * @member {protos.opts.IRelayGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.kafka = null;

            /**
             * RelayOptions awssqs.
             * @member {protos.opts.IRelayGroupAWSSQSOptions|null|undefined} awssqs
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.awssqs = null;

            /**
             * RelayOptions mongo.
             * @member {protos.opts.IRelayGroupMongoOptions|null|undefined} mongo
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.mongo = null;

            /**
             * RelayOptions nsq.
             * @member {protos.opts.IRelayGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.nsq = null;

            /**
             * RelayOptions rabbit.
             * @member {protos.opts.IRelayGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.rabbit = null;

            /**
             * RelayOptions mqtt.
             * @member {protos.opts.IRelayGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.mqtt = null;

            /**
             * RelayOptions azureServiceBus.
             * @member {protos.opts.IRelayGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.azureServiceBus = null;

            /**
             * RelayOptions gcpPubsub.
             * @member {protos.opts.IRelayGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.gcpPubsub = null;

            /**
             * RelayOptions kubemqQueue.
             * @member {protos.opts.IRelayGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.kubemqQueue = null;

            /**
             * RelayOptions redisPubsub.
             * @member {protos.opts.IRelayGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.redisPubsub = null;

            /**
             * RelayOptions redisStreams.
             * @member {protos.opts.IRelayGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.redisStreams = null;

            /**
             * RelayOptions postgres.
             * @member {protos.opts.IRelayGroupPostgresOptions|null|undefined} postgres
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.postgres = null;

            /**
             * Creates a new RelayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayOptions} RelayOptions instance
             */
            RelayOptions.create = function create(properties) {
                return new RelayOptions(properties);
            };

            /**
             * Encodes the specified RelayOptions message. Does not implicitly {@link protos.opts.RelayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions} message RelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collectionToken != null && Object.hasOwnProperty.call(message, "collectionToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collectionToken);
                if (message.batchSize != null && Object.hasOwnProperty.call(message, "batchSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.batchSize);
                if (message.batchMaxRetry != null && Object.hasOwnProperty.call(message, "batchMaxRetry"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.batchMaxRetry);
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.connectionId);
                if (message.numWorkers != null && Object.hasOwnProperty.call(message, "numWorkers"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.numWorkers);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.RelayGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.opts.RelayGroupAWSSQSOptions.encode(message.awssqs, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.opts.RelayGroupMongoOptions.encode(message.mongo, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.RelayGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.RelayGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.RelayGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.RelayGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.RelayGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.RelayGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.RelayGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.RelayGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.opts.RelayGroupPostgresOptions.encode(message.postgres, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message._batchshGrpcAddress != null && Object.hasOwnProperty.call(message, "_batchshGrpcAddress"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._batchshGrpcAddress);
                if (message._batchshGrpcDisableTls != null && Object.hasOwnProperty.call(message, "_batchshGrpcDisableTls"))
                    writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message._batchshGrpcDisableTls);
                if (message._batchshGrpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "_batchshGrpcTimeoutSeconds"))
                    writer.uint32(/* id 1002, wireType 0 =*/8016).int32(message._batchshGrpcTimeoutSeconds);
                if (message._relayId != null && Object.hasOwnProperty.call(message, "_relayId"))
                    writer.uint32(/* id 1003, wireType 2 =*/8026).string(message._relayId);
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.RelayCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1004, wireType 2 =*/8034).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayOptions message, length delimited. Does not implicitly {@link protos.opts.RelayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions} message RelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayOptions} RelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collectionToken = reader.string();
                        break;
                    case 2:
                        message.batchSize = reader.int32();
                        break;
                    case 3:
                        message.batchMaxRetry = reader.int32();
                        break;
                    case 4:
                        message.connectionId = reader.string();
                        break;
                    case 5:
                        message.numWorkers = reader.int32();
                        break;
                    case 1000:
                        message._batchshGrpcAddress = reader.string();
                        break;
                    case 1001:
                        message._batchshGrpcDisableTls = reader.bool();
                        break;
                    case 1002:
                        message._batchshGrpcTimeoutSeconds = reader.int32();
                        break;
                    case 1003:
                        message._relayId = reader.string();
                        break;
                    case 1004:
                        message._cliOptions = $root.protos.opts.RelayCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.RelayGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.awssqs = $root.protos.opts.RelayGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.mongo = $root.protos.opts.RelayGroupMongoOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.nsq = $root.protos.opts.RelayGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.rabbit = $root.protos.opts.RelayGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.mqtt = $root.protos.opts.RelayGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.postgres = $root.protos.opts.RelayGroupPostgresOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayOptions} RelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayOptions message.
             * @function verify
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collectionToken != null && message.hasOwnProperty("collectionToken"))
                    if (!$util.isString(message.collectionToken))
                        return "collectionToken: string expected";
                if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                    if (!$util.isInteger(message.batchSize))
                        return "batchSize: integer expected";
                if (message.batchMaxRetry != null && message.hasOwnProperty("batchMaxRetry"))
                    if (!$util.isInteger(message.batchMaxRetry))
                        return "batchMaxRetry: integer expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.numWorkers != null && message.hasOwnProperty("numWorkers"))
                    if (!$util.isInteger(message.numWorkers))
                        return "numWorkers: integer expected";
                if (message._batchshGrpcAddress != null && message.hasOwnProperty("_batchshGrpcAddress"))
                    if (!$util.isString(message._batchshGrpcAddress))
                        return "_batchshGrpcAddress: string expected";
                if (message._batchshGrpcDisableTls != null && message.hasOwnProperty("_batchshGrpcDisableTls"))
                    if (typeof message._batchshGrpcDisableTls !== "boolean")
                        return "_batchshGrpcDisableTls: boolean expected";
                if (message._batchshGrpcTimeoutSeconds != null && message.hasOwnProperty("_batchshGrpcTimeoutSeconds"))
                    if (!$util.isInteger(message._batchshGrpcTimeoutSeconds))
                        return "_batchshGrpcTimeoutSeconds: integer expected";
                if (message._relayId != null && message.hasOwnProperty("_relayId"))
                    if (!$util.isString(message._relayId))
                        return "_relayId: string expected";
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    var error = $root.protos.opts.RelayCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.RelayGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    var error = $root.protos.opts.RelayGroupAWSSQSOptions.verify(message.awssqs);
                    if (error)
                        return "awssqs." + error;
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    var error = $root.protos.opts.RelayGroupMongoOptions.verify(message.mongo);
                    if (error)
                        return "mongo." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.RelayGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.RelayGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.RelayGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.RelayGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.RelayGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.RelayGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.RelayGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.RelayGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    var error = $root.protos.opts.RelayGroupPostgresOptions.verify(message.postgres);
                    if (error)
                        return "postgres." + error;
                }
                return null;
            };

            /**
             * Creates a RelayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayOptions} RelayOptions
             */
            RelayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayOptions)
                    return object;
                var message = new $root.protos.opts.RelayOptions();
                if (object.collectionToken != null)
                    message.collectionToken = String(object.collectionToken);
                if (object.batchSize != null)
                    message.batchSize = object.batchSize | 0;
                if (object.batchMaxRetry != null)
                    message.batchMaxRetry = object.batchMaxRetry | 0;
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.numWorkers != null)
                    message.numWorkers = object.numWorkers | 0;
                if (object._batchshGrpcAddress != null)
                    message._batchshGrpcAddress = String(object._batchshGrpcAddress);
                if (object._batchshGrpcDisableTls != null)
                    message._batchshGrpcDisableTls = Boolean(object._batchshGrpcDisableTls);
                if (object._batchshGrpcTimeoutSeconds != null)
                    message._batchshGrpcTimeoutSeconds = object._batchshGrpcTimeoutSeconds | 0;
                if (object._relayId != null)
                    message._relayId = String(object._relayId);
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.RelayOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.RelayCLIOptions.fromObject(object._cliOptions);
                }
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.RelayOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.RelayGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.RelayOptions.awssqs: object expected");
                    message.awssqs = $root.protos.opts.RelayGroupAWSSQSOptions.fromObject(object.awssqs);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.RelayOptions.mongo: object expected");
                    message.mongo = $root.protos.opts.RelayGroupMongoOptions.fromObject(object.mongo);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.RelayOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.RelayGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.RelayOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.RelayGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.RelayOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.RelayGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.RelayOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.RelayOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.RelayOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.RelayOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.RelayOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.RelayOptions.postgres: object expected");
                    message.postgres = $root.protos.opts.RelayGroupPostgresOptions.fromObject(object.postgres);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.RelayOptions} message RelayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collectionToken = "";
                    object.batchSize = 0;
                    object.batchMaxRetry = 0;
                    object.connectionId = "";
                    object.numWorkers = 0;
                    object.kafka = null;
                    object.awssqs = null;
                    object.mongo = null;
                    object.nsq = null;
                    object.rabbit = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.postgres = null;
                    object._batchshGrpcAddress = "";
                    object._batchshGrpcDisableTls = false;
                    object._batchshGrpcTimeoutSeconds = 0;
                    object._relayId = "";
                    object._cliOptions = null;
                }
                if (message.collectionToken != null && message.hasOwnProperty("collectionToken"))
                    object.collectionToken = message.collectionToken;
                if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                    object.batchSize = message.batchSize;
                if (message.batchMaxRetry != null && message.hasOwnProperty("batchMaxRetry"))
                    object.batchMaxRetry = message.batchMaxRetry;
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.numWorkers != null && message.hasOwnProperty("numWorkers"))
                    object.numWorkers = message.numWorkers;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.RelayGroupKafkaOptions.toObject(message.kafka, options);
                if (message.awssqs != null && message.hasOwnProperty("awssqs"))
                    object.awssqs = $root.protos.opts.RelayGroupAWSSQSOptions.toObject(message.awssqs, options);
                if (message.mongo != null && message.hasOwnProperty("mongo"))
                    object.mongo = $root.protos.opts.RelayGroupMongoOptions.toObject(message.mongo, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.RelayGroupNSQOptions.toObject(message.nsq, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.RelayGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.RelayGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.postgres != null && message.hasOwnProperty("postgres"))
                    object.postgres = $root.protos.opts.RelayGroupPostgresOptions.toObject(message.postgres, options);
                if (message._batchshGrpcAddress != null && message.hasOwnProperty("_batchshGrpcAddress"))
                    object._batchshGrpcAddress = message._batchshGrpcAddress;
                if (message._batchshGrpcDisableTls != null && message.hasOwnProperty("_batchshGrpcDisableTls"))
                    object._batchshGrpcDisableTls = message._batchshGrpcDisableTls;
                if (message._batchshGrpcTimeoutSeconds != null && message.hasOwnProperty("_batchshGrpcTimeoutSeconds"))
                    object._batchshGrpcTimeoutSeconds = message._batchshGrpcTimeoutSeconds;
                if (message._relayId != null && message.hasOwnProperty("_relayId"))
                    object._relayId = message._relayId;
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.RelayCLIOptions.toObject(message._cliOptions, options);
                return object;
            };

            /**
             * Converts this RelayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayOptions;
        })();

        opts.RelayGroupKafkaOptions = (function() {

            /**
             * Properties of a RelayGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IRelayGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] RelayGroupKafkaOptions _conn
             * @property {protos.args.IKafkaRelayArgs|null} [args] RelayGroupKafkaOptions args
             */

            /**
             * Constructs a new RelayGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupKafkaOptions.
             * @implements IRelayGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IRelayGroupKafkaOptions=} [properties] Properties to set
             */
            function RelayGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             */
            RelayGroupKafkaOptions.prototype._conn = null;

            /**
             * RelayGroupKafkaOptions args.
             * @member {protos.args.IKafkaRelayArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             */
            RelayGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions instance
             */
            RelayGroupKafkaOptions.create = function create(properties) {
                return new RelayGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupKafkaOptions message. Does not implicitly {@link protos.opts.RelayGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions} message RelayGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaRelayArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions} message RelayGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaRelayArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaRelayArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             */
            RelayGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaRelayArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.RelayGroupKafkaOptions} message RelayGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaRelayArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupKafkaOptions;
        })();

        opts.RelayGroupAWSSQSOptions = (function() {

            /**
             * Properties of a RelayGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IRelayGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] RelayGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSRelayArgs|null} [args] RelayGroupAWSSQSOptions args
             */

            /**
             * Constructs a new RelayGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupAWSSQSOptions.
             * @implements IRelayGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IRelayGroupAWSSQSOptions=} [properties] Properties to set
             */
            function RelayGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             */
            RelayGroupAWSSQSOptions.prototype._conn = null;

            /**
             * RelayGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSRelayArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             */
            RelayGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions instance
             */
            RelayGroupAWSSQSOptions.create = function create(properties) {
                return new RelayGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.RelayGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSRelayArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSRelayArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSRelayArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             */
            RelayGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSRelayArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.RelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSRelayArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupAWSSQSOptions;
        })();

        opts.RelayGroupMongoOptions = (function() {

            /**
             * Properties of a RelayGroupMongoOptions.
             * @memberof protos.opts
             * @interface IRelayGroupMongoOptions
             * @property {protos.args.IMongoConn|null} [_conn] RelayGroupMongoOptions _conn
             * @property {protos.args.IMongoReadArgs|null} [args] RelayGroupMongoOptions args
             */

            /**
             * Constructs a new RelayGroupMongoOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupMongoOptions.
             * @implements IRelayGroupMongoOptions
             * @constructor
             * @param {protos.opts.IRelayGroupMongoOptions=} [properties] Properties to set
             */
            function RelayGroupMongoOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupMongoOptions _conn.
             * @member {protos.args.IMongoConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             */
            RelayGroupMongoOptions.prototype._conn = null;

            /**
             * RelayGroupMongoOptions args.
             * @member {protos.args.IMongoReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             */
            RelayGroupMongoOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupMongoOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions instance
             */
            RelayGroupMongoOptions.create = function create(properties) {
                return new RelayGroupMongoOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupMongoOptions message. Does not implicitly {@link protos.opts.RelayGroupMongoOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions} message RelayGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMongoOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MongoConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MongoReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupMongoOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupMongoOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions} message RelayGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMongoOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupMongoOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMongoOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupMongoOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MongoReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupMongoOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMongoOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupMongoOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupMongoOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MongoConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MongoReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupMongoOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             */
            RelayGroupMongoOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupMongoOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupMongoOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupMongoOptions._conn: object expected");
                    message._conn = $root.protos.args.MongoConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupMongoOptions.args: object expected");
                    message.args = $root.protos.args.MongoReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupMongoOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.RelayGroupMongoOptions} message RelayGroupMongoOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupMongoOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MongoConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MongoReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupMongoOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupMongoOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupMongoOptions;
        })();

        opts.RelayGroupNSQOptions = (function() {

            /**
             * Properties of a RelayGroupNSQOptions.
             * @memberof protos.opts
             * @interface IRelayGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] RelayGroupNSQOptions _conn
             * @property {protos.args.INSQReadArgs|null} [args] RelayGroupNSQOptions args
             */

            /**
             * Constructs a new RelayGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupNSQOptions.
             * @implements IRelayGroupNSQOptions
             * @constructor
             * @param {protos.opts.IRelayGroupNSQOptions=} [properties] Properties to set
             */
            function RelayGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             */
            RelayGroupNSQOptions.prototype._conn = null;

            /**
             * RelayGroupNSQOptions args.
             * @member {protos.args.INSQReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             */
            RelayGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions instance
             */
            RelayGroupNSQOptions.create = function create(properties) {
                return new RelayGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupNSQOptions message. Does not implicitly {@link protos.opts.RelayGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions} message RelayGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions} message RelayGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             */
            RelayGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.RelayGroupNSQOptions} message RelayGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupNSQOptions;
        })();

        opts.RelayGroupPostgresOptions = (function() {

            /**
             * Properties of a RelayGroupPostgresOptions.
             * @memberof protos.opts
             * @interface IRelayGroupPostgresOptions
             * @property {protos.args.IPostgresConn|null} [_conn] RelayGroupPostgresOptions _conn
             * @property {protos.args.IPostgresReadArgs|null} [args] RelayGroupPostgresOptions args
             */

            /**
             * Constructs a new RelayGroupPostgresOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupPostgresOptions.
             * @implements IRelayGroupPostgresOptions
             * @constructor
             * @param {protos.opts.IRelayGroupPostgresOptions=} [properties] Properties to set
             */
            function RelayGroupPostgresOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupPostgresOptions _conn.
             * @member {protos.args.IPostgresConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             */
            RelayGroupPostgresOptions.prototype._conn = null;

            /**
             * RelayGroupPostgresOptions args.
             * @member {protos.args.IPostgresReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             */
            RelayGroupPostgresOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupPostgresOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions instance
             */
            RelayGroupPostgresOptions.create = function create(properties) {
                return new RelayGroupPostgresOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupPostgresOptions message. Does not implicitly {@link protos.opts.RelayGroupPostgresOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions} message RelayGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupPostgresOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PostgresConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PostgresReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupPostgresOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupPostgresOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions} message RelayGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupPostgresOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupPostgresOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupPostgresOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupPostgresOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PostgresReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupPostgresOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupPostgresOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupPostgresOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupPostgresOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PostgresConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PostgresReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupPostgresOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             */
            RelayGroupPostgresOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupPostgresOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupPostgresOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupPostgresOptions._conn: object expected");
                    message._conn = $root.protos.args.PostgresConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupPostgresOptions.args: object expected");
                    message.args = $root.protos.args.PostgresReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupPostgresOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.RelayGroupPostgresOptions} message RelayGroupPostgresOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupPostgresOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PostgresConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PostgresReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupPostgresOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupPostgresOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupPostgresOptions;
        })();

        opts.RelayGroupRabbitOptions = (function() {

            /**
             * Properties of a RelayGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] RelayGroupRabbitOptions _conn
             * @property {protos.args.IRabbitReadArgs|null} [args] RelayGroupRabbitOptions args
             */

            /**
             * Constructs a new RelayGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRabbitOptions.
             * @implements IRelayGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRabbitOptions=} [properties] Properties to set
             */
            function RelayGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             */
            RelayGroupRabbitOptions.prototype._conn = null;

            /**
             * RelayGroupRabbitOptions args.
             * @member {protos.args.IRabbitReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             */
            RelayGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions instance
             */
            RelayGroupRabbitOptions.create = function create(properties) {
                return new RelayGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRabbitOptions message. Does not implicitly {@link protos.opts.RelayGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions} message RelayGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions} message RelayGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             */
            RelayGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.RelayGroupRabbitOptions} message RelayGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRabbitOptions;
        })();

        opts.RelayGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a RelayGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] RelayGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubReadArgs|null} [args] RelayGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new RelayGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRedisPubSubOptions.
             * @implements IRelayGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function RelayGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             */
            RelayGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * RelayGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             */
            RelayGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions instance
             */
            RelayGroupRedisPubSubOptions.create = function create(properties) {
                return new RelayGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.RelayGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             */
            RelayGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.RelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRedisPubSubOptions;
        })();

        opts.RelayGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a RelayGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] RelayGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsReadArgs|null} [args] RelayGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new RelayGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRedisStreamsOptions.
             * @implements IRelayGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function RelayGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             */
            RelayGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * RelayGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             */
            RelayGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions instance
             */
            RelayGroupRedisStreamsOptions.create = function create(properties) {
                return new RelayGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.RelayGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             */
            RelayGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.RelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRedisStreamsOptions;
        })();

        opts.RelayGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a RelayGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IRelayGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] RelayGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusReadArgs|null} [args] RelayGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new RelayGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupAzureServiceBusOptions.
             * @implements IRelayGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function RelayGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             */
            RelayGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * RelayGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             */
            RelayGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions instance
             */
            RelayGroupAzureServiceBusOptions.create = function create(properties) {
                return new RelayGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.RelayGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             */
            RelayGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.RelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupAzureServiceBusOptions;
        })();

        opts.RelayGroupMQTTOptions = (function() {

            /**
             * Properties of a RelayGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IRelayGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] RelayGroupMQTTOptions _conn
             * @property {protos.args.IMQTTReadArgs|null} [args] RelayGroupMQTTOptions args
             */

            /**
             * Constructs a new RelayGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupMQTTOptions.
             * @implements IRelayGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IRelayGroupMQTTOptions=} [properties] Properties to set
             */
            function RelayGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             */
            RelayGroupMQTTOptions.prototype._conn = null;

            /**
             * RelayGroupMQTTOptions args.
             * @member {protos.args.IMQTTReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             */
            RelayGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions instance
             */
            RelayGroupMQTTOptions.create = function create(properties) {
                return new RelayGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupMQTTOptions message. Does not implicitly {@link protos.opts.RelayGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions} message RelayGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions} message RelayGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             */
            RelayGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.RelayGroupMQTTOptions} message RelayGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupMQTTOptions;
        })();

        opts.RelayGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a RelayGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IRelayGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] RelayGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubReadArgs|null} [args] RelayGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new RelayGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupGCPPubSubOptions.
             * @implements IRelayGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IRelayGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function RelayGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             */
            RelayGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * RelayGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             */
            RelayGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions instance
             */
            RelayGroupGCPPubSubOptions.create = function create(properties) {
                return new RelayGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.RelayGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             */
            RelayGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.RelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupGCPPubSubOptions;
        })();

        opts.RelayGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a RelayGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IRelayGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] RelayGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueReadArgs|null} [args] RelayGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new RelayGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupKubeMQQueueOptions.
             * @implements IRelayGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function RelayGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             */
            RelayGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * RelayGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             */
            RelayGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions instance
             */
            RelayGroupKubeMQQueueOptions.create = function create(properties) {
                return new RelayGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.RelayGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             */
            RelayGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.RelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupKubeMQQueueOptions;
        })();

        opts.ServerOptions = (function() {

            /**
             * Properties of a ServerOptions.
             * @memberof protos.opts
             * @interface IServerOptions
             * @property {string|null} [nodeId] ServerOptions nodeId
             * @property {string|null} [clusterId] ServerOptions clusterId
             * @property {string|null} [grpcListenAddress] ServerOptions grpcListenAddress
             * @property {string|null} [authToken] ServerOptions authToken
             * @property {string|null} [initialCluster] ServerOptions initialCluster
             * @property {string|null} [advertisePeerUrl] ServerOptions advertisePeerUrl
             * @property {string|null} [advertiseClientUrl] ServerOptions advertiseClientUrl
             * @property {string|null} [listenerPeerUrl] ServerOptions listenerPeerUrl
             * @property {string|null} [listenerClientUrl] ServerOptions listenerClientUrl
             * @property {string|null} [peerToken] ServerOptions peerToken
             * @property {string|null} [vcserviceGrpcAddress] ServerOptions vcserviceGrpcAddress
             * @property {number|null} [vcserviceGrpcTimeoutSeconds] ServerOptions vcserviceGrpcTimeoutSeconds
             * @property {boolean|null} [vcserviceGrpcInsecure] ServerOptions vcserviceGrpcInsecure
             */

            /**
             * Constructs a new ServerOptions.
             * @memberof protos.opts
             * @classdesc Represents a ServerOptions.
             * @implements IServerOptions
             * @constructor
             * @param {protos.opts.IServerOptions=} [properties] Properties to set
             */
            function ServerOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServerOptions nodeId.
             * @member {string} nodeId
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.nodeId = "";

            /**
             * ServerOptions clusterId.
             * @member {string} clusterId
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.clusterId = "";

            /**
             * ServerOptions grpcListenAddress.
             * @member {string} grpcListenAddress
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.grpcListenAddress = "";

            /**
             * ServerOptions authToken.
             * @member {string} authToken
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.authToken = "";

            /**
             * ServerOptions initialCluster.
             * @member {string} initialCluster
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.initialCluster = "";

            /**
             * ServerOptions advertisePeerUrl.
             * @member {string} advertisePeerUrl
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.advertisePeerUrl = "";

            /**
             * ServerOptions advertiseClientUrl.
             * @member {string} advertiseClientUrl
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.advertiseClientUrl = "";

            /**
             * ServerOptions listenerPeerUrl.
             * @member {string} listenerPeerUrl
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.listenerPeerUrl = "";

            /**
             * ServerOptions listenerClientUrl.
             * @member {string} listenerClientUrl
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.listenerClientUrl = "";

            /**
             * ServerOptions peerToken.
             * @member {string} peerToken
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.peerToken = "";

            /**
             * ServerOptions vcserviceGrpcAddress.
             * @member {string} vcserviceGrpcAddress
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.vcserviceGrpcAddress = "";

            /**
             * ServerOptions vcserviceGrpcTimeoutSeconds.
             * @member {number} vcserviceGrpcTimeoutSeconds
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.vcserviceGrpcTimeoutSeconds = 0;

            /**
             * ServerOptions vcserviceGrpcInsecure.
             * @member {boolean} vcserviceGrpcInsecure
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.vcserviceGrpcInsecure = false;

            /**
             * Creates a new ServerOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions=} [properties] Properties to set
             * @returns {protos.opts.ServerOptions} ServerOptions instance
             */
            ServerOptions.create = function create(properties) {
                return new ServerOptions(properties);
            };

            /**
             * Encodes the specified ServerOptions message. Does not implicitly {@link protos.opts.ServerOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions} message ServerOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clusterId);
                if (message.grpcListenAddress != null && Object.hasOwnProperty.call(message, "grpcListenAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.grpcListenAddress);
                if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.authToken);
                if (message.initialCluster != null && Object.hasOwnProperty.call(message, "initialCluster"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.initialCluster);
                if (message.advertisePeerUrl != null && Object.hasOwnProperty.call(message, "advertisePeerUrl"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.advertisePeerUrl);
                if (message.advertiseClientUrl != null && Object.hasOwnProperty.call(message, "advertiseClientUrl"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.advertiseClientUrl);
                if (message.listenerPeerUrl != null && Object.hasOwnProperty.call(message, "listenerPeerUrl"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.listenerPeerUrl);
                if (message.listenerClientUrl != null && Object.hasOwnProperty.call(message, "listenerClientUrl"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.listenerClientUrl);
                if (message.peerToken != null && Object.hasOwnProperty.call(message, "peerToken"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.peerToken);
                if (message.vcserviceGrpcAddress != null && Object.hasOwnProperty.call(message, "vcserviceGrpcAddress"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.vcserviceGrpcAddress);
                if (message.vcserviceGrpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "vcserviceGrpcTimeoutSeconds"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.vcserviceGrpcTimeoutSeconds);
                if (message.vcserviceGrpcInsecure != null && Object.hasOwnProperty.call(message, "vcserviceGrpcInsecure"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.vcserviceGrpcInsecure);
                return writer;
            };

            /**
             * Encodes the specified ServerOptions message, length delimited. Does not implicitly {@link protos.opts.ServerOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions} message ServerOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServerOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ServerOptions} ServerOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ServerOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nodeId = reader.string();
                        break;
                    case 2:
                        message.clusterId = reader.string();
                        break;
                    case 3:
                        message.grpcListenAddress = reader.string();
                        break;
                    case 4:
                        message.authToken = reader.string();
                        break;
                    case 5:
                        message.initialCluster = reader.string();
                        break;
                    case 6:
                        message.advertisePeerUrl = reader.string();
                        break;
                    case 7:
                        message.advertiseClientUrl = reader.string();
                        break;
                    case 8:
                        message.listenerPeerUrl = reader.string();
                        break;
                    case 9:
                        message.listenerClientUrl = reader.string();
                        break;
                    case 10:
                        message.peerToken = reader.string();
                        break;
                    case 11:
                        message.vcserviceGrpcAddress = reader.string();
                        break;
                    case 12:
                        message.vcserviceGrpcTimeoutSeconds = reader.uint32();
                        break;
                    case 13:
                        message.vcserviceGrpcInsecure = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServerOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ServerOptions} ServerOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServerOptions message.
             * @function verify
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServerOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    if (!$util.isString(message.clusterId))
                        return "clusterId: string expected";
                if (message.grpcListenAddress != null && message.hasOwnProperty("grpcListenAddress"))
                    if (!$util.isString(message.grpcListenAddress))
                        return "grpcListenAddress: string expected";
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    if (!$util.isString(message.authToken))
                        return "authToken: string expected";
                if (message.initialCluster != null && message.hasOwnProperty("initialCluster"))
                    if (!$util.isString(message.initialCluster))
                        return "initialCluster: string expected";
                if (message.advertisePeerUrl != null && message.hasOwnProperty("advertisePeerUrl"))
                    if (!$util.isString(message.advertisePeerUrl))
                        return "advertisePeerUrl: string expected";
                if (message.advertiseClientUrl != null && message.hasOwnProperty("advertiseClientUrl"))
                    if (!$util.isString(message.advertiseClientUrl))
                        return "advertiseClientUrl: string expected";
                if (message.listenerPeerUrl != null && message.hasOwnProperty("listenerPeerUrl"))
                    if (!$util.isString(message.listenerPeerUrl))
                        return "listenerPeerUrl: string expected";
                if (message.listenerClientUrl != null && message.hasOwnProperty("listenerClientUrl"))
                    if (!$util.isString(message.listenerClientUrl))
                        return "listenerClientUrl: string expected";
                if (message.peerToken != null && message.hasOwnProperty("peerToken"))
                    if (!$util.isString(message.peerToken))
                        return "peerToken: string expected";
                if (message.vcserviceGrpcAddress != null && message.hasOwnProperty("vcserviceGrpcAddress"))
                    if (!$util.isString(message.vcserviceGrpcAddress))
                        return "vcserviceGrpcAddress: string expected";
                if (message.vcserviceGrpcTimeoutSeconds != null && message.hasOwnProperty("vcserviceGrpcTimeoutSeconds"))
                    if (!$util.isInteger(message.vcserviceGrpcTimeoutSeconds))
                        return "vcserviceGrpcTimeoutSeconds: integer expected";
                if (message.vcserviceGrpcInsecure != null && message.hasOwnProperty("vcserviceGrpcInsecure"))
                    if (typeof message.vcserviceGrpcInsecure !== "boolean")
                        return "vcserviceGrpcInsecure: boolean expected";
                return null;
            };

            /**
             * Creates a ServerOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ServerOptions} ServerOptions
             */
            ServerOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ServerOptions)
                    return object;
                var message = new $root.protos.opts.ServerOptions();
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.clusterId != null)
                    message.clusterId = String(object.clusterId);
                if (object.grpcListenAddress != null)
                    message.grpcListenAddress = String(object.grpcListenAddress);
                if (object.authToken != null)
                    message.authToken = String(object.authToken);
                if (object.initialCluster != null)
                    message.initialCluster = String(object.initialCluster);
                if (object.advertisePeerUrl != null)
                    message.advertisePeerUrl = String(object.advertisePeerUrl);
                if (object.advertiseClientUrl != null)
                    message.advertiseClientUrl = String(object.advertiseClientUrl);
                if (object.listenerPeerUrl != null)
                    message.listenerPeerUrl = String(object.listenerPeerUrl);
                if (object.listenerClientUrl != null)
                    message.listenerClientUrl = String(object.listenerClientUrl);
                if (object.peerToken != null)
                    message.peerToken = String(object.peerToken);
                if (object.vcserviceGrpcAddress != null)
                    message.vcserviceGrpcAddress = String(object.vcserviceGrpcAddress);
                if (object.vcserviceGrpcTimeoutSeconds != null)
                    message.vcserviceGrpcTimeoutSeconds = object.vcserviceGrpcTimeoutSeconds >>> 0;
                if (object.vcserviceGrpcInsecure != null)
                    message.vcserviceGrpcInsecure = Boolean(object.vcserviceGrpcInsecure);
                return message;
            };

            /**
             * Creates a plain object from a ServerOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.ServerOptions} message ServerOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServerOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.nodeId = "";
                    object.clusterId = "";
                    object.grpcListenAddress = "";
                    object.authToken = "";
                    object.initialCluster = "";
                    object.advertisePeerUrl = "";
                    object.advertiseClientUrl = "";
                    object.listenerPeerUrl = "";
                    object.listenerClientUrl = "";
                    object.peerToken = "";
                    object.vcserviceGrpcAddress = "";
                    object.vcserviceGrpcTimeoutSeconds = 0;
                    object.vcserviceGrpcInsecure = false;
                }
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    object.clusterId = message.clusterId;
                if (message.grpcListenAddress != null && message.hasOwnProperty("grpcListenAddress"))
                    object.grpcListenAddress = message.grpcListenAddress;
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    object.authToken = message.authToken;
                if (message.initialCluster != null && message.hasOwnProperty("initialCluster"))
                    object.initialCluster = message.initialCluster;
                if (message.advertisePeerUrl != null && message.hasOwnProperty("advertisePeerUrl"))
                    object.advertisePeerUrl = message.advertisePeerUrl;
                if (message.advertiseClientUrl != null && message.hasOwnProperty("advertiseClientUrl"))
                    object.advertiseClientUrl = message.advertiseClientUrl;
                if (message.listenerPeerUrl != null && message.hasOwnProperty("listenerPeerUrl"))
                    object.listenerPeerUrl = message.listenerPeerUrl;
                if (message.listenerClientUrl != null && message.hasOwnProperty("listenerClientUrl"))
                    object.listenerClientUrl = message.listenerClientUrl;
                if (message.peerToken != null && message.hasOwnProperty("peerToken"))
                    object.peerToken = message.peerToken;
                if (message.vcserviceGrpcAddress != null && message.hasOwnProperty("vcserviceGrpcAddress"))
                    object.vcserviceGrpcAddress = message.vcserviceGrpcAddress;
                if (message.vcserviceGrpcTimeoutSeconds != null && message.hasOwnProperty("vcserviceGrpcTimeoutSeconds"))
                    object.vcserviceGrpcTimeoutSeconds = message.vcserviceGrpcTimeoutSeconds;
                if (message.vcserviceGrpcInsecure != null && message.hasOwnProperty("vcserviceGrpcInsecure"))
                    object.vcserviceGrpcInsecure = message.vcserviceGrpcInsecure;
                return object;
            };

            /**
             * Converts this ServerOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ServerOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServerOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServerOptions;
        })();

        opts.MonitorOptions = (function() {

            /**
             * Properties of a MonitorOptions.
             * @memberof protos.opts
             * @interface IMonitorOptions
             * @property {string|null} [_id] MonitorOptions _id
             * @property {string|null} [_createdBy] MonitorOptions _createdBy
             * @property {number|Long|null} [_createdAtTsUtc] MonitorOptions _createdAtTsUtc
             * @property {string|null} [notes] MonitorOptions notes
             * @property {protos.opts.IMonitorSchemaValidationConfig|null} [schemaValidation] MonitorOptions schemaValidation
             * @property {protos.opts.IMonitorServiceSchemaVersionConfig|null} [serviceSchemaVersion] MonitorOptions serviceSchemaVersion
             * @property {protos.opts.IMonitorReadHasDataConfig|null} [readHasData] MonitorOptions readHasData
             */

            /**
             * Constructs a new MonitorOptions.
             * @memberof protos.opts
             * @classdesc Represents a MonitorOptions.
             * @implements IMonitorOptions
             * @constructor
             * @param {protos.opts.IMonitorOptions=} [properties] Properties to set
             */
            function MonitorOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MonitorOptions _id.
             * @member {string} _id
             * @memberof protos.opts.MonitorOptions
             * @instance
             */
            MonitorOptions.prototype._id = "";

            /**
             * MonitorOptions _createdBy.
             * @member {string} _createdBy
             * @memberof protos.opts.MonitorOptions
             * @instance
             */
            MonitorOptions.prototype._createdBy = "";

            /**
             * MonitorOptions _createdAtTsUtc.
             * @member {number|Long} _createdAtTsUtc
             * @memberof protos.opts.MonitorOptions
             * @instance
             */
            MonitorOptions.prototype._createdAtTsUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MonitorOptions notes.
             * @member {string} notes
             * @memberof protos.opts.MonitorOptions
             * @instance
             */
            MonitorOptions.prototype.notes = "";

            /**
             * MonitorOptions schemaValidation.
             * @member {protos.opts.IMonitorSchemaValidationConfig|null|undefined} schemaValidation
             * @memberof protos.opts.MonitorOptions
             * @instance
             */
            MonitorOptions.prototype.schemaValidation = null;

            /**
             * MonitorOptions serviceSchemaVersion.
             * @member {protos.opts.IMonitorServiceSchemaVersionConfig|null|undefined} serviceSchemaVersion
             * @memberof protos.opts.MonitorOptions
             * @instance
             */
            MonitorOptions.prototype.serviceSchemaVersion = null;

            /**
             * MonitorOptions readHasData.
             * @member {protos.opts.IMonitorReadHasDataConfig|null|undefined} readHasData
             * @memberof protos.opts.MonitorOptions
             * @instance
             */
            MonitorOptions.prototype.readHasData = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * MonitorOptions config.
             * @member {"schemaValidation"|"serviceSchemaVersion"|"readHasData"|undefined} config
             * @memberof protos.opts.MonitorOptions
             * @instance
             */
            Object.defineProperty(MonitorOptions.prototype, "config", {
                get: $util.oneOfGetter($oneOfFields = ["schemaValidation", "serviceSchemaVersion", "readHasData"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MonitorOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.MonitorOptions
             * @static
             * @param {protos.opts.IMonitorOptions=} [properties] Properties to set
             * @returns {protos.opts.MonitorOptions} MonitorOptions instance
             */
            MonitorOptions.create = function create(properties) {
                return new MonitorOptions(properties);
            };

            /**
             * Encodes the specified MonitorOptions message. Does not implicitly {@link protos.opts.MonitorOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.MonitorOptions
             * @static
             * @param {protos.opts.IMonitorOptions} message MonitorOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MonitorOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message._id);
                if (message._createdBy != null && Object.hasOwnProperty.call(message, "_createdBy"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message._createdBy);
                if (message._createdAtTsUtc != null && Object.hasOwnProperty.call(message, "_createdAtTsUtc"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message._createdAtTsUtc);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.notes);
                if (message.schemaValidation != null && Object.hasOwnProperty.call(message, "schemaValidation"))
                    $root.protos.opts.MonitorSchemaValidationConfig.encode(message.schemaValidation, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.serviceSchemaVersion != null && Object.hasOwnProperty.call(message, "serviceSchemaVersion"))
                    $root.protos.opts.MonitorServiceSchemaVersionConfig.encode(message.serviceSchemaVersion, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.readHasData != null && Object.hasOwnProperty.call(message, "readHasData"))
                    $root.protos.opts.MonitorReadHasDataConfig.encode(message.readHasData, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MonitorOptions message, length delimited. Does not implicitly {@link protos.opts.MonitorOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.MonitorOptions
             * @static
             * @param {protos.opts.IMonitorOptions} message MonitorOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MonitorOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MonitorOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.MonitorOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.MonitorOptions} MonitorOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MonitorOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.MonitorOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._id = reader.string();
                        break;
                    case 2:
                        message._createdBy = reader.string();
                        break;
                    case 3:
                        message._createdAtTsUtc = reader.int64();
                        break;
                    case 4:
                        message.notes = reader.string();
                        break;
                    case 100:
                        message.schemaValidation = $root.protos.opts.MonitorSchemaValidationConfig.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.serviceSchemaVersion = $root.protos.opts.MonitorServiceSchemaVersionConfig.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.readHasData = $root.protos.opts.MonitorReadHasDataConfig.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MonitorOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.MonitorOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.MonitorOptions} MonitorOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MonitorOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MonitorOptions message.
             * @function verify
             * @memberof protos.opts.MonitorOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MonitorOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                if (message._createdBy != null && message.hasOwnProperty("_createdBy"))
                    if (!$util.isString(message._createdBy))
                        return "_createdBy: string expected";
                if (message._createdAtTsUtc != null && message.hasOwnProperty("_createdAtTsUtc"))
                    if (!$util.isInteger(message._createdAtTsUtc) && !(message._createdAtTsUtc && $util.isInteger(message._createdAtTsUtc.low) && $util.isInteger(message._createdAtTsUtc.high)))
                        return "_createdAtTsUtc: integer|Long expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.schemaValidation != null && message.hasOwnProperty("schemaValidation")) {
                    properties.config = 1;
                    {
                        var error = $root.protos.opts.MonitorSchemaValidationConfig.verify(message.schemaValidation);
                        if (error)
                            return "schemaValidation." + error;
                    }
                }
                if (message.serviceSchemaVersion != null && message.hasOwnProperty("serviceSchemaVersion")) {
                    if (properties.config === 1)
                        return "config: multiple values";
                    properties.config = 1;
                    {
                        var error = $root.protos.opts.MonitorServiceSchemaVersionConfig.verify(message.serviceSchemaVersion);
                        if (error)
                            return "serviceSchemaVersion." + error;
                    }
                }
                if (message.readHasData != null && message.hasOwnProperty("readHasData")) {
                    if (properties.config === 1)
                        return "config: multiple values";
                    properties.config = 1;
                    {
                        var error = $root.protos.opts.MonitorReadHasDataConfig.verify(message.readHasData);
                        if (error)
                            return "readHasData." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MonitorOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.MonitorOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.MonitorOptions} MonitorOptions
             */
            MonitorOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.MonitorOptions)
                    return object;
                var message = new $root.protos.opts.MonitorOptions();
                if (object._id != null)
                    message._id = String(object._id);
                if (object._createdBy != null)
                    message._createdBy = String(object._createdBy);
                if (object._createdAtTsUtc != null)
                    if ($util.Long)
                        (message._createdAtTsUtc = $util.Long.fromValue(object._createdAtTsUtc)).unsigned = false;
                    else if (typeof object._createdAtTsUtc === "string")
                        message._createdAtTsUtc = parseInt(object._createdAtTsUtc, 10);
                    else if (typeof object._createdAtTsUtc === "number")
                        message._createdAtTsUtc = object._createdAtTsUtc;
                    else if (typeof object._createdAtTsUtc === "object")
                        message._createdAtTsUtc = new $util.LongBits(object._createdAtTsUtc.low >>> 0, object._createdAtTsUtc.high >>> 0).toNumber();
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.schemaValidation != null) {
                    if (typeof object.schemaValidation !== "object")
                        throw TypeError(".protos.opts.MonitorOptions.schemaValidation: object expected");
                    message.schemaValidation = $root.protos.opts.MonitorSchemaValidationConfig.fromObject(object.schemaValidation);
                }
                if (object.serviceSchemaVersion != null) {
                    if (typeof object.serviceSchemaVersion !== "object")
                        throw TypeError(".protos.opts.MonitorOptions.serviceSchemaVersion: object expected");
                    message.serviceSchemaVersion = $root.protos.opts.MonitorServiceSchemaVersionConfig.fromObject(object.serviceSchemaVersion);
                }
                if (object.readHasData != null) {
                    if (typeof object.readHasData !== "object")
                        throw TypeError(".protos.opts.MonitorOptions.readHasData: object expected");
                    message.readHasData = $root.protos.opts.MonitorReadHasDataConfig.fromObject(object.readHasData);
                }
                return message;
            };

            /**
             * Creates a plain object from a MonitorOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.MonitorOptions
             * @static
             * @param {protos.opts.MonitorOptions} message MonitorOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MonitorOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._id = "";
                    object._createdBy = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object._createdAtTsUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object._createdAtTsUtc = options.longs === String ? "0" : 0;
                    object.notes = "";
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                if (message._createdBy != null && message.hasOwnProperty("_createdBy"))
                    object._createdBy = message._createdBy;
                if (message._createdAtTsUtc != null && message.hasOwnProperty("_createdAtTsUtc"))
                    if (typeof message._createdAtTsUtc === "number")
                        object._createdAtTsUtc = options.longs === String ? String(message._createdAtTsUtc) : message._createdAtTsUtc;
                    else
                        object._createdAtTsUtc = options.longs === String ? $util.Long.prototype.toString.call(message._createdAtTsUtc) : options.longs === Number ? new $util.LongBits(message._createdAtTsUtc.low >>> 0, message._createdAtTsUtc.high >>> 0).toNumber() : message._createdAtTsUtc;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.schemaValidation != null && message.hasOwnProperty("schemaValidation")) {
                    object.schemaValidation = $root.protos.opts.MonitorSchemaValidationConfig.toObject(message.schemaValidation, options);
                    if (options.oneofs)
                        object.config = "schemaValidation";
                }
                if (message.serviceSchemaVersion != null && message.hasOwnProperty("serviceSchemaVersion")) {
                    object.serviceSchemaVersion = $root.protos.opts.MonitorServiceSchemaVersionConfig.toObject(message.serviceSchemaVersion, options);
                    if (options.oneofs)
                        object.config = "serviceSchemaVersion";
                }
                if (message.readHasData != null && message.hasOwnProperty("readHasData")) {
                    object.readHasData = $root.protos.opts.MonitorReadHasDataConfig.toObject(message.readHasData, options);
                    if (options.oneofs)
                        object.config = "readHasData";
                }
                return object;
            };

            /**
             * Converts this MonitorOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.MonitorOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MonitorOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MonitorOptions;
        })();

        opts.MonitorSchemaValidationConfig = (function() {

            /**
             * Properties of a MonitorSchemaValidationConfig.
             * @memberof protos.opts
             * @interface IMonitorSchemaValidationConfig
             * @property {Array.<string>|null} [schemaId] MonitorSchemaValidationConfig schemaId
             * @property {Array.<protos.common.IValidation>|null} [validations] MonitorSchemaValidationConfig validations
             */

            /**
             * Constructs a new MonitorSchemaValidationConfig.
             * @memberof protos.opts
             * @classdesc Represents a MonitorSchemaValidationConfig.
             * @implements IMonitorSchemaValidationConfig
             * @constructor
             * @param {protos.opts.IMonitorSchemaValidationConfig=} [properties] Properties to set
             */
            function MonitorSchemaValidationConfig(properties) {
                this.schemaId = [];
                this.validations = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MonitorSchemaValidationConfig schemaId.
             * @member {Array.<string>} schemaId
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @instance
             */
            MonitorSchemaValidationConfig.prototype.schemaId = $util.emptyArray;

            /**
             * MonitorSchemaValidationConfig validations.
             * @member {Array.<protos.common.IValidation>} validations
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @instance
             */
            MonitorSchemaValidationConfig.prototype.validations = $util.emptyArray;

            /**
             * Creates a new MonitorSchemaValidationConfig instance using the specified properties.
             * @function create
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @static
             * @param {protos.opts.IMonitorSchemaValidationConfig=} [properties] Properties to set
             * @returns {protos.opts.MonitorSchemaValidationConfig} MonitorSchemaValidationConfig instance
             */
            MonitorSchemaValidationConfig.create = function create(properties) {
                return new MonitorSchemaValidationConfig(properties);
            };

            /**
             * Encodes the specified MonitorSchemaValidationConfig message. Does not implicitly {@link protos.opts.MonitorSchemaValidationConfig.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @static
             * @param {protos.opts.IMonitorSchemaValidationConfig} message MonitorSchemaValidationConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MonitorSchemaValidationConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schemaId != null && message.schemaId.length)
                    for (var i = 0; i < message.schemaId.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.schemaId[i]);
                if (message.validations != null && message.validations.length)
                    for (var i = 0; i < message.validations.length; ++i)
                        $root.protos.common.Validation.encode(message.validations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MonitorSchemaValidationConfig message, length delimited. Does not implicitly {@link protos.opts.MonitorSchemaValidationConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @static
             * @param {protos.opts.IMonitorSchemaValidationConfig} message MonitorSchemaValidationConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MonitorSchemaValidationConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MonitorSchemaValidationConfig message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.MonitorSchemaValidationConfig} MonitorSchemaValidationConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MonitorSchemaValidationConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.MonitorSchemaValidationConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.schemaId && message.schemaId.length))
                            message.schemaId = [];
                        message.schemaId.push(reader.string());
                        break;
                    case 2:
                        if (!(message.validations && message.validations.length))
                            message.validations = [];
                        message.validations.push($root.protos.common.Validation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MonitorSchemaValidationConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.MonitorSchemaValidationConfig} MonitorSchemaValidationConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MonitorSchemaValidationConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MonitorSchemaValidationConfig message.
             * @function verify
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MonitorSchemaValidationConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId")) {
                    if (!Array.isArray(message.schemaId))
                        return "schemaId: array expected";
                    for (var i = 0; i < message.schemaId.length; ++i)
                        if (!$util.isString(message.schemaId[i]))
                            return "schemaId: string[] expected";
                }
                if (message.validations != null && message.hasOwnProperty("validations")) {
                    if (!Array.isArray(message.validations))
                        return "validations: array expected";
                    for (var i = 0; i < message.validations.length; ++i) {
                        var error = $root.protos.common.Validation.verify(message.validations[i]);
                        if (error)
                            return "validations." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MonitorSchemaValidationConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.MonitorSchemaValidationConfig} MonitorSchemaValidationConfig
             */
            MonitorSchemaValidationConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.MonitorSchemaValidationConfig)
                    return object;
                var message = new $root.protos.opts.MonitorSchemaValidationConfig();
                if (object.schemaId) {
                    if (!Array.isArray(object.schemaId))
                        throw TypeError(".protos.opts.MonitorSchemaValidationConfig.schemaId: array expected");
                    message.schemaId = [];
                    for (var i = 0; i < object.schemaId.length; ++i)
                        message.schemaId[i] = String(object.schemaId[i]);
                }
                if (object.validations) {
                    if (!Array.isArray(object.validations))
                        throw TypeError(".protos.opts.MonitorSchemaValidationConfig.validations: array expected");
                    message.validations = [];
                    for (var i = 0; i < object.validations.length; ++i) {
                        if (typeof object.validations[i] !== "object")
                            throw TypeError(".protos.opts.MonitorSchemaValidationConfig.validations: object expected");
                        message.validations[i] = $root.protos.common.Validation.fromObject(object.validations[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MonitorSchemaValidationConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @static
             * @param {protos.opts.MonitorSchemaValidationConfig} message MonitorSchemaValidationConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MonitorSchemaValidationConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.schemaId = [];
                    object.validations = [];
                }
                if (message.schemaId && message.schemaId.length) {
                    object.schemaId = [];
                    for (var j = 0; j < message.schemaId.length; ++j)
                        object.schemaId[j] = message.schemaId[j];
                }
                if (message.validations && message.validations.length) {
                    object.validations = [];
                    for (var j = 0; j < message.validations.length; ++j)
                        object.validations[j] = $root.protos.common.Validation.toObject(message.validations[j], options);
                }
                return object;
            };

            /**
             * Converts this MonitorSchemaValidationConfig to JSON.
             * @function toJSON
             * @memberof protos.opts.MonitorSchemaValidationConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MonitorSchemaValidationConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MonitorSchemaValidationConfig;
        })();

        /**
         * MonitorServiceSchemaVersionType enum.
         * @name protos.opts.MonitorServiceSchemaVersionType
         * @enum {number}
         * @property {number} SERVICE_SCHEMA_VERSION_CONDITION_TYPE_LATEST=0 SERVICE_SCHEMA_VERSION_CONDITION_TYPE_LATEST value
         * @property {number} SERVICE_SCHEMA_VERSION_CONDITION_TYPE_EXACT=1 SERVICE_SCHEMA_VERSION_CONDITION_TYPE_EXACT value
         */
        opts.MonitorServiceSchemaVersionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SERVICE_SCHEMA_VERSION_CONDITION_TYPE_LATEST"] = 0;
            values[valuesById[1] = "SERVICE_SCHEMA_VERSION_CONDITION_TYPE_EXACT"] = 1;
            return values;
        })();

        opts.MonitorServiceSchemaVersionConfig = (function() {

            /**
             * Properties of a MonitorServiceSchemaVersionConfig.
             * @memberof protos.opts
             * @interface IMonitorServiceSchemaVersionConfig
             * @property {Array.<string>|null} [serviceIds] MonitorServiceSchemaVersionConfig serviceIds
             * @property {protos.opts.MonitorServiceSchemaVersionType|null} [type] MonitorServiceSchemaVersionConfig type
             * @property {Object.<string,string>|null} [args] MonitorServiceSchemaVersionConfig args
             */

            /**
             * Constructs a new MonitorServiceSchemaVersionConfig.
             * @memberof protos.opts
             * @classdesc Represents a MonitorServiceSchemaVersionConfig.
             * @implements IMonitorServiceSchemaVersionConfig
             * @constructor
             * @param {protos.opts.IMonitorServiceSchemaVersionConfig=} [properties] Properties to set
             */
            function MonitorServiceSchemaVersionConfig(properties) {
                this.serviceIds = [];
                this.args = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MonitorServiceSchemaVersionConfig serviceIds.
             * @member {Array.<string>} serviceIds
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @instance
             */
            MonitorServiceSchemaVersionConfig.prototype.serviceIds = $util.emptyArray;

            /**
             * MonitorServiceSchemaVersionConfig type.
             * @member {protos.opts.MonitorServiceSchemaVersionType} type
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @instance
             */
            MonitorServiceSchemaVersionConfig.prototype.type = 0;

            /**
             * MonitorServiceSchemaVersionConfig args.
             * @member {Object.<string,string>} args
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @instance
             */
            MonitorServiceSchemaVersionConfig.prototype.args = $util.emptyObject;

            /**
             * Creates a new MonitorServiceSchemaVersionConfig instance using the specified properties.
             * @function create
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @static
             * @param {protos.opts.IMonitorServiceSchemaVersionConfig=} [properties] Properties to set
             * @returns {protos.opts.MonitorServiceSchemaVersionConfig} MonitorServiceSchemaVersionConfig instance
             */
            MonitorServiceSchemaVersionConfig.create = function create(properties) {
                return new MonitorServiceSchemaVersionConfig(properties);
            };

            /**
             * Encodes the specified MonitorServiceSchemaVersionConfig message. Does not implicitly {@link protos.opts.MonitorServiceSchemaVersionConfig.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @static
             * @param {protos.opts.IMonitorServiceSchemaVersionConfig} message MonitorServiceSchemaVersionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MonitorServiceSchemaVersionConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serviceIds != null && message.serviceIds.length)
                    for (var i = 0; i < message.serviceIds.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.serviceIds[i]);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    for (var keys = Object.keys(message.args), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.args[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MonitorServiceSchemaVersionConfig message, length delimited. Does not implicitly {@link protos.opts.MonitorServiceSchemaVersionConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @static
             * @param {protos.opts.IMonitorServiceSchemaVersionConfig} message MonitorServiceSchemaVersionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MonitorServiceSchemaVersionConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MonitorServiceSchemaVersionConfig message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.MonitorServiceSchemaVersionConfig} MonitorServiceSchemaVersionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MonitorServiceSchemaVersionConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.MonitorServiceSchemaVersionConfig(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.serviceIds && message.serviceIds.length))
                            message.serviceIds = [];
                        message.serviceIds.push(reader.string());
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        if (message.args === $util.emptyObject)
                            message.args = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.args[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MonitorServiceSchemaVersionConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.MonitorServiceSchemaVersionConfig} MonitorServiceSchemaVersionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MonitorServiceSchemaVersionConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MonitorServiceSchemaVersionConfig message.
             * @function verify
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MonitorServiceSchemaVersionConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serviceIds != null && message.hasOwnProperty("serviceIds")) {
                    if (!Array.isArray(message.serviceIds))
                        return "serviceIds: array expected";
                    for (var i = 0; i < message.serviceIds.length; ++i)
                        if (!$util.isString(message.serviceIds[i]))
                            return "serviceIds: string[] expected";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.args != null && message.hasOwnProperty("args")) {
                    if (!$util.isObject(message.args))
                        return "args: object expected";
                    var key = Object.keys(message.args);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.args[key[i]]))
                            return "args: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a MonitorServiceSchemaVersionConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.MonitorServiceSchemaVersionConfig} MonitorServiceSchemaVersionConfig
             */
            MonitorServiceSchemaVersionConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.MonitorServiceSchemaVersionConfig)
                    return object;
                var message = new $root.protos.opts.MonitorServiceSchemaVersionConfig();
                if (object.serviceIds) {
                    if (!Array.isArray(object.serviceIds))
                        throw TypeError(".protos.opts.MonitorServiceSchemaVersionConfig.serviceIds: array expected");
                    message.serviceIds = [];
                    for (var i = 0; i < object.serviceIds.length; ++i)
                        message.serviceIds[i] = String(object.serviceIds[i]);
                }
                switch (object.type) {
                case "SERVICE_SCHEMA_VERSION_CONDITION_TYPE_LATEST":
                case 0:
                    message.type = 0;
                    break;
                case "SERVICE_SCHEMA_VERSION_CONDITION_TYPE_EXACT":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.args) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.MonitorServiceSchemaVersionConfig.args: object expected");
                    message.args = {};
                    for (var keys = Object.keys(object.args), i = 0; i < keys.length; ++i)
                        message.args[keys[i]] = String(object.args[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MonitorServiceSchemaVersionConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @static
             * @param {protos.opts.MonitorServiceSchemaVersionConfig} message MonitorServiceSchemaVersionConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MonitorServiceSchemaVersionConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.serviceIds = [];
                if (options.objects || options.defaults)
                    object.args = {};
                if (options.defaults)
                    object.type = options.enums === String ? "SERVICE_SCHEMA_VERSION_CONDITION_TYPE_LATEST" : 0;
                if (message.serviceIds && message.serviceIds.length) {
                    object.serviceIds = [];
                    for (var j = 0; j < message.serviceIds.length; ++j)
                        object.serviceIds[j] = message.serviceIds[j];
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.opts.MonitorServiceSchemaVersionType[message.type] : message.type;
                var keys2;
                if (message.args && (keys2 = Object.keys(message.args)).length) {
                    object.args = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.args[keys2[j]] = message.args[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this MonitorServiceSchemaVersionConfig to JSON.
             * @function toJSON
             * @memberof protos.opts.MonitorServiceSchemaVersionConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MonitorServiceSchemaVersionConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MonitorServiceSchemaVersionConfig;
        })();

        /**
         * ReadOperator enum.
         * @name protos.opts.ReadOperator
         * @enum {number}
         * @property {number} READ_OPERATOR_UNSET=0 READ_OPERATOR_UNSET value
         * @property {number} READ_OPERATOR_EQ=1 READ_OPERATOR_EQ value
         * @property {number} READ_OPERATOR_LT=2 READ_OPERATOR_LT value
         * @property {number} READ_OPERATOR_GT=3 READ_OPERATOR_GT value
         * @property {number} READ_OPERATOR_LTE=4 READ_OPERATOR_LTE value
         * @property {number} READ_OPERATOR_GTE=5 READ_OPERATOR_GTE value
         */
        opts.ReadOperator = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "READ_OPERATOR_UNSET"] = 0;
            values[valuesById[1] = "READ_OPERATOR_EQ"] = 1;
            values[valuesById[2] = "READ_OPERATOR_LT"] = 2;
            values[valuesById[3] = "READ_OPERATOR_GT"] = 3;
            values[valuesById[4] = "READ_OPERATOR_LTE"] = 4;
            values[valuesById[5] = "READ_OPERATOR_GTE"] = 5;
            return values;
        })();

        opts.MonitorReadHasDataConfig = (function() {

            /**
             * Properties of a MonitorReadHasDataConfig.
             * @memberof protos.opts
             * @interface IMonitorReadHasDataConfig
             * @property {Array.<string>|null} [readIds] MonitorReadHasDataConfig readIds
             * @property {protos.opts.ReadOperator|null} [operator] MonitorReadHasDataConfig operator
             * @property {number|null} [value] MonitorReadHasDataConfig value
             * @property {number|null} [intervalSeconds] MonitorReadHasDataConfig intervalSeconds
             */

            /**
             * Constructs a new MonitorReadHasDataConfig.
             * @memberof protos.opts
             * @classdesc Represents a MonitorReadHasDataConfig.
             * @implements IMonitorReadHasDataConfig
             * @constructor
             * @param {protos.opts.IMonitorReadHasDataConfig=} [properties] Properties to set
             */
            function MonitorReadHasDataConfig(properties) {
                this.readIds = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MonitorReadHasDataConfig readIds.
             * @member {Array.<string>} readIds
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @instance
             */
            MonitorReadHasDataConfig.prototype.readIds = $util.emptyArray;

            /**
             * MonitorReadHasDataConfig operator.
             * @member {protos.opts.ReadOperator} operator
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @instance
             */
            MonitorReadHasDataConfig.prototype.operator = 0;

            /**
             * MonitorReadHasDataConfig value.
             * @member {number} value
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @instance
             */
            MonitorReadHasDataConfig.prototype.value = 0;

            /**
             * MonitorReadHasDataConfig intervalSeconds.
             * @member {number} intervalSeconds
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @instance
             */
            MonitorReadHasDataConfig.prototype.intervalSeconds = 0;

            /**
             * Creates a new MonitorReadHasDataConfig instance using the specified properties.
             * @function create
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @static
             * @param {protos.opts.IMonitorReadHasDataConfig=} [properties] Properties to set
             * @returns {protos.opts.MonitorReadHasDataConfig} MonitorReadHasDataConfig instance
             */
            MonitorReadHasDataConfig.create = function create(properties) {
                return new MonitorReadHasDataConfig(properties);
            };

            /**
             * Encodes the specified MonitorReadHasDataConfig message. Does not implicitly {@link protos.opts.MonitorReadHasDataConfig.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @static
             * @param {protos.opts.IMonitorReadHasDataConfig} message MonitorReadHasDataConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MonitorReadHasDataConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.readIds != null && message.readIds.length)
                    for (var i = 0; i < message.readIds.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.readIds[i]);
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.operator);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.value);
                if (message.intervalSeconds != null && Object.hasOwnProperty.call(message, "intervalSeconds"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.intervalSeconds);
                return writer;
            };

            /**
             * Encodes the specified MonitorReadHasDataConfig message, length delimited. Does not implicitly {@link protos.opts.MonitorReadHasDataConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @static
             * @param {protos.opts.IMonitorReadHasDataConfig} message MonitorReadHasDataConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MonitorReadHasDataConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MonitorReadHasDataConfig message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.MonitorReadHasDataConfig} MonitorReadHasDataConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MonitorReadHasDataConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.MonitorReadHasDataConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.readIds && message.readIds.length))
                            message.readIds = [];
                        message.readIds.push(reader.string());
                        break;
                    case 2:
                        message.operator = reader.int32();
                        break;
                    case 3:
                        message.value = reader.int32();
                        break;
                    case 4:
                        message.intervalSeconds = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MonitorReadHasDataConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.MonitorReadHasDataConfig} MonitorReadHasDataConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MonitorReadHasDataConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MonitorReadHasDataConfig message.
             * @function verify
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MonitorReadHasDataConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.readIds != null && message.hasOwnProperty("readIds")) {
                    if (!Array.isArray(message.readIds))
                        return "readIds: array expected";
                    for (var i = 0; i < message.readIds.length; ++i)
                        if (!$util.isString(message.readIds[i]))
                            return "readIds: string[] expected";
                }
                if (message.operator != null && message.hasOwnProperty("operator"))
                    switch (message.operator) {
                    default:
                        return "operator: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                if (message.intervalSeconds != null && message.hasOwnProperty("intervalSeconds"))
                    if (!$util.isInteger(message.intervalSeconds))
                        return "intervalSeconds: integer expected";
                return null;
            };

            /**
             * Creates a MonitorReadHasDataConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.MonitorReadHasDataConfig} MonitorReadHasDataConfig
             */
            MonitorReadHasDataConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.MonitorReadHasDataConfig)
                    return object;
                var message = new $root.protos.opts.MonitorReadHasDataConfig();
                if (object.readIds) {
                    if (!Array.isArray(object.readIds))
                        throw TypeError(".protos.opts.MonitorReadHasDataConfig.readIds: array expected");
                    message.readIds = [];
                    for (var i = 0; i < object.readIds.length; ++i)
                        message.readIds[i] = String(object.readIds[i]);
                }
                switch (object.operator) {
                case "READ_OPERATOR_UNSET":
                case 0:
                    message.operator = 0;
                    break;
                case "READ_OPERATOR_EQ":
                case 1:
                    message.operator = 1;
                    break;
                case "READ_OPERATOR_LT":
                case 2:
                    message.operator = 2;
                    break;
                case "READ_OPERATOR_GT":
                case 3:
                    message.operator = 3;
                    break;
                case "READ_OPERATOR_LTE":
                case 4:
                    message.operator = 4;
                    break;
                case "READ_OPERATOR_GTE":
                case 5:
                    message.operator = 5;
                    break;
                }
                if (object.value != null)
                    message.value = object.value | 0;
                if (object.intervalSeconds != null)
                    message.intervalSeconds = object.intervalSeconds | 0;
                return message;
            };

            /**
             * Creates a plain object from a MonitorReadHasDataConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @static
             * @param {protos.opts.MonitorReadHasDataConfig} message MonitorReadHasDataConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MonitorReadHasDataConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.readIds = [];
                if (options.defaults) {
                    object.operator = options.enums === String ? "READ_OPERATOR_UNSET" : 0;
                    object.value = 0;
                    object.intervalSeconds = 0;
                }
                if (message.readIds && message.readIds.length) {
                    object.readIds = [];
                    for (var j = 0; j < message.readIds.length; ++j)
                        object.readIds[j] = message.readIds[j];
                }
                if (message.operator != null && message.hasOwnProperty("operator"))
                    object.operator = options.enums === String ? $root.protos.opts.ReadOperator[message.operator] : message.operator;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.intervalSeconds != null && message.hasOwnProperty("intervalSeconds"))
                    object.intervalSeconds = message.intervalSeconds;
                return object;
            };

            /**
             * Converts this MonitorReadHasDataConfig to JSON.
             * @function toJSON
             * @memberof protos.opts.MonitorReadHasDataConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MonitorReadHasDataConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MonitorReadHasDataConfig;
        })();

        /**
         * BatchOutputType enum.
         * @name protos.opts.BatchOutputType
         * @enum {number}
         * @property {number} TABLE=0 TABLE value
         * @property {number} JSON=1 JSON value
         */
        opts.BatchOutputType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TABLE"] = 0;
            values[valuesById[1] = "JSON"] = 1;
            return values;
        })();

        /**
         * BatchReplayType enum.
         * @name protos.opts.BatchReplayType
         * @enum {number}
         * @property {number} SINGLE=0 SINGLE value
         * @property {number} CONTINUOUS=1 CONTINUOUS value
         */
        opts.BatchReplayType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SINGLE"] = 0;
            values[valuesById[1] = "CONTINUOUS"] = 1;
            return values;
        })();

        opts.BatchOptions = (function() {

            /**
             * Properties of a BatchOptions.
             * @memberof protos.opts
             * @interface IBatchOptions
             * @property {protos.opts.BatchOutputType|null} [outputType] BatchOptions outputType
             * @property {string|null} [apiUrl] BatchOptions apiUrl
             * @property {protos.opts.IBatchLoginOptions|null} [login] BatchOptions login
             * @property {protos.opts.IBatchLogoutOptions|null} [logout] BatchOptions logout
             * @property {protos.opts.IBatchListOptions|null} [list] BatchOptions list
             * @property {protos.opts.IBatchCreateOptions|null} [create] BatchOptions create
             * @property {protos.opts.IBatchSearchOptions|null} [search] BatchOptions search
             * @property {protos.opts.IBatchArchiveOptions|null} [archive] BatchOptions archive
             */

            /**
             * Constructs a new BatchOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchOptions.
             * @implements IBatchOptions
             * @constructor
             * @param {protos.opts.IBatchOptions=} [properties] Properties to set
             */
            function BatchOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchOptions outputType.
             * @member {protos.opts.BatchOutputType} outputType
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.outputType = 0;

            /**
             * BatchOptions apiUrl.
             * @member {string} apiUrl
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.apiUrl = "";

            /**
             * BatchOptions login.
             * @member {protos.opts.IBatchLoginOptions|null|undefined} login
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.login = null;

            /**
             * BatchOptions logout.
             * @member {protos.opts.IBatchLogoutOptions|null|undefined} logout
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.logout = null;

            /**
             * BatchOptions list.
             * @member {protos.opts.IBatchListOptions|null|undefined} list
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.list = null;

            /**
             * BatchOptions create.
             * @member {protos.opts.IBatchCreateOptions|null|undefined} create
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.create = null;

            /**
             * BatchOptions search.
             * @member {protos.opts.IBatchSearchOptions|null|undefined} search
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.search = null;

            /**
             * BatchOptions archive.
             * @member {protos.opts.IBatchArchiveOptions|null|undefined} archive
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.archive = null;

            /**
             * Creates a new BatchOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.IBatchOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchOptions} BatchOptions instance
             */
            BatchOptions.create = function create(properties) {
                return new BatchOptions(properties);
            };

            /**
             * Encodes the specified BatchOptions message. Does not implicitly {@link protos.opts.BatchOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.IBatchOptions} message BatchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.outputType);
                if (message.apiUrl != null && Object.hasOwnProperty.call(message, "apiUrl"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.apiUrl);
                if (message.login != null && Object.hasOwnProperty.call(message, "login"))
                    $root.protos.opts.BatchLoginOptions.encode(message.login, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.logout != null && Object.hasOwnProperty.call(message, "logout"))
                    $root.protos.opts.BatchLogoutOptions.encode(message.logout, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.list != null && Object.hasOwnProperty.call(message, "list"))
                    $root.protos.opts.BatchListOptions.encode(message.list, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.create != null && Object.hasOwnProperty.call(message, "create"))
                    $root.protos.opts.BatchCreateOptions.encode(message.create, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.search != null && Object.hasOwnProperty.call(message, "search"))
                    $root.protos.opts.BatchSearchOptions.encode(message.search, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.archive != null && Object.hasOwnProperty.call(message, "archive"))
                    $root.protos.opts.BatchArchiveOptions.encode(message.archive, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchOptions message, length delimited. Does not implicitly {@link protos.opts.BatchOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.IBatchOptions} message BatchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchOptions} BatchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.outputType = reader.int32();
                        break;
                    case 2:
                        message.apiUrl = reader.string();
                        break;
                    case 3:
                        message.login = $root.protos.opts.BatchLoginOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.logout = $root.protos.opts.BatchLogoutOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.list = $root.protos.opts.BatchListOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.create = $root.protos.opts.BatchCreateOptions.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.search = $root.protos.opts.BatchSearchOptions.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.archive = $root.protos.opts.BatchArchiveOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchOptions} BatchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchOptions message.
             * @function verify
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    switch (message.outputType) {
                    default:
                        return "outputType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.apiUrl != null && message.hasOwnProperty("apiUrl"))
                    if (!$util.isString(message.apiUrl))
                        return "apiUrl: string expected";
                if (message.login != null && message.hasOwnProperty("login")) {
                    var error = $root.protos.opts.BatchLoginOptions.verify(message.login);
                    if (error)
                        return "login." + error;
                }
                if (message.logout != null && message.hasOwnProperty("logout")) {
                    var error = $root.protos.opts.BatchLogoutOptions.verify(message.logout);
                    if (error)
                        return "logout." + error;
                }
                if (message.list != null && message.hasOwnProperty("list")) {
                    var error = $root.protos.opts.BatchListOptions.verify(message.list);
                    if (error)
                        return "list." + error;
                }
                if (message.create != null && message.hasOwnProperty("create")) {
                    var error = $root.protos.opts.BatchCreateOptions.verify(message.create);
                    if (error)
                        return "create." + error;
                }
                if (message.search != null && message.hasOwnProperty("search")) {
                    var error = $root.protos.opts.BatchSearchOptions.verify(message.search);
                    if (error)
                        return "search." + error;
                }
                if (message.archive != null && message.hasOwnProperty("archive")) {
                    var error = $root.protos.opts.BatchArchiveOptions.verify(message.archive);
                    if (error)
                        return "archive." + error;
                }
                return null;
            };

            /**
             * Creates a BatchOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchOptions} BatchOptions
             */
            BatchOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchOptions)
                    return object;
                var message = new $root.protos.opts.BatchOptions();
                switch (object.outputType) {
                case "TABLE":
                case 0:
                    message.outputType = 0;
                    break;
                case "JSON":
                case 1:
                    message.outputType = 1;
                    break;
                }
                if (object.apiUrl != null)
                    message.apiUrl = String(object.apiUrl);
                if (object.login != null) {
                    if (typeof object.login !== "object")
                        throw TypeError(".protos.opts.BatchOptions.login: object expected");
                    message.login = $root.protos.opts.BatchLoginOptions.fromObject(object.login);
                }
                if (object.logout != null) {
                    if (typeof object.logout !== "object")
                        throw TypeError(".protos.opts.BatchOptions.logout: object expected");
                    message.logout = $root.protos.opts.BatchLogoutOptions.fromObject(object.logout);
                }
                if (object.list != null) {
                    if (typeof object.list !== "object")
                        throw TypeError(".protos.opts.BatchOptions.list: object expected");
                    message.list = $root.protos.opts.BatchListOptions.fromObject(object.list);
                }
                if (object.create != null) {
                    if (typeof object.create !== "object")
                        throw TypeError(".protos.opts.BatchOptions.create: object expected");
                    message.create = $root.protos.opts.BatchCreateOptions.fromObject(object.create);
                }
                if (object.search != null) {
                    if (typeof object.search !== "object")
                        throw TypeError(".protos.opts.BatchOptions.search: object expected");
                    message.search = $root.protos.opts.BatchSearchOptions.fromObject(object.search);
                }
                if (object.archive != null) {
                    if (typeof object.archive !== "object")
                        throw TypeError(".protos.opts.BatchOptions.archive: object expected");
                    message.archive = $root.protos.opts.BatchArchiveOptions.fromObject(object.archive);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.BatchOptions} message BatchOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.outputType = options.enums === String ? "TABLE" : 0;
                    object.apiUrl = "";
                    object.login = null;
                    object.logout = null;
                    object.list = null;
                    object.create = null;
                    object.search = null;
                    object.archive = null;
                }
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = options.enums === String ? $root.protos.opts.BatchOutputType[message.outputType] : message.outputType;
                if (message.apiUrl != null && message.hasOwnProperty("apiUrl"))
                    object.apiUrl = message.apiUrl;
                if (message.login != null && message.hasOwnProperty("login"))
                    object.login = $root.protos.opts.BatchLoginOptions.toObject(message.login, options);
                if (message.logout != null && message.hasOwnProperty("logout"))
                    object.logout = $root.protos.opts.BatchLogoutOptions.toObject(message.logout, options);
                if (message.list != null && message.hasOwnProperty("list"))
                    object.list = $root.protos.opts.BatchListOptions.toObject(message.list, options);
                if (message.create != null && message.hasOwnProperty("create"))
                    object.create = $root.protos.opts.BatchCreateOptions.toObject(message.create, options);
                if (message.search != null && message.hasOwnProperty("search"))
                    object.search = $root.protos.opts.BatchSearchOptions.toObject(message.search, options);
                if (message.archive != null && message.hasOwnProperty("archive"))
                    object.archive = $root.protos.opts.BatchArchiveOptions.toObject(message.archive, options);
                return object;
            };

            /**
             * Converts this BatchOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchOptions;
        })();

        opts.BatchLoginOptions = (function() {

            /**
             * Properties of a BatchLoginOptions.
             * @memberof protos.opts
             * @interface IBatchLoginOptions
             */

            /**
             * Constructs a new BatchLoginOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchLoginOptions.
             * @implements IBatchLoginOptions
             * @constructor
             * @param {protos.opts.IBatchLoginOptions=} [properties] Properties to set
             */
            function BatchLoginOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BatchLoginOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.IBatchLoginOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions instance
             */
            BatchLoginOptions.create = function create(properties) {
                return new BatchLoginOptions(properties);
            };

            /**
             * Encodes the specified BatchLoginOptions message. Does not implicitly {@link protos.opts.BatchLoginOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.IBatchLoginOptions} message BatchLoginOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLoginOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BatchLoginOptions message, length delimited. Does not implicitly {@link protos.opts.BatchLoginOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.IBatchLoginOptions} message BatchLoginOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLoginOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchLoginOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLoginOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchLoginOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchLoginOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLoginOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchLoginOptions message.
             * @function verify
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchLoginOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BatchLoginOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions
             */
            BatchLoginOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchLoginOptions)
                    return object;
                return new $root.protos.opts.BatchLoginOptions();
            };

            /**
             * Creates a plain object from a BatchLoginOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.BatchLoginOptions} message BatchLoginOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchLoginOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BatchLoginOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchLoginOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchLoginOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchLoginOptions;
        })();

        opts.BatchLogoutOptions = (function() {

            /**
             * Properties of a BatchLogoutOptions.
             * @memberof protos.opts
             * @interface IBatchLogoutOptions
             */

            /**
             * Constructs a new BatchLogoutOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchLogoutOptions.
             * @implements IBatchLogoutOptions
             * @constructor
             * @param {protos.opts.IBatchLogoutOptions=} [properties] Properties to set
             */
            function BatchLogoutOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BatchLogoutOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.IBatchLogoutOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions instance
             */
            BatchLogoutOptions.create = function create(properties) {
                return new BatchLogoutOptions(properties);
            };

            /**
             * Encodes the specified BatchLogoutOptions message. Does not implicitly {@link protos.opts.BatchLogoutOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.IBatchLogoutOptions} message BatchLogoutOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLogoutOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BatchLogoutOptions message, length delimited. Does not implicitly {@link protos.opts.BatchLogoutOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.IBatchLogoutOptions} message BatchLogoutOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLogoutOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchLogoutOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLogoutOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchLogoutOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchLogoutOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLogoutOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchLogoutOptions message.
             * @function verify
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchLogoutOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BatchLogoutOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions
             */
            BatchLogoutOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchLogoutOptions)
                    return object;
                return new $root.protos.opts.BatchLogoutOptions();
            };

            /**
             * Creates a plain object from a BatchLogoutOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.BatchLogoutOptions} message BatchLogoutOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchLogoutOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BatchLogoutOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchLogoutOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchLogoutOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchLogoutOptions;
        })();

        opts.BatchArchiveOptions = (function() {

            /**
             * Properties of a BatchArchiveOptions.
             * @memberof protos.opts
             * @interface IBatchArchiveOptions
             * @property {protos.opts.IBatchArchiveReplayOptions|null} [replay] BatchArchiveOptions replay
             */

            /**
             * Constructs a new BatchArchiveOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchArchiveOptions.
             * @implements IBatchArchiveOptions
             * @constructor
             * @param {protos.opts.IBatchArchiveOptions=} [properties] Properties to set
             */
            function BatchArchiveOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchArchiveOptions replay.
             * @member {protos.opts.IBatchArchiveReplayOptions|null|undefined} replay
             * @memberof protos.opts.BatchArchiveOptions
             * @instance
             */
            BatchArchiveOptions.prototype.replay = null;

            /**
             * Creates a new BatchArchiveOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.IBatchArchiveOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions instance
             */
            BatchArchiveOptions.create = function create(properties) {
                return new BatchArchiveOptions(properties);
            };

            /**
             * Encodes the specified BatchArchiveOptions message. Does not implicitly {@link protos.opts.BatchArchiveOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.IBatchArchiveOptions} message BatchArchiveOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    $root.protos.opts.BatchArchiveReplayOptions.encode(message.replay, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchArchiveOptions message, length delimited. Does not implicitly {@link protos.opts.BatchArchiveOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.IBatchArchiveOptions} message BatchArchiveOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchArchiveOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchArchiveOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replay = $root.protos.opts.BatchArchiveReplayOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchArchiveOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchArchiveOptions message.
             * @function verify
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchArchiveOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replay != null && message.hasOwnProperty("replay")) {
                    var error = $root.protos.opts.BatchArchiveReplayOptions.verify(message.replay);
                    if (error)
                        return "replay." + error;
                }
                return null;
            };

            /**
             * Creates a BatchArchiveOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions
             */
            BatchArchiveOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchArchiveOptions)
                    return object;
                var message = new $root.protos.opts.BatchArchiveOptions();
                if (object.replay != null) {
                    if (typeof object.replay !== "object")
                        throw TypeError(".protos.opts.BatchArchiveOptions.replay: object expected");
                    message.replay = $root.protos.opts.BatchArchiveReplayOptions.fromObject(object.replay);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchArchiveOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.BatchArchiveOptions} message BatchArchiveOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchArchiveOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.replay = null;
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = $root.protos.opts.BatchArchiveReplayOptions.toObject(message.replay, options);
                return object;
            };

            /**
             * Converts this BatchArchiveOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchArchiveOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchArchiveOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchArchiveOptions;
        })();

        opts.BatchArchiveReplayOptions = (function() {

            /**
             * Properties of a BatchArchiveReplayOptions.
             * @memberof protos.opts
             * @interface IBatchArchiveReplayOptions
             * @property {string|null} [replayId] BatchArchiveReplayOptions replayId
             */

            /**
             * Constructs a new BatchArchiveReplayOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchArchiveReplayOptions.
             * @implements IBatchArchiveReplayOptions
             * @constructor
             * @param {protos.opts.IBatchArchiveReplayOptions=} [properties] Properties to set
             */
            function BatchArchiveReplayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchArchiveReplayOptions replayId.
             * @member {string} replayId
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @instance
             */
            BatchArchiveReplayOptions.prototype.replayId = "";

            /**
             * Creates a new BatchArchiveReplayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.IBatchArchiveReplayOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions instance
             */
            BatchArchiveReplayOptions.create = function create(properties) {
                return new BatchArchiveReplayOptions(properties);
            };

            /**
             * Encodes the specified BatchArchiveReplayOptions message. Does not implicitly {@link protos.opts.BatchArchiveReplayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.IBatchArchiveReplayOptions} message BatchArchiveReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveReplayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replayId != null && Object.hasOwnProperty.call(message, "replayId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.replayId);
                return writer;
            };

            /**
             * Encodes the specified BatchArchiveReplayOptions message, length delimited. Does not implicitly {@link protos.opts.BatchArchiveReplayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.IBatchArchiveReplayOptions} message BatchArchiveReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveReplayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchArchiveReplayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveReplayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchArchiveReplayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replayId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchArchiveReplayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveReplayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchArchiveReplayOptions message.
             * @function verify
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchArchiveReplayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replayId != null && message.hasOwnProperty("replayId"))
                    if (!$util.isString(message.replayId))
                        return "replayId: string expected";
                return null;
            };

            /**
             * Creates a BatchArchiveReplayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions
             */
            BatchArchiveReplayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchArchiveReplayOptions)
                    return object;
                var message = new $root.protos.opts.BatchArchiveReplayOptions();
                if (object.replayId != null)
                    message.replayId = String(object.replayId);
                return message;
            };

            /**
             * Creates a plain object from a BatchArchiveReplayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.BatchArchiveReplayOptions} message BatchArchiveReplayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchArchiveReplayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.replayId = "";
                if (message.replayId != null && message.hasOwnProperty("replayId"))
                    object.replayId = message.replayId;
                return object;
            };

            /**
             * Converts this BatchArchiveReplayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchArchiveReplayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchArchiveReplayOptions;
        })();

        opts.BatchListOptions = (function() {

            /**
             * Properties of a BatchListOptions.
             * @memberof protos.opts
             * @interface IBatchListOptions
             * @property {boolean|null} [collection] BatchListOptions collection
             * @property {boolean|null} [destination] BatchListOptions destination
             * @property {boolean|null} [replay] BatchListOptions replay
             * @property {boolean|null} [schema] BatchListOptions schema
             */

            /**
             * Constructs a new BatchListOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchListOptions.
             * @implements IBatchListOptions
             * @constructor
             * @param {protos.opts.IBatchListOptions=} [properties] Properties to set
             */
            function BatchListOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchListOptions collection.
             * @member {boolean} collection
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.collection = false;

            /**
             * BatchListOptions destination.
             * @member {boolean} destination
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.destination = false;

            /**
             * BatchListOptions replay.
             * @member {boolean} replay
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.replay = false;

            /**
             * BatchListOptions schema.
             * @member {boolean} schema
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.schema = false;

            /**
             * Creates a new BatchListOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.IBatchListOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchListOptions} BatchListOptions instance
             */
            BatchListOptions.create = function create(properties) {
                return new BatchListOptions(properties);
            };

            /**
             * Encodes the specified BatchListOptions message. Does not implicitly {@link protos.opts.BatchListOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.IBatchListOptions} message BatchListOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.collection);
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.destination);
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.replay);
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.schema);
                return writer;
            };

            /**
             * Encodes the specified BatchListOptions message, length delimited. Does not implicitly {@link protos.opts.BatchListOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.IBatchListOptions} message BatchListOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchListOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchListOptions} BatchListOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchListOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection = reader.bool();
                        break;
                    case 2:
                        message.destination = reader.bool();
                        break;
                    case 3:
                        message.replay = reader.bool();
                        break;
                    case 4:
                        message.schema = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchListOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchListOptions} BatchListOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchListOptions message.
             * @function verify
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchListOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (typeof message.collection !== "boolean")
                        return "collection: boolean expected";
                if (message.destination != null && message.hasOwnProperty("destination"))
                    if (typeof message.destination !== "boolean")
                        return "destination: boolean expected";
                if (message.replay != null && message.hasOwnProperty("replay"))
                    if (typeof message.replay !== "boolean")
                        return "replay: boolean expected";
                if (message.schema != null && message.hasOwnProperty("schema"))
                    if (typeof message.schema !== "boolean")
                        return "schema: boolean expected";
                return null;
            };

            /**
             * Creates a BatchListOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchListOptions} BatchListOptions
             */
            BatchListOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchListOptions)
                    return object;
                var message = new $root.protos.opts.BatchListOptions();
                if (object.collection != null)
                    message.collection = Boolean(object.collection);
                if (object.destination != null)
                    message.destination = Boolean(object.destination);
                if (object.replay != null)
                    message.replay = Boolean(object.replay);
                if (object.schema != null)
                    message.schema = Boolean(object.schema);
                return message;
            };

            /**
             * Creates a plain object from a BatchListOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.BatchListOptions} message BatchListOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchListOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection = false;
                    object.destination = false;
                    object.replay = false;
                    object.schema = false;
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = message.destination;
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = message.replay;
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = message.schema;
                return object;
            };

            /**
             * Converts this BatchListOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchListOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchListOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchListOptions;
        })();

        opts.BatchCreateOptions = (function() {

            /**
             * Properties of a BatchCreateOptions.
             * @memberof protos.opts
             * @interface IBatchCreateOptions
             * @property {protos.opts.IBatchCreateCollectionOptions|null} [collection] BatchCreateOptions collection
             * @property {protos.opts.IBatchCreateReplayOptions|null} [replay] BatchCreateOptions replay
             * @property {protos.opts.IBatchCreateDestinationOptions|null} [destination] BatchCreateOptions destination
             */

            /**
             * Constructs a new BatchCreateOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateOptions.
             * @implements IBatchCreateOptions
             * @constructor
             * @param {protos.opts.IBatchCreateOptions=} [properties] Properties to set
             */
            function BatchCreateOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateOptions collection.
             * @member {protos.opts.IBatchCreateCollectionOptions|null|undefined} collection
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             */
            BatchCreateOptions.prototype.collection = null;

            /**
             * BatchCreateOptions replay.
             * @member {protos.opts.IBatchCreateReplayOptions|null|undefined} replay
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             */
            BatchCreateOptions.prototype.replay = null;

            /**
             * BatchCreateOptions destination.
             * @member {protos.opts.IBatchCreateDestinationOptions|null|undefined} destination
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             */
            BatchCreateOptions.prototype.destination = null;

            /**
             * Creates a new BatchCreateOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.IBatchCreateOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions instance
             */
            BatchCreateOptions.create = function create(properties) {
                return new BatchCreateOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateOptions message. Does not implicitly {@link protos.opts.BatchCreateOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.IBatchCreateOptions} message BatchCreateOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    $root.protos.opts.BatchCreateCollectionOptions.encode(message.collection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    $root.protos.opts.BatchCreateReplayOptions.encode(message.replay, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    $root.protos.opts.BatchCreateDestinationOptions.encode(message.destination, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchCreateOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.IBatchCreateOptions} message BatchCreateOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection = $root.protos.opts.BatchCreateCollectionOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.replay = $root.protos.opts.BatchCreateReplayOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.destination = $root.protos.opts.BatchCreateDestinationOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection != null && message.hasOwnProperty("collection")) {
                    var error = $root.protos.opts.BatchCreateCollectionOptions.verify(message.collection);
                    if (error)
                        return "collection." + error;
                }
                if (message.replay != null && message.hasOwnProperty("replay")) {
                    var error = $root.protos.opts.BatchCreateReplayOptions.verify(message.replay);
                    if (error)
                        return "replay." + error;
                }
                if (message.destination != null && message.hasOwnProperty("destination")) {
                    var error = $root.protos.opts.BatchCreateDestinationOptions.verify(message.destination);
                    if (error)
                        return "destination." + error;
                }
                return null;
            };

            /**
             * Creates a BatchCreateOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions
             */
            BatchCreateOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateOptions)
                    return object;
                var message = new $root.protos.opts.BatchCreateOptions();
                if (object.collection != null) {
                    if (typeof object.collection !== "object")
                        throw TypeError(".protos.opts.BatchCreateOptions.collection: object expected");
                    message.collection = $root.protos.opts.BatchCreateCollectionOptions.fromObject(object.collection);
                }
                if (object.replay != null) {
                    if (typeof object.replay !== "object")
                        throw TypeError(".protos.opts.BatchCreateOptions.replay: object expected");
                    message.replay = $root.protos.opts.BatchCreateReplayOptions.fromObject(object.replay);
                }
                if (object.destination != null) {
                    if (typeof object.destination !== "object")
                        throw TypeError(".protos.opts.BatchCreateOptions.destination: object expected");
                    message.destination = $root.protos.opts.BatchCreateDestinationOptions.fromObject(object.destination);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.BatchCreateOptions} message BatchCreateOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection = null;
                    object.replay = null;
                    object.destination = null;
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = $root.protos.opts.BatchCreateCollectionOptions.toObject(message.collection, options);
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = $root.protos.opts.BatchCreateReplayOptions.toObject(message.replay, options);
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = $root.protos.opts.BatchCreateDestinationOptions.toObject(message.destination, options);
                return object;
            };

            /**
             * Converts this BatchCreateOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateOptions;
        })();

        opts.BatchSearchOptions = (function() {

            /**
             * Properties of a BatchSearchOptions.
             * @memberof protos.opts
             * @interface IBatchSearchOptions
             * @property {string|null} [query] BatchSearchOptions query
             * @property {string|null} [collectionId] BatchSearchOptions collectionId
             * @property {number|null} [page] BatchSearchOptions page
             */

            /**
             * Constructs a new BatchSearchOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchSearchOptions.
             * @implements IBatchSearchOptions
             * @constructor
             * @param {protos.opts.IBatchSearchOptions=} [properties] Properties to set
             */
            function BatchSearchOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchSearchOptions query.
             * @member {string} query
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             */
            BatchSearchOptions.prototype.query = "";

            /**
             * BatchSearchOptions collectionId.
             * @member {string} collectionId
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             */
            BatchSearchOptions.prototype.collectionId = "";

            /**
             * BatchSearchOptions page.
             * @member {number} page
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             */
            BatchSearchOptions.prototype.page = 0;

            /**
             * Creates a new BatchSearchOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.IBatchSearchOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions instance
             */
            BatchSearchOptions.create = function create(properties) {
                return new BatchSearchOptions(properties);
            };

            /**
             * Encodes the specified BatchSearchOptions message. Does not implicitly {@link protos.opts.BatchSearchOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.IBatchSearchOptions} message BatchSearchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchSearchOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                if (message.collectionId != null && Object.hasOwnProperty.call(message, "collectionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collectionId);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.page);
                return writer;
            };

            /**
             * Encodes the specified BatchSearchOptions message, length delimited. Does not implicitly {@link protos.opts.BatchSearchOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.IBatchSearchOptions} message BatchSearchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchSearchOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchSearchOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchSearchOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchSearchOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    case 2:
                        message.collectionId = reader.string();
                        break;
                    case 3:
                        message.page = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchSearchOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchSearchOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchSearchOptions message.
             * @function verify
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchSearchOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    if (!$util.isString(message.collectionId))
                        return "collectionId: string expected";
                if (message.page != null && message.hasOwnProperty("page"))
                    if (!$util.isInteger(message.page))
                        return "page: integer expected";
                return null;
            };

            /**
             * Creates a BatchSearchOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions
             */
            BatchSearchOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchSearchOptions)
                    return object;
                var message = new $root.protos.opts.BatchSearchOptions();
                if (object.query != null)
                    message.query = String(object.query);
                if (object.collectionId != null)
                    message.collectionId = String(object.collectionId);
                if (object.page != null)
                    message.page = object.page | 0;
                return message;
            };

            /**
             * Creates a plain object from a BatchSearchOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.BatchSearchOptions} message BatchSearchOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchSearchOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.query = "";
                    object.collectionId = "";
                    object.page = 0;
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    object.collectionId = message.collectionId;
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = message.page;
                return object;
            };

            /**
             * Converts this BatchSearchOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchSearchOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchSearchOptions;
        })();

        opts.BatchCreateCollectionOptions = (function() {

            /**
             * Properties of a BatchCreateCollectionOptions.
             * @memberof protos.opts
             * @interface IBatchCreateCollectionOptions
             * @property {string|null} [name] BatchCreateCollectionOptions name
             * @property {string|null} [schemaId] BatchCreateCollectionOptions schemaId
             * @property {string|null} [notes] BatchCreateCollectionOptions notes
             */

            /**
             * Constructs a new BatchCreateCollectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateCollectionOptions.
             * @implements IBatchCreateCollectionOptions
             * @constructor
             * @param {protos.opts.IBatchCreateCollectionOptions=} [properties] Properties to set
             */
            function BatchCreateCollectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateCollectionOptions name.
             * @member {string} name
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             */
            BatchCreateCollectionOptions.prototype.name = "";

            /**
             * BatchCreateCollectionOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             */
            BatchCreateCollectionOptions.prototype.schemaId = "";

            /**
             * BatchCreateCollectionOptions notes.
             * @member {string} notes
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             */
            BatchCreateCollectionOptions.prototype.notes = "";

            /**
             * Creates a new BatchCreateCollectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.IBatchCreateCollectionOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions instance
             */
            BatchCreateCollectionOptions.create = function create(properties) {
                return new BatchCreateCollectionOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateCollectionOptions message. Does not implicitly {@link protos.opts.BatchCreateCollectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.IBatchCreateCollectionOptions} message BatchCreateCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateCollectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.notes);
                return writer;
            };

            /**
             * Encodes the specified BatchCreateCollectionOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateCollectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.IBatchCreateCollectionOptions} message BatchCreateCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateCollectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateCollectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateCollectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateCollectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.schemaId = reader.string();
                        break;
                    case 3:
                        message.notes = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateCollectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateCollectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateCollectionOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateCollectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                return null;
            };

            /**
             * Creates a BatchCreateCollectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions
             */
            BatchCreateCollectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateCollectionOptions)
                    return object;
                var message = new $root.protos.opts.BatchCreateCollectionOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                if (object.notes != null)
                    message.notes = String(object.notes);
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateCollectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.BatchCreateCollectionOptions} message BatchCreateCollectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateCollectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.schemaId = "";
                    object.notes = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                return object;
            };

            /**
             * Converts this BatchCreateCollectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateCollectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateCollectionOptions;
        })();

        opts.BatchCreateReplayOptions = (function() {

            /**
             * Properties of a BatchCreateReplayOptions.
             * @memberof protos.opts
             * @interface IBatchCreateReplayOptions
             * @property {string|null} [name] BatchCreateReplayOptions name
             * @property {protos.opts.BatchReplayType|null} [type] BatchCreateReplayOptions type
             * @property {string|null} [notes] BatchCreateReplayOptions notes
             * @property {string|null} [collectionId] BatchCreateReplayOptions collectionId
             * @property {string|null} [destinationId] BatchCreateReplayOptions destinationId
             * @property {string|null} [query] BatchCreateReplayOptions query
             * @property {string|null} [fromTimestamp] BatchCreateReplayOptions fromTimestamp
             * @property {string|null} [toTimestamp] BatchCreateReplayOptions toTimestamp
             */

            /**
             * Constructs a new BatchCreateReplayOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateReplayOptions.
             * @implements IBatchCreateReplayOptions
             * @constructor
             * @param {protos.opts.IBatchCreateReplayOptions=} [properties] Properties to set
             */
            function BatchCreateReplayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateReplayOptions name.
             * @member {string} name
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.name = "";

            /**
             * BatchCreateReplayOptions type.
             * @member {protos.opts.BatchReplayType} type
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.type = 0;

            /**
             * BatchCreateReplayOptions notes.
             * @member {string} notes
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.notes = "";

            /**
             * BatchCreateReplayOptions collectionId.
             * @member {string} collectionId
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.collectionId = "";

            /**
             * BatchCreateReplayOptions destinationId.
             * @member {string} destinationId
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.destinationId = "";

            /**
             * BatchCreateReplayOptions query.
             * @member {string} query
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.query = "";

            /**
             * BatchCreateReplayOptions fromTimestamp.
             * @member {string} fromTimestamp
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.fromTimestamp = "";

            /**
             * BatchCreateReplayOptions toTimestamp.
             * @member {string} toTimestamp
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.toTimestamp = "";

            /**
             * Creates a new BatchCreateReplayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.IBatchCreateReplayOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions instance
             */
            BatchCreateReplayOptions.create = function create(properties) {
                return new BatchCreateReplayOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateReplayOptions message. Does not implicitly {@link protos.opts.BatchCreateReplayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.IBatchCreateReplayOptions} message BatchCreateReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateReplayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.notes);
                if (message.collectionId != null && Object.hasOwnProperty.call(message, "collectionId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.collectionId);
                if (message.destinationId != null && Object.hasOwnProperty.call(message, "destinationId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.destinationId);
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.query);
                if (message.fromTimestamp != null && Object.hasOwnProperty.call(message, "fromTimestamp"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.fromTimestamp);
                if (message.toTimestamp != null && Object.hasOwnProperty.call(message, "toTimestamp"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.toTimestamp);
                return writer;
            };

            /**
             * Encodes the specified BatchCreateReplayOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateReplayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.IBatchCreateReplayOptions} message BatchCreateReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateReplayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateReplayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateReplayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateReplayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.notes = reader.string();
                        break;
                    case 4:
                        message.collectionId = reader.string();
                        break;
                    case 5:
                        message.destinationId = reader.string();
                        break;
                    case 6:
                        message.query = reader.string();
                        break;
                    case 7:
                        message.fromTimestamp = reader.string();
                        break;
                    case 8:
                        message.toTimestamp = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateReplayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateReplayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateReplayOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateReplayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    if (!$util.isString(message.collectionId))
                        return "collectionId: string expected";
                if (message.destinationId != null && message.hasOwnProperty("destinationId"))
                    if (!$util.isString(message.destinationId))
                        return "destinationId: string expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                if (message.fromTimestamp != null && message.hasOwnProperty("fromTimestamp"))
                    if (!$util.isString(message.fromTimestamp))
                        return "fromTimestamp: string expected";
                if (message.toTimestamp != null && message.hasOwnProperty("toTimestamp"))
                    if (!$util.isString(message.toTimestamp))
                        return "toTimestamp: string expected";
                return null;
            };

            /**
             * Creates a BatchCreateReplayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions
             */
            BatchCreateReplayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateReplayOptions)
                    return object;
                var message = new $root.protos.opts.BatchCreateReplayOptions();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "SINGLE":
                case 0:
                    message.type = 0;
                    break;
                case "CONTINUOUS":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.collectionId != null)
                    message.collectionId = String(object.collectionId);
                if (object.destinationId != null)
                    message.destinationId = String(object.destinationId);
                if (object.query != null)
                    message.query = String(object.query);
                if (object.fromTimestamp != null)
                    message.fromTimestamp = String(object.fromTimestamp);
                if (object.toTimestamp != null)
                    message.toTimestamp = String(object.toTimestamp);
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateReplayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.BatchCreateReplayOptions} message BatchCreateReplayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateReplayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "SINGLE" : 0;
                    object.notes = "";
                    object.collectionId = "";
                    object.destinationId = "";
                    object.query = "";
                    object.fromTimestamp = "";
                    object.toTimestamp = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.opts.BatchReplayType[message.type] : message.type;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    object.collectionId = message.collectionId;
                if (message.destinationId != null && message.hasOwnProperty("destinationId"))
                    object.destinationId = message.destinationId;
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.fromTimestamp != null && message.hasOwnProperty("fromTimestamp"))
                    object.fromTimestamp = message.fromTimestamp;
                if (message.toTimestamp != null && message.hasOwnProperty("toTimestamp"))
                    object.toTimestamp = message.toTimestamp;
                return object;
            };

            /**
             * Converts this BatchCreateReplayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateReplayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateReplayOptions;
        })();

        opts.BatchCreateDestinationOptions = (function() {

            /**
             * Properties of a BatchCreateDestinationOptions.
             * @memberof protos.opts
             * @interface IBatchCreateDestinationOptions
             * @property {string|null} [name] BatchCreateDestinationOptions name
             * @property {string|null} [notes] BatchCreateDestinationOptions notes
             * @property {string|null} [_apiDestinationType] BatchCreateDestinationOptions _apiDestinationType
             * @property {protos.opts.IWriteGroupKafkaOptions|null} [kafka] BatchCreateDestinationOptions kafka
             * @property {protos.opts.IWriteGroupRabbitOptions|null} [rabbit] BatchCreateDestinationOptions rabbit
             * @property {protos.opts.IWriteGroupKubeMQQueueOptions|null} [kubemqQueue] BatchCreateDestinationOptions kubemqQueue
             * @property {protos.opts.IWriteGroupAWSSQSOptions|null} [awssqs] BatchCreateDestinationOptions awssqs
             * @property {protos.opts.IHTTPDestination|null} [http] BatchCreateDestinationOptions http
             */

            /**
             * Constructs a new BatchCreateDestinationOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateDestinationOptions.
             * @implements IBatchCreateDestinationOptions
             * @constructor
             * @param {protos.opts.IBatchCreateDestinationOptions=} [properties] Properties to set
             */
            function BatchCreateDestinationOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateDestinationOptions name.
             * @member {string} name
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.name = "";

            /**
             * BatchCreateDestinationOptions notes.
             * @member {string} notes
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.notes = "";

            /**
             * BatchCreateDestinationOptions _apiDestinationType.
             * @member {string} _apiDestinationType
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype._apiDestinationType = "";

            /**
             * BatchCreateDestinationOptions kafka.
             * @member {protos.opts.IWriteGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.kafka = null;

            /**
             * BatchCreateDestinationOptions rabbit.
             * @member {protos.opts.IWriteGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.rabbit = null;

            /**
             * BatchCreateDestinationOptions kubemqQueue.
             * @member {protos.opts.IWriteGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.kubemqQueue = null;

            /**
             * BatchCreateDestinationOptions awssqs.
             * @member {protos.opts.IWriteGroupAWSSQSOptions|null|undefined} awssqs
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.awssqs = null;

            /**
             * BatchCreateDestinationOptions http.
             * @member {protos.opts.IHTTPDestination|null|undefined} http
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.http = null;

            /**
             * Creates a new BatchCreateDestinationOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.IBatchCreateDestinationOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions instance
             */
            BatchCreateDestinationOptions.create = function create(properties) {
                return new BatchCreateDestinationOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateDestinationOptions message. Does not implicitly {@link protos.opts.BatchCreateDestinationOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.IBatchCreateDestinationOptions} message BatchCreateDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateDestinationOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.notes);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.WriteGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.WriteGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.WriteGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.opts.WriteGroupAWSSQSOptions.encode(message.awssqs, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.http != null && Object.hasOwnProperty.call(message, "http"))
                    $root.protos.opts.HTTPDestination.encode(message.http, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message._apiDestinationType != null && Object.hasOwnProperty.call(message, "_apiDestinationType"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._apiDestinationType);
                return writer;
            };

            /**
             * Encodes the specified BatchCreateDestinationOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateDestinationOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.IBatchCreateDestinationOptions} message BatchCreateDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateDestinationOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateDestinationOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateDestinationOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateDestinationOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.notes = reader.string();
                        break;
                    case 1000:
                        message._apiDestinationType = reader.string();
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.WriteGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.http = $root.protos.opts.HTTPDestination.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateDestinationOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateDestinationOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateDestinationOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateDestinationOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message._apiDestinationType != null && message.hasOwnProperty("_apiDestinationType"))
                    if (!$util.isString(message._apiDestinationType))
                        return "_apiDestinationType: string expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.WriteGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.WriteGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.WriteGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    var error = $root.protos.opts.WriteGroupAWSSQSOptions.verify(message.awssqs);
                    if (error)
                        return "awssqs." + error;
                }
                if (message.http != null && message.hasOwnProperty("http")) {
                    var error = $root.protos.opts.HTTPDestination.verify(message.http);
                    if (error)
                        return "http." + error;
                }
                return null;
            };

            /**
             * Creates a BatchCreateDestinationOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions
             */
            BatchCreateDestinationOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateDestinationOptions)
                    return object;
                var message = new $root.protos.opts.BatchCreateDestinationOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object._apiDestinationType != null)
                    message._apiDestinationType = String(object._apiDestinationType);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.WriteGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.awssqs: object expected");
                    message.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.fromObject(object.awssqs);
                }
                if (object.http != null) {
                    if (typeof object.http !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.http: object expected");
                    message.http = $root.protos.opts.HTTPDestination.fromObject(object.http);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateDestinationOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.BatchCreateDestinationOptions} message BatchCreateDestinationOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateDestinationOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.notes = "";
                    object.kafka = null;
                    object.rabbit = null;
                    object.kubemqQueue = null;
                    object.awssqs = null;
                    object.http = null;
                    object._apiDestinationType = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.WriteGroupKafkaOptions.toObject(message.kafka, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.WriteGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.awssqs != null && message.hasOwnProperty("awssqs"))
                    object.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.toObject(message.awssqs, options);
                if (message.http != null && message.hasOwnProperty("http"))
                    object.http = $root.protos.opts.HTTPDestination.toObject(message.http, options);
                if (message._apiDestinationType != null && message.hasOwnProperty("_apiDestinationType"))
                    object._apiDestinationType = message._apiDestinationType;
                return object;
            };

            /**
             * Converts this BatchCreateDestinationOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateDestinationOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateDestinationOptions;
        })();

        opts.HTTPDestination = (function() {

            /**
             * Properties of a HTTPDestination.
             * @memberof protos.opts
             * @interface IHTTPDestination
             * @property {string|null} [url] HTTPDestination url
             * @property {Object.<string,string>|null} [headers] HTTPDestination headers
             */

            /**
             * Constructs a new HTTPDestination.
             * @memberof protos.opts
             * @classdesc Represents a HTTPDestination.
             * @implements IHTTPDestination
             * @constructor
             * @param {protos.opts.IHTTPDestination=} [properties] Properties to set
             */
            function HTTPDestination(properties) {
                this.headers = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HTTPDestination url.
             * @member {string} url
             * @memberof protos.opts.HTTPDestination
             * @instance
             */
            HTTPDestination.prototype.url = "";

            /**
             * HTTPDestination headers.
             * @member {Object.<string,string>} headers
             * @memberof protos.opts.HTTPDestination
             * @instance
             */
            HTTPDestination.prototype.headers = $util.emptyObject;

            /**
             * Creates a new HTTPDestination instance using the specified properties.
             * @function create
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination=} [properties] Properties to set
             * @returns {protos.opts.HTTPDestination} HTTPDestination instance
             */
            HTTPDestination.create = function create(properties) {
                return new HTTPDestination(properties);
            };

            /**
             * Encodes the specified HTTPDestination message. Does not implicitly {@link protos.opts.HTTPDestination.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination} message HTTPDestination message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HTTPDestination.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    for (var keys = Object.keys(message.headers), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.headers[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HTTPDestination message, length delimited. Does not implicitly {@link protos.opts.HTTPDestination.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination} message HTTPDestination message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HTTPDestination.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HTTPDestination message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HTTPDestination.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.HTTPDestination(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        if (message.headers === $util.emptyObject)
                            message.headers = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.headers[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HTTPDestination message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HTTPDestination.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HTTPDestination message.
             * @function verify
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HTTPDestination.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!$util.isObject(message.headers))
                        return "headers: object expected";
                    var key = Object.keys(message.headers);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.headers[key[i]]))
                            return "headers: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a HTTPDestination message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             */
            HTTPDestination.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.HTTPDestination)
                    return object;
                var message = new $root.protos.opts.HTTPDestination();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.headers) {
                    if (typeof object.headers !== "object")
                        throw TypeError(".protos.opts.HTTPDestination.headers: object expected");
                    message.headers = {};
                    for (var keys = Object.keys(object.headers), i = 0; i < keys.length; ++i)
                        message.headers[keys[i]] = String(object.headers[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a HTTPDestination message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.HTTPDestination} message HTTPDestination
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HTTPDestination.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.headers = {};
                if (options.defaults)
                    object.url = "";
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                var keys2;
                if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                    object.headers = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.headers[keys2[j]] = message.headers[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this HTTPDestination to JSON.
             * @function toJSON
             * @memberof protos.opts.HTTPDestination
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HTTPDestination.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HTTPDestination;
        })();

        opts.GlobalCLIOptions = (function() {

            /**
             * Properties of a GlobalCLIOptions.
             * @memberof protos.opts
             * @interface IGlobalCLIOptions
             * @property {boolean|null} [debug] GlobalCLIOptions debug
             * @property {boolean|null} [quiet] GlobalCLIOptions quiet
             * @property {boolean|null} [version] GlobalCLIOptions version
             * @property {string|null} [_fullCommand] GlobalCLIOptions _fullCommand
             * @property {string|null} [_action] GlobalCLIOptions _action
             * @property {string|null} [_backend] GlobalCLIOptions _backend
             */

            /**
             * Constructs a new GlobalCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a GlobalCLIOptions.
             * @implements IGlobalCLIOptions
             * @constructor
             * @param {protos.opts.IGlobalCLIOptions=} [properties] Properties to set
             */
            function GlobalCLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GlobalCLIOptions debug.
             * @member {boolean} debug
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.debug = false;

            /**
             * GlobalCLIOptions quiet.
             * @member {boolean} quiet
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.quiet = false;

            /**
             * GlobalCLIOptions version.
             * @member {boolean} version
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.version = false;

            /**
             * GlobalCLIOptions _fullCommand.
             * @member {string} _fullCommand
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._fullCommand = "";

            /**
             * GlobalCLIOptions _action.
             * @member {string} _action
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._action = "";

            /**
             * GlobalCLIOptions _backend.
             * @member {string} _backend
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._backend = "";

            /**
             * Creates a new GlobalCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions instance
             */
            GlobalCLIOptions.create = function create(properties) {
                return new GlobalCLIOptions(properties);
            };

            /**
             * Encodes the specified GlobalCLIOptions message. Does not implicitly {@link protos.opts.GlobalCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions} message GlobalCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.debug);
                if (message.quiet != null && Object.hasOwnProperty.call(message, "quiet"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.quiet);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.version);
                if (message._fullCommand != null && Object.hasOwnProperty.call(message, "_fullCommand"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._fullCommand);
                if (message._action != null && Object.hasOwnProperty.call(message, "_action"))
                    writer.uint32(/* id 1001, wireType 2 =*/8010).string(message._action);
                if (message._backend != null && Object.hasOwnProperty.call(message, "_backend"))
                    writer.uint32(/* id 1002, wireType 2 =*/8018).string(message._backend);
                return writer;
            };

            /**
             * Encodes the specified GlobalCLIOptions message, length delimited. Does not implicitly {@link protos.opts.GlobalCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions} message GlobalCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlobalCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.GlobalCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.debug = reader.bool();
                        break;
                    case 2:
                        message.quiet = reader.bool();
                        break;
                    case 3:
                        message.version = reader.bool();
                        break;
                    case 1000:
                        message._fullCommand = reader.string();
                        break;
                    case 1001:
                        message._action = reader.string();
                        break;
                    case 1002:
                        message._backend = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlobalCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlobalCLIOptions message.
             * @function verify
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GlobalCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.debug != null && message.hasOwnProperty("debug"))
                    if (typeof message.debug !== "boolean")
                        return "debug: boolean expected";
                if (message.quiet != null && message.hasOwnProperty("quiet"))
                    if (typeof message.quiet !== "boolean")
                        return "quiet: boolean expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (typeof message.version !== "boolean")
                        return "version: boolean expected";
                if (message._fullCommand != null && message.hasOwnProperty("_fullCommand"))
                    if (!$util.isString(message._fullCommand))
                        return "_fullCommand: string expected";
                if (message._action != null && message.hasOwnProperty("_action"))
                    if (!$util.isString(message._action))
                        return "_action: string expected";
                if (message._backend != null && message.hasOwnProperty("_backend"))
                    if (!$util.isString(message._backend))
                        return "_backend: string expected";
                return null;
            };

            /**
             * Creates a GlobalCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             */
            GlobalCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.GlobalCLIOptions)
                    return object;
                var message = new $root.protos.opts.GlobalCLIOptions();
                if (object.debug != null)
                    message.debug = Boolean(object.debug);
                if (object.quiet != null)
                    message.quiet = Boolean(object.quiet);
                if (object.version != null)
                    message.version = Boolean(object.version);
                if (object._fullCommand != null)
                    message._fullCommand = String(object._fullCommand);
                if (object._action != null)
                    message._action = String(object._action);
                if (object._backend != null)
                    message._backend = String(object._backend);
                return message;
            };

            /**
             * Creates a plain object from a GlobalCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.GlobalCLIOptions} message GlobalCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.debug = false;
                    object.quiet = false;
                    object.version = false;
                    object._fullCommand = "";
                    object._action = "";
                    object._backend = "";
                }
                if (message.debug != null && message.hasOwnProperty("debug"))
                    object.debug = message.debug;
                if (message.quiet != null && message.hasOwnProperty("quiet"))
                    object.quiet = message.quiet;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message._fullCommand != null && message.hasOwnProperty("_fullCommand"))
                    object._fullCommand = message._fullCommand;
                if (message._action != null && message.hasOwnProperty("_action"))
                    object._action = message._action;
                if (message._backend != null && message.hasOwnProperty("_backend"))
                    object._backend = message._backend;
                return object;
            };

            /**
             * Converts this GlobalCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GlobalCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GlobalCLIOptions;
        })();

        opts.CLIOptions = (function() {

            /**
             * Properties of a CLIOptions.
             * @memberof protos.opts
             * @interface ICLIOptions
             * @property {protos.opts.IGlobalCLIOptions|null} [global] CLIOptions global
             * @property {protos.opts.IReadOptions|null} [read] CLIOptions read
             * @property {protos.opts.IWriteOptions|null} [write] CLIOptions write
             * @property {protos.opts.IRelayOptions|null} [relay] CLIOptions relay
             * @property {protos.opts.IDynamicOptions|null} [dynamic] CLIOptions dynamic
             * @property {protos.opts.IBatchOptions|null} [batch] CLIOptions batch
             * @property {protos.opts.IServerOptions|null} [server] CLIOptions server
             */

            /**
             * Constructs a new CLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a CLIOptions.
             * @implements ICLIOptions
             * @constructor
             * @param {protos.opts.ICLIOptions=} [properties] Properties to set
             */
            function CLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CLIOptions global.
             * @member {protos.opts.IGlobalCLIOptions|null|undefined} global
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.global = null;

            /**
             * CLIOptions read.
             * @member {protos.opts.IReadOptions|null|undefined} read
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.read = null;

            /**
             * CLIOptions write.
             * @member {protos.opts.IWriteOptions|null|undefined} write
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.write = null;

            /**
             * CLIOptions relay.
             * @member {protos.opts.IRelayOptions|null|undefined} relay
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.relay = null;

            /**
             * CLIOptions dynamic.
             * @member {protos.opts.IDynamicOptions|null|undefined} dynamic
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.dynamic = null;

            /**
             * CLIOptions batch.
             * @member {protos.opts.IBatchOptions|null|undefined} batch
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.batch = null;

            /**
             * CLIOptions server.
             * @member {protos.opts.IServerOptions|null|undefined} server
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.server = null;

            /**
             * Creates a new CLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions=} [properties] Properties to set
             * @returns {protos.opts.CLIOptions} CLIOptions instance
             */
            CLIOptions.create = function create(properties) {
                return new CLIOptions(properties);
            };

            /**
             * Encodes the specified CLIOptions message. Does not implicitly {@link protos.opts.CLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions} message CLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.global != null && Object.hasOwnProperty.call(message, "global"))
                    $root.protos.opts.GlobalCLIOptions.encode(message.global, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.read != null && Object.hasOwnProperty.call(message, "read"))
                    $root.protos.opts.ReadOptions.encode(message.read, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.write != null && Object.hasOwnProperty.call(message, "write"))
                    $root.protos.opts.WriteOptions.encode(message.write, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.relay != null && Object.hasOwnProperty.call(message, "relay"))
                    $root.protos.opts.RelayOptions.encode(message.relay, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.dynamic != null && Object.hasOwnProperty.call(message, "dynamic"))
                    $root.protos.opts.DynamicOptions.encode(message.dynamic, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.batch != null && Object.hasOwnProperty.call(message, "batch"))
                    $root.protos.opts.BatchOptions.encode(message.batch, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.server != null && Object.hasOwnProperty.call(message, "server"))
                    $root.protos.opts.ServerOptions.encode(message.server, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CLIOptions message, length delimited. Does not implicitly {@link protos.opts.CLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions} message CLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.CLIOptions} CLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.CLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.global = $root.protos.opts.GlobalCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.read = $root.protos.opts.ReadOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.write = $root.protos.opts.WriteOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.relay = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.dynamic = $root.protos.opts.DynamicOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.batch = $root.protos.opts.BatchOptions.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.server = $root.protos.opts.ServerOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.CLIOptions} CLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CLIOptions message.
             * @function verify
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.global != null && message.hasOwnProperty("global")) {
                    var error = $root.protos.opts.GlobalCLIOptions.verify(message.global);
                    if (error)
                        return "global." + error;
                }
                if (message.read != null && message.hasOwnProperty("read")) {
                    var error = $root.protos.opts.ReadOptions.verify(message.read);
                    if (error)
                        return "read." + error;
                }
                if (message.write != null && message.hasOwnProperty("write")) {
                    var error = $root.protos.opts.WriteOptions.verify(message.write);
                    if (error)
                        return "write." + error;
                }
                if (message.relay != null && message.hasOwnProperty("relay")) {
                    var error = $root.protos.opts.RelayOptions.verify(message.relay);
                    if (error)
                        return "relay." + error;
                }
                if (message.dynamic != null && message.hasOwnProperty("dynamic")) {
                    var error = $root.protos.opts.DynamicOptions.verify(message.dynamic);
                    if (error)
                        return "dynamic." + error;
                }
                if (message.batch != null && message.hasOwnProperty("batch")) {
                    var error = $root.protos.opts.BatchOptions.verify(message.batch);
                    if (error)
                        return "batch." + error;
                }
                if (message.server != null && message.hasOwnProperty("server")) {
                    var error = $root.protos.opts.ServerOptions.verify(message.server);
                    if (error)
                        return "server." + error;
                }
                return null;
            };

            /**
             * Creates a CLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.CLIOptions} CLIOptions
             */
            CLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.CLIOptions)
                    return object;
                var message = new $root.protos.opts.CLIOptions();
                if (object.global != null) {
                    if (typeof object.global !== "object")
                        throw TypeError(".protos.opts.CLIOptions.global: object expected");
                    message.global = $root.protos.opts.GlobalCLIOptions.fromObject(object.global);
                }
                if (object.read != null) {
                    if (typeof object.read !== "object")
                        throw TypeError(".protos.opts.CLIOptions.read: object expected");
                    message.read = $root.protos.opts.ReadOptions.fromObject(object.read);
                }
                if (object.write != null) {
                    if (typeof object.write !== "object")
                        throw TypeError(".protos.opts.CLIOptions.write: object expected");
                    message.write = $root.protos.opts.WriteOptions.fromObject(object.write);
                }
                if (object.relay != null) {
                    if (typeof object.relay !== "object")
                        throw TypeError(".protos.opts.CLIOptions.relay: object expected");
                    message.relay = $root.protos.opts.RelayOptions.fromObject(object.relay);
                }
                if (object.dynamic != null) {
                    if (typeof object.dynamic !== "object")
                        throw TypeError(".protos.opts.CLIOptions.dynamic: object expected");
                    message.dynamic = $root.protos.opts.DynamicOptions.fromObject(object.dynamic);
                }
                if (object.batch != null) {
                    if (typeof object.batch !== "object")
                        throw TypeError(".protos.opts.CLIOptions.batch: object expected");
                    message.batch = $root.protos.opts.BatchOptions.fromObject(object.batch);
                }
                if (object.server != null) {
                    if (typeof object.server !== "object")
                        throw TypeError(".protos.opts.CLIOptions.server: object expected");
                    message.server = $root.protos.opts.ServerOptions.fromObject(object.server);
                }
                return message;
            };

            /**
             * Creates a plain object from a CLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.CLIOptions} message CLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.global = null;
                    object.read = null;
                    object.write = null;
                    object.relay = null;
                    object.dynamic = null;
                    object.batch = null;
                    object.server = null;
                }
                if (message.global != null && message.hasOwnProperty("global"))
                    object.global = $root.protos.opts.GlobalCLIOptions.toObject(message.global, options);
                if (message.read != null && message.hasOwnProperty("read"))
                    object.read = $root.protos.opts.ReadOptions.toObject(message.read, options);
                if (message.write != null && message.hasOwnProperty("write"))
                    object.write = $root.protos.opts.WriteOptions.toObject(message.write, options);
                if (message.relay != null && message.hasOwnProperty("relay"))
                    object.relay = $root.protos.opts.RelayOptions.toObject(message.relay, options);
                if (message.dynamic != null && message.hasOwnProperty("dynamic"))
                    object.dynamic = $root.protos.opts.DynamicOptions.toObject(message.dynamic, options);
                if (message.batch != null && message.hasOwnProperty("batch"))
                    object.batch = $root.protos.opts.BatchOptions.toObject(message.batch, options);
                if (message.server != null && message.hasOwnProperty("server"))
                    object.server = $root.protos.opts.ServerOptions.toObject(message.server, options);
                return object;
            };

            /**
             * Converts this CLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.CLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CLIOptions;
        })();

        opts.DynamicOptions = (function() {

            /**
             * Properties of a DynamicOptions.
             * @memberof protos.opts
             * @interface IDynamicOptions
             * @property {string|null} [apiToken] DynamicOptions apiToken
             * @property {string|null} [_grpcAddress] DynamicOptions _grpcAddress
             * @property {number|null} [_grpcTimeoutSeconds] DynamicOptions _grpcTimeoutSeconds
             * @property {boolean|null} [_grpcInsecure] DynamicOptions _grpcInsecure
             * @property {protos.opts.IDynamicGroupKafkaOptions|null} [kafka] DynamicOptions kafka
             * @property {protos.opts.IDynamicGroupActiveMQOptions|null} [activemq] DynamicOptions activemq
             * @property {protos.opts.IDynamicGroupAWSSQSOptions|null} [awssqs] DynamicOptions awssqs
             * @property {protos.opts.IDynamicGroupAWSSNSOptions|null} [awssns] DynamicOptions awssns
             * @property {protos.opts.IDynamicGroupNatsOptions|null} [nats] DynamicOptions nats
             * @property {protos.opts.IDynamicGroupNatsStreamingOptions|null} [natsStreaming] DynamicOptions natsStreaming
             * @property {protos.opts.IDynamicGroupNSQOptions|null} [nsq] DynamicOptions nsq
             * @property {protos.opts.IDynamicGroupRabbitOptions|null} [rabbit] DynamicOptions rabbit
             * @property {protos.opts.IDynamicGroupMQTTOptions|null} [mqtt] DynamicOptions mqtt
             * @property {protos.opts.IDynamicGroupAzureServiceBusOptions|null} [azureServiceBus] DynamicOptions azureServiceBus
             * @property {protos.opts.IDynamicGroupAzureEventHubOptions|null} [azureEventHub] DynamicOptions azureEventHub
             * @property {protos.opts.IDynamicGroupGCPPubSubOptions|null} [gcpPubsub] DynamicOptions gcpPubsub
             * @property {protos.opts.IDynamicGroupKubeMQQueueOptions|null} [kubemqQueue] DynamicOptions kubemqQueue
             * @property {protos.opts.IDynamicGroupRedisPubSubOptions|null} [redisPubsub] DynamicOptions redisPubsub
             * @property {protos.opts.IDynamicGroupRedisStreamsOptions|null} [redisStreams] DynamicOptions redisStreams
             */

            /**
             * Constructs a new DynamicOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicOptions.
             * @implements IDynamicOptions
             * @constructor
             * @param {protos.opts.IDynamicOptions=} [properties] Properties to set
             */
            function DynamicOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicOptions apiToken.
             * @member {string} apiToken
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.apiToken = "";

            /**
             * DynamicOptions _grpcAddress.
             * @member {string} _grpcAddress
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._grpcAddress = "";

            /**
             * DynamicOptions _grpcTimeoutSeconds.
             * @member {number} _grpcTimeoutSeconds
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._grpcTimeoutSeconds = 0;

            /**
             * DynamicOptions _grpcInsecure.
             * @member {boolean} _grpcInsecure
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._grpcInsecure = false;

            /**
             * DynamicOptions kafka.
             * @member {protos.opts.IDynamicGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.kafka = null;

            /**
             * DynamicOptions activemq.
             * @member {protos.opts.IDynamicGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.activemq = null;

            /**
             * DynamicOptions awssqs.
             * @member {protos.opts.IDynamicGroupAWSSQSOptions|null|undefined} awssqs
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.awssqs = null;

            /**
             * DynamicOptions awssns.
             * @member {protos.opts.IDynamicGroupAWSSNSOptions|null|undefined} awssns
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.awssns = null;

            /**
             * DynamicOptions nats.
             * @member {protos.opts.IDynamicGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.nats = null;

            /**
             * DynamicOptions natsStreaming.
             * @member {protos.opts.IDynamicGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.natsStreaming = null;

            /**
             * DynamicOptions nsq.
             * @member {protos.opts.IDynamicGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.nsq = null;

            /**
             * DynamicOptions rabbit.
             * @member {protos.opts.IDynamicGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.rabbit = null;

            /**
             * DynamicOptions mqtt.
             * @member {protos.opts.IDynamicGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.mqtt = null;

            /**
             * DynamicOptions azureServiceBus.
             * @member {protos.opts.IDynamicGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.azureServiceBus = null;

            /**
             * DynamicOptions azureEventHub.
             * @member {protos.opts.IDynamicGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.azureEventHub = null;

            /**
             * DynamicOptions gcpPubsub.
             * @member {protos.opts.IDynamicGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.gcpPubsub = null;

            /**
             * DynamicOptions kubemqQueue.
             * @member {protos.opts.IDynamicGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.kubemqQueue = null;

            /**
             * DynamicOptions redisPubsub.
             * @member {protos.opts.IDynamicGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.redisPubsub = null;

            /**
             * DynamicOptions redisStreams.
             * @member {protos.opts.IDynamicGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.redisStreams = null;

            /**
             * Creates a new DynamicOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.IDynamicOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicOptions} DynamicOptions instance
             */
            DynamicOptions.create = function create(properties) {
                return new DynamicOptions(properties);
            };

            /**
             * Encodes the specified DynamicOptions message. Does not implicitly {@link protos.opts.DynamicOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.IDynamicOptions} message DynamicOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.apiToken != null && Object.hasOwnProperty.call(message, "apiToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.apiToken);
                if (message._grpcAddress != null && Object.hasOwnProperty.call(message, "_grpcAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message._grpcAddress);
                if (message._grpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "_grpcTimeoutSeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message._grpcTimeoutSeconds);
                if (message._grpcInsecure != null && Object.hasOwnProperty.call(message, "_grpcInsecure"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message._grpcInsecure);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.DynamicGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.DynamicGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.opts.DynamicGroupAWSSQSOptions.encode(message.awssqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awssns != null && Object.hasOwnProperty.call(message, "awssns"))
                    $root.protos.opts.DynamicGroupAWSSNSOptions.encode(message.awssns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.DynamicGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.DynamicGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.DynamicGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.DynamicGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.DynamicGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.DynamicGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.DynamicGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.DynamicGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.DynamicGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.DynamicGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.DynamicGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.IDynamicOptions} message DynamicOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicOptions} DynamicOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.apiToken = reader.string();
                        break;
                    case 2:
                        message._grpcAddress = reader.string();
                        break;
                    case 3:
                        message._grpcTimeoutSeconds = reader.uint32();
                        break;
                    case 4:
                        message._grpcInsecure = reader.bool();
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.DynamicGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.DynamicGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awssqs = $root.protos.opts.DynamicGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awssns = $root.protos.opts.DynamicGroupAWSSNSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.DynamicGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.DynamicGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.DynamicGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.rabbit = $root.protos.opts.DynamicGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.mqtt = $root.protos.opts.DynamicGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.azureServiceBus = $root.protos.opts.DynamicGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.azureEventHub = $root.protos.opts.DynamicGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.gcpPubsub = $root.protos.opts.DynamicGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.kubemqQueue = $root.protos.opts.DynamicGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.redisPubsub = $root.protos.opts.DynamicGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.redisStreams = $root.protos.opts.DynamicGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicOptions} DynamicOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicOptions message.
             * @function verify
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                    if (!$util.isString(message.apiToken))
                        return "apiToken: string expected";
                if (message._grpcAddress != null && message.hasOwnProperty("_grpcAddress"))
                    if (!$util.isString(message._grpcAddress))
                        return "_grpcAddress: string expected";
                if (message._grpcTimeoutSeconds != null && message.hasOwnProperty("_grpcTimeoutSeconds"))
                    if (!$util.isInteger(message._grpcTimeoutSeconds))
                        return "_grpcTimeoutSeconds: integer expected";
                if (message._grpcInsecure != null && message.hasOwnProperty("_grpcInsecure"))
                    if (typeof message._grpcInsecure !== "boolean")
                        return "_grpcInsecure: boolean expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.DynamicGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    var error = $root.protos.opts.DynamicGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    var error = $root.protos.opts.DynamicGroupAWSSQSOptions.verify(message.awssqs);
                    if (error)
                        return "awssqs." + error;
                }
                if (message.awssns != null && message.hasOwnProperty("awssns")) {
                    var error = $root.protos.opts.DynamicGroupAWSSNSOptions.verify(message.awssns);
                    if (error)
                        return "awssns." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.DynamicGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.DynamicGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.DynamicGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.DynamicGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.DynamicGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.DynamicGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.opts.DynamicGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.DynamicGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.DynamicGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.DynamicGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.DynamicGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicOptions} DynamicOptions
             */
            DynamicOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicOptions)
                    return object;
                var message = new $root.protos.opts.DynamicOptions();
                if (object.apiToken != null)
                    message.apiToken = String(object.apiToken);
                if (object._grpcAddress != null)
                    message._grpcAddress = String(object._grpcAddress);
                if (object._grpcTimeoutSeconds != null)
                    message._grpcTimeoutSeconds = object._grpcTimeoutSeconds >>> 0;
                if (object._grpcInsecure != null)
                    message._grpcInsecure = Boolean(object._grpcInsecure);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.DynamicGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.DynamicGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.awssqs: object expected");
                    message.awssqs = $root.protos.opts.DynamicGroupAWSSQSOptions.fromObject(object.awssqs);
                }
                if (object.awssns != null) {
                    if (typeof object.awssns !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.awssns: object expected");
                    message.awssns = $root.protos.opts.DynamicGroupAWSSNSOptions.fromObject(object.awssns);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.nats: object expected");
                    message.nats = $root.protos.opts.DynamicGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.DynamicGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.DynamicGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.DynamicGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.DynamicGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.DynamicGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.DynamicGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.DynamicGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.DynamicGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.DynamicGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.DynamicGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.DynamicOptions} message DynamicOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.apiToken = "";
                    object._grpcAddress = "";
                    object._grpcTimeoutSeconds = 0;
                    object._grpcInsecure = false;
                    object.kafka = null;
                    object.activemq = null;
                    object.awssqs = null;
                    object.awssns = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.rabbit = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                }
                if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                    object.apiToken = message.apiToken;
                if (message._grpcAddress != null && message.hasOwnProperty("_grpcAddress"))
                    object._grpcAddress = message._grpcAddress;
                if (message._grpcTimeoutSeconds != null && message.hasOwnProperty("_grpcTimeoutSeconds"))
                    object._grpcTimeoutSeconds = message._grpcTimeoutSeconds;
                if (message._grpcInsecure != null && message.hasOwnProperty("_grpcInsecure"))
                    object._grpcInsecure = message._grpcInsecure;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.DynamicGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.DynamicGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awssqs != null && message.hasOwnProperty("awssqs"))
                    object.awssqs = $root.protos.opts.DynamicGroupAWSSQSOptions.toObject(message.awssqs, options);
                if (message.awssns != null && message.hasOwnProperty("awssns"))
                    object.awssns = $root.protos.opts.DynamicGroupAWSSNSOptions.toObject(message.awssns, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.DynamicGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.DynamicGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.DynamicGroupNSQOptions.toObject(message.nsq, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.DynamicGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.DynamicGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.DynamicGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.DynamicGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.DynamicGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.DynamicGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.DynamicGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.DynamicGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                return object;
            };

            /**
             * Converts this DynamicOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicOptions;
        })();

        opts.DynamicGroupKafkaOptions = (function() {

            /**
             * Properties of a DynamicGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] DynamicGroupKafkaOptions _conn
             * @property {protos.args.IKafkaWriteArgs|null} [args] DynamicGroupKafkaOptions args
             */

            /**
             * Constructs a new DynamicGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupKafkaOptions.
             * @implements IDynamicGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupKafkaOptions=} [properties] Properties to set
             */
            function DynamicGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @instance
             */
            DynamicGroupKafkaOptions.prototype._conn = null;

            /**
             * DynamicGroupKafkaOptions args.
             * @member {protos.args.IKafkaWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @instance
             */
            DynamicGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.IDynamicGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions instance
             */
            DynamicGroupKafkaOptions.create = function create(properties) {
                return new DynamicGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupKafkaOptions message. Does not implicitly {@link protos.opts.DynamicGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.IDynamicGroupKafkaOptions} message DynamicGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.IDynamicGroupKafkaOptions} message DynamicGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions
             */
            DynamicGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.DynamicGroupKafkaOptions} message DynamicGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupKafkaOptions;
        })();

        opts.DynamicGroupActiveMQOptions = (function() {

            /**
             * Properties of a DynamicGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] DynamicGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQWriteArgs|null} [args] DynamicGroupActiveMQOptions args
             */

            /**
             * Constructs a new DynamicGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupActiveMQOptions.
             * @implements IDynamicGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupActiveMQOptions=} [properties] Properties to set
             */
            function DynamicGroupActiveMQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @instance
             */
            DynamicGroupActiveMQOptions.prototype._conn = null;

            /**
             * DynamicGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @instance
             */
            DynamicGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.IDynamicGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions instance
             */
            DynamicGroupActiveMQOptions.create = function create(properties) {
                return new DynamicGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupActiveMQOptions message. Does not implicitly {@link protos.opts.DynamicGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.IDynamicGroupActiveMQOptions} message DynamicGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.IDynamicGroupActiveMQOptions} message DynamicGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupActiveMQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.ActiveMQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions
             */
            DynamicGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupActiveMQOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.DynamicGroupActiveMQOptions} message DynamicGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupActiveMQOptions;
        })();

        opts.DynamicGroupAWSSQSOptions = (function() {

            /**
             * Properties of a DynamicGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] DynamicGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSWriteArgs|null} [args] DynamicGroupAWSSQSOptions args
             */

            /**
             * Constructs a new DynamicGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAWSSQSOptions.
             * @implements IDynamicGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAWSSQSOptions=} [properties] Properties to set
             */
            function DynamicGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @instance
             */
            DynamicGroupAWSSQSOptions.prototype._conn = null;

            /**
             * DynamicGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @instance
             */
            DynamicGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions instance
             */
            DynamicGroupAWSSQSOptions.create = function create(properties) {
                return new DynamicGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.DynamicGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSQSOptions} message DynamicGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSQSOptions} message DynamicGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions
             */
            DynamicGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.DynamicGroupAWSSQSOptions} message DynamicGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAWSSQSOptions;
        })();

        opts.DynamicGroupAWSSNSOptions = (function() {

            /**
             * Properties of a DynamicGroupAWSSNSOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAWSSNSOptions
             * @property {protos.args.IAWSSNSConn|null} [_conn] DynamicGroupAWSSNSOptions _conn
             * @property {protos.args.IAWSSNSWriteArgs|null} [args] DynamicGroupAWSSNSOptions args
             */

            /**
             * Constructs a new DynamicGroupAWSSNSOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAWSSNSOptions.
             * @implements IDynamicGroupAWSSNSOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAWSSNSOptions=} [properties] Properties to set
             */
            function DynamicGroupAWSSNSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAWSSNSOptions _conn.
             * @member {protos.args.IAWSSNSConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @instance
             */
            DynamicGroupAWSSNSOptions.prototype._conn = null;

            /**
             * DynamicGroupAWSSNSOptions args.
             * @member {protos.args.IAWSSNSWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @instance
             */
            DynamicGroupAWSSNSOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAWSSNSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSNSOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions instance
             */
            DynamicGroupAWSSNSOptions.create = function create(properties) {
                return new DynamicGroupAWSSNSOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAWSSNSOptions message. Does not implicitly {@link protos.opts.DynamicGroupAWSSNSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSNSOptions} message DynamicGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSNSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSNSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSNSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAWSSNSOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAWSSNSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSNSOptions} message DynamicGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSNSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAWSSNSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSNSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAWSSNSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSNSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAWSSNSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSNSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAWSSNSOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAWSSNSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSNSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSNSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAWSSNSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions
             */
            DynamicGroupAWSSNSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAWSSNSOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupAWSSNSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSNSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSNSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSNSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSNSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAWSSNSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.DynamicGroupAWSSNSOptions} message DynamicGroupAWSSNSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAWSSNSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSNSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSNSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAWSSNSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAWSSNSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAWSSNSOptions;
        })();

        opts.DynamicGroupNatsOptions = (function() {

            /**
             * Properties of a DynamicGroupNatsOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] DynamicGroupNatsOptions _conn
             * @property {protos.args.INatsWriteArgs|null} [args] DynamicGroupNatsOptions args
             */

            /**
             * Constructs a new DynamicGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupNatsOptions.
             * @implements IDynamicGroupNatsOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupNatsOptions=} [properties] Properties to set
             */
            function DynamicGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @instance
             */
            DynamicGroupNatsOptions.prototype._conn = null;

            /**
             * DynamicGroupNatsOptions args.
             * @member {protos.args.INatsWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @instance
             */
            DynamicGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions instance
             */
            DynamicGroupNatsOptions.create = function create(properties) {
                return new DynamicGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupNatsOptions message. Does not implicitly {@link protos.opts.DynamicGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsOptions} message DynamicGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsOptions} message DynamicGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions
             */
            DynamicGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.DynamicGroupNatsOptions} message DynamicGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupNatsOptions;
        })();

        opts.DynamicGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a DynamicGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] DynamicGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingWriteArgs|null} [args] DynamicGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new DynamicGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupNatsStreamingOptions.
             * @implements IDynamicGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function DynamicGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @instance
             */
            DynamicGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * DynamicGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @instance
             */
            DynamicGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions instance
             */
            DynamicGroupNatsStreamingOptions.create = function create(properties) {
                return new DynamicGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.DynamicGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions} message DynamicGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions} message DynamicGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions
             */
            DynamicGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.DynamicGroupNatsStreamingOptions} message DynamicGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupNatsStreamingOptions;
        })();

        opts.DynamicGroupNSQOptions = (function() {

            /**
             * Properties of a DynamicGroupNSQOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] DynamicGroupNSQOptions _conn
             * @property {protos.args.INSQWriteArgs|null} [args] DynamicGroupNSQOptions args
             */

            /**
             * Constructs a new DynamicGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupNSQOptions.
             * @implements IDynamicGroupNSQOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupNSQOptions=} [properties] Properties to set
             */
            function DynamicGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @instance
             */
            DynamicGroupNSQOptions.prototype._conn = null;

            /**
             * DynamicGroupNSQOptions args.
             * @member {protos.args.INSQWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @instance
             */
            DynamicGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.IDynamicGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions instance
             */
            DynamicGroupNSQOptions.create = function create(properties) {
                return new DynamicGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupNSQOptions message. Does not implicitly {@link protos.opts.DynamicGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.IDynamicGroupNSQOptions} message DynamicGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.IDynamicGroupNSQOptions} message DynamicGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions
             */
            DynamicGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.DynamicGroupNSQOptions} message DynamicGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupNSQOptions;
        })();

        opts.DynamicGroupRabbitOptions = (function() {

            /**
             * Properties of a DynamicGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] DynamicGroupRabbitOptions _conn
             * @property {protos.args.IRabbitWriteArgs|null} [args] DynamicGroupRabbitOptions args
             */

            /**
             * Constructs a new DynamicGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRabbitOptions.
             * @implements IDynamicGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRabbitOptions=} [properties] Properties to set
             */
            function DynamicGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @instance
             */
            DynamicGroupRabbitOptions.prototype._conn = null;

            /**
             * DynamicGroupRabbitOptions args.
             * @member {protos.args.IRabbitWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @instance
             */
            DynamicGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions instance
             */
            DynamicGroupRabbitOptions.create = function create(properties) {
                return new DynamicGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRabbitOptions message. Does not implicitly {@link protos.opts.DynamicGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitOptions} message DynamicGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitOptions} message DynamicGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions
             */
            DynamicGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.DynamicGroupRabbitOptions} message DynamicGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRabbitOptions;
        })();

        opts.DynamicGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a DynamicGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] DynamicGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsWriteArgs|null} [args] DynamicGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new DynamicGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRabbitStreamsOptions.
             * @implements IDynamicGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function DynamicGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @instance
             */
            DynamicGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * DynamicGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @instance
             */
            DynamicGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions instance
             */
            DynamicGroupRabbitStreamsOptions.create = function create(properties) {
                return new DynamicGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.DynamicGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions} message DynamicGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions} message DynamicGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions
             */
            DynamicGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRabbitStreamsOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.DynamicGroupRabbitStreamsOptions} message DynamicGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRabbitStreamsOptions;
        })();

        opts.DynamicGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a DynamicGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] DynamicGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubWriteArgs|null} [args] DynamicGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new DynamicGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRedisPubSubOptions.
             * @implements IDynamicGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function DynamicGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @instance
             */
            DynamicGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * DynamicGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @instance
             */
            DynamicGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions instance
             */
            DynamicGroupRedisPubSubOptions.create = function create(properties) {
                return new DynamicGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.DynamicGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions} message DynamicGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions} message DynamicGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions
             */
            DynamicGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.DynamicGroupRedisPubSubOptions} message DynamicGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRedisPubSubOptions;
        })();

        opts.DynamicGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a DynamicGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] DynamicGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsWriteArgs|null} [args] DynamicGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new DynamicGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRedisStreamsOptions.
             * @implements IDynamicGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function DynamicGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @instance
             */
            DynamicGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * DynamicGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @instance
             */
            DynamicGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions instance
             */
            DynamicGroupRedisStreamsOptions.create = function create(properties) {
                return new DynamicGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.DynamicGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions} message DynamicGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions} message DynamicGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions
             */
            DynamicGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.DynamicGroupRedisStreamsOptions} message DynamicGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRedisStreamsOptions;
        })();

        opts.DynamicGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a DynamicGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] DynamicGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubWriteArgs|null} [args] DynamicGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new DynamicGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAzureEventHubOptions.
             * @implements IDynamicGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function DynamicGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @instance
             */
            DynamicGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * DynamicGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @instance
             */
            DynamicGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions instance
             */
            DynamicGroupAzureEventHubOptions.create = function create(properties) {
                return new DynamicGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.DynamicGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions} message DynamicGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions} message DynamicGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureEventHubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions
             */
            DynamicGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAzureEventHubOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.DynamicGroupAzureEventHubOptions} message DynamicGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAzureEventHubOptions;
        })();

        opts.DynamicGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a DynamicGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] DynamicGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusWriteArgs|null} [args] DynamicGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new DynamicGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAzureServiceBusOptions.
             * @implements IDynamicGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function DynamicGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @instance
             */
            DynamicGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * DynamicGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @instance
             */
            DynamicGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions instance
             */
            DynamicGroupAzureServiceBusOptions.create = function create(properties) {
                return new DynamicGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.DynamicGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions} message DynamicGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions} message DynamicGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions
             */
            DynamicGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.DynamicGroupAzureServiceBusOptions} message DynamicGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAzureServiceBusOptions;
        })();

        opts.DynamicGroupMQTTOptions = (function() {

            /**
             * Properties of a DynamicGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] DynamicGroupMQTTOptions _conn
             * @property {protos.args.IMQTTWriteArgs|null} [args] DynamicGroupMQTTOptions args
             */

            /**
             * Constructs a new DynamicGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupMQTTOptions.
             * @implements IDynamicGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupMQTTOptions=} [properties] Properties to set
             */
            function DynamicGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @instance
             */
            DynamicGroupMQTTOptions.prototype._conn = null;

            /**
             * DynamicGroupMQTTOptions args.
             * @member {protos.args.IMQTTWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @instance
             */
            DynamicGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.IDynamicGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions instance
             */
            DynamicGroupMQTTOptions.create = function create(properties) {
                return new DynamicGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupMQTTOptions message. Does not implicitly {@link protos.opts.DynamicGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.IDynamicGroupMQTTOptions} message DynamicGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.IDynamicGroupMQTTOptions} message DynamicGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions
             */
            DynamicGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.DynamicGroupMQTTOptions} message DynamicGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupMQTTOptions;
        })();

        opts.DynamicGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a DynamicGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] DynamicGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubWriteArgs|null} [args] DynamicGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new DynamicGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupGCPPubSubOptions.
             * @implements IDynamicGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function DynamicGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @instance
             */
            DynamicGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * DynamicGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @instance
             */
            DynamicGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions instance
             */
            DynamicGroupGCPPubSubOptions.create = function create(properties) {
                return new DynamicGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.DynamicGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions} message DynamicGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions} message DynamicGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions
             */
            DynamicGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.DynamicGroupGCPPubSubOptions} message DynamicGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupGCPPubSubOptions;
        })();

        opts.DynamicGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a DynamicGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] DynamicGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueWriteArgs|null} [args] DynamicGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new DynamicGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupKubeMQQueueOptions.
             * @implements IDynamicGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function DynamicGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @instance
             */
            DynamicGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * DynamicGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @instance
             */
            DynamicGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions instance
             */
            DynamicGroupKubeMQQueueOptions.create = function create(properties) {
                return new DynamicGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.DynamicGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions} message DynamicGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions} message DynamicGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions
             */
            DynamicGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.DynamicGroupKubeMQQueueOptions} message DynamicGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupKubeMQQueueOptions;
        })();

        return opts;
    })();

    protos.PlumberServer = (function() {

        /**
         * Constructs a new PlumberServer service.
         * @memberof protos
         * @classdesc Represents a PlumberServer
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function PlumberServer(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (PlumberServer.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = PlumberServer;

        /**
         * Creates new PlumberServer service using the specified rpc implementation.
         * @function create
         * @memberof protos.PlumberServer
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {PlumberServer} RPC service. Useful where requests and/or responses are streamed.
         */
        PlumberServer.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link protos.PlumberServer#getAllConnections}.
         * @memberof protos.PlumberServer
         * @typedef GetAllConnectionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllConnectionsResponse} [response] GetAllConnectionsResponse
         */

        /**
         * Calls GetAllConnections.
         * @function getAllConnections
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllConnectionsRequest} request GetAllConnectionsRequest message or plain object
         * @param {protos.PlumberServer.GetAllConnectionsCallback} callback Node-style callback called with the error, if any, and GetAllConnectionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllConnections = function getAllConnections(request, callback) {
            return this.rpcCall(getAllConnections, $root.protos.GetAllConnectionsRequest, $root.protos.GetAllConnectionsResponse, request, callback);
        }, "name", { value: "GetAllConnections" });

        /**
         * Calls GetAllConnections.
         * @function getAllConnections
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllConnectionsRequest} request GetAllConnectionsRequest message or plain object
         * @returns {Promise<protos.GetAllConnectionsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getConnection}.
         * @memberof protos.PlumberServer
         * @typedef GetConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetConnectionResponse} [response] GetConnectionResponse
         */

        /**
         * Calls GetConnection.
         * @function getConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetConnectionRequest} request GetConnectionRequest message or plain object
         * @param {protos.PlumberServer.GetConnectionCallback} callback Node-style callback called with the error, if any, and GetConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getConnection = function getConnection(request, callback) {
            return this.rpcCall(getConnection, $root.protos.GetConnectionRequest, $root.protos.GetConnectionResponse, request, callback);
        }, "name", { value: "GetConnection" });

        /**
         * Calls GetConnection.
         * @function getConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetConnectionRequest} request GetConnectionRequest message or plain object
         * @returns {Promise<protos.GetConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createConnection}.
         * @memberof protos.PlumberServer
         * @typedef CreateConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateConnectionResponse} [response] CreateConnectionResponse
         */

        /**
         * Calls CreateConnection.
         * @function createConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateConnectionRequest} request CreateConnectionRequest message or plain object
         * @param {protos.PlumberServer.CreateConnectionCallback} callback Node-style callback called with the error, if any, and CreateConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createConnection = function createConnection(request, callback) {
            return this.rpcCall(createConnection, $root.protos.CreateConnectionRequest, $root.protos.CreateConnectionResponse, request, callback);
        }, "name", { value: "CreateConnection" });

        /**
         * Calls CreateConnection.
         * @function createConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateConnectionRequest} request CreateConnectionRequest message or plain object
         * @returns {Promise<protos.CreateConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#testConnection}.
         * @memberof protos.PlumberServer
         * @typedef TestConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.TestConnectionResponse} [response] TestConnectionResponse
         */

        /**
         * Calls TestConnection.
         * @function testConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ITestConnectionRequest} request TestConnectionRequest message or plain object
         * @param {protos.PlumberServer.TestConnectionCallback} callback Node-style callback called with the error, if any, and TestConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.testConnection = function testConnection(request, callback) {
            return this.rpcCall(testConnection, $root.protos.TestConnectionRequest, $root.protos.TestConnectionResponse, request, callback);
        }, "name", { value: "TestConnection" });

        /**
         * Calls TestConnection.
         * @function testConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ITestConnectionRequest} request TestConnectionRequest message or plain object
         * @returns {Promise<protos.TestConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateConnection}.
         * @memberof protos.PlumberServer
         * @typedef UpdateConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateConnectionResponse} [response] UpdateConnectionResponse
         */

        /**
         * Calls UpdateConnection.
         * @function updateConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateConnectionRequest} request UpdateConnectionRequest message or plain object
         * @param {protos.PlumberServer.UpdateConnectionCallback} callback Node-style callback called with the error, if any, and UpdateConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateConnection = function updateConnection(request, callback) {
            return this.rpcCall(updateConnection, $root.protos.UpdateConnectionRequest, $root.protos.UpdateConnectionResponse, request, callback);
        }, "name", { value: "UpdateConnection" });

        /**
         * Calls UpdateConnection.
         * @function updateConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateConnectionRequest} request UpdateConnectionRequest message or plain object
         * @returns {Promise<protos.UpdateConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteConnection}.
         * @memberof protos.PlumberServer
         * @typedef DeleteConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteConnectionResponse} [response] DeleteConnectionResponse
         */

        /**
         * Calls DeleteConnection.
         * @function deleteConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteConnectionRequest} request DeleteConnectionRequest message or plain object
         * @param {protos.PlumberServer.DeleteConnectionCallback} callback Node-style callback called with the error, if any, and DeleteConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteConnection = function deleteConnection(request, callback) {
            return this.rpcCall(deleteConnection, $root.protos.DeleteConnectionRequest, $root.protos.DeleteConnectionResponse, request, callback);
        }, "name", { value: "DeleteConnection" });

        /**
         * Calls DeleteConnection.
         * @function deleteConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteConnectionRequest} request DeleteConnectionRequest message or plain object
         * @returns {Promise<protos.DeleteConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createRead}.
         * @memberof protos.PlumberServer
         * @typedef CreateReadCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateReadResponse} [response] CreateReadResponse
         */

        /**
         * Calls CreateRead.
         * @function createRead
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateReadRequest} request CreateReadRequest message or plain object
         * @param {protos.PlumberServer.CreateReadCallback} callback Node-style callback called with the error, if any, and CreateReadResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createRead = function createRead(request, callback) {
            return this.rpcCall(createRead, $root.protos.CreateReadRequest, $root.protos.CreateReadResponse, request, callback);
        }, "name", { value: "CreateRead" });

        /**
         * Calls CreateRead.
         * @function createRead
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateReadRequest} request CreateReadRequest message or plain object
         * @returns {Promise<protos.CreateReadResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#startRead}.
         * @memberof protos.PlumberServer
         * @typedef StartReadCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.StartReadResponse} [response] StartReadResponse
         */

        /**
         * Calls StartRead.
         * @function startRead
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStartReadRequest} request StartReadRequest message or plain object
         * @param {protos.PlumberServer.StartReadCallback} callback Node-style callback called with the error, if any, and StartReadResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.startRead = function startRead(request, callback) {
            return this.rpcCall(startRead, $root.protos.StartReadRequest, $root.protos.StartReadResponse, request, callback);
        }, "name", { value: "StartRead" });

        /**
         * Calls StartRead.
         * @function startRead
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStartReadRequest} request StartReadRequest message or plain object
         * @returns {Promise<protos.StartReadResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getAllReads}.
         * @memberof protos.PlumberServer
         * @typedef GetAllReadsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllReadsResponse} [response] GetAllReadsResponse
         */

        /**
         * Calls GetAllReads.
         * @function getAllReads
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllReadsRequest} request GetAllReadsRequest message or plain object
         * @param {protos.PlumberServer.GetAllReadsCallback} callback Node-style callback called with the error, if any, and GetAllReadsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllReads = function getAllReads(request, callback) {
            return this.rpcCall(getAllReads, $root.protos.GetAllReadsRequest, $root.protos.GetAllReadsResponse, request, callback);
        }, "name", { value: "GetAllReads" });

        /**
         * Calls GetAllReads.
         * @function getAllReads
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllReadsRequest} request GetAllReadsRequest message or plain object
         * @returns {Promise<protos.GetAllReadsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#stopRead}.
         * @memberof protos.PlumberServer
         * @typedef StopReadCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.StopReadResponse} [response] StopReadResponse
         */

        /**
         * Calls StopRead.
         * @function stopRead
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopReadRequest} request StopReadRequest message or plain object
         * @param {protos.PlumberServer.StopReadCallback} callback Node-style callback called with the error, if any, and StopReadResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.stopRead = function stopRead(request, callback) {
            return this.rpcCall(stopRead, $root.protos.StopReadRequest, $root.protos.StopReadResponse, request, callback);
        }, "name", { value: "StopRead" });

        /**
         * Calls StopRead.
         * @function stopRead
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopReadRequest} request StopReadRequest message or plain object
         * @returns {Promise<protos.StopReadResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#resumeRead}.
         * @memberof protos.PlumberServer
         * @typedef ResumeReadCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ResumeReadResponse} [response] ResumeReadResponse
         */

        /**
         * Calls ResumeRead.
         * @function resumeRead
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeReadRequest} request ResumeReadRequest message or plain object
         * @param {protos.PlumberServer.ResumeReadCallback} callback Node-style callback called with the error, if any, and ResumeReadResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.resumeRead = function resumeRead(request, callback) {
            return this.rpcCall(resumeRead, $root.protos.ResumeReadRequest, $root.protos.ResumeReadResponse, request, callback);
        }, "name", { value: "ResumeRead" });

        /**
         * Calls ResumeRead.
         * @function resumeRead
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeReadRequest} request ResumeReadRequest message or plain object
         * @returns {Promise<protos.ResumeReadResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteRead}.
         * @memberof protos.PlumberServer
         * @typedef DeleteReadCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteReadResponse} [response] DeleteReadResponse
         */

        /**
         * Calls DeleteRead.
         * @function deleteRead
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteReadRequest} request DeleteReadRequest message or plain object
         * @param {protos.PlumberServer.DeleteReadCallback} callback Node-style callback called with the error, if any, and DeleteReadResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteRead = function deleteRead(request, callback) {
            return this.rpcCall(deleteRead, $root.protos.DeleteReadRequest, $root.protos.DeleteReadResponse, request, callback);
        }, "name", { value: "DeleteRead" });

        /**
         * Calls DeleteRead.
         * @function deleteRead
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteReadRequest} request DeleteReadRequest message or plain object
         * @returns {Promise<protos.DeleteReadResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#write}.
         * @memberof protos.PlumberServer
         * @typedef WriteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.WriteResponse} [response] WriteResponse
         */

        /**
         * Calls Write.
         * @function write
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IWriteRequest} request WriteRequest message or plain object
         * @param {protos.PlumberServer.WriteCallback} callback Node-style callback called with the error, if any, and WriteResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.write = function write(request, callback) {
            return this.rpcCall(write, $root.protos.WriteRequest, $root.protos.WriteResponse, request, callback);
        }, "name", { value: "Write" });

        /**
         * Calls Write.
         * @function write
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IWriteRequest} request WriteRequest message or plain object
         * @returns {Promise<protos.WriteResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createRelay}.
         * @memberof protos.PlumberServer
         * @typedef CreateRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateRelayResponse} [response] CreateRelayResponse
         */

        /**
         * Calls CreateRelay.
         * @function createRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateRelayRequest} request CreateRelayRequest message or plain object
         * @param {protos.PlumberServer.CreateRelayCallback} callback Node-style callback called with the error, if any, and CreateRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createRelay = function createRelay(request, callback) {
            return this.rpcCall(createRelay, $root.protos.CreateRelayRequest, $root.protos.CreateRelayResponse, request, callback);
        }, "name", { value: "CreateRelay" });

        /**
         * Calls CreateRelay.
         * @function createRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateRelayRequest} request CreateRelayRequest message or plain object
         * @returns {Promise<protos.CreateRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateRelay}.
         * @memberof protos.PlumberServer
         * @typedef UpdateRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateRelayResponse} [response] UpdateRelayResponse
         */

        /**
         * Calls UpdateRelay.
         * @function updateRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateRelayRequest} request UpdateRelayRequest message or plain object
         * @param {protos.PlumberServer.UpdateRelayCallback} callback Node-style callback called with the error, if any, and UpdateRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateRelay = function updateRelay(request, callback) {
            return this.rpcCall(updateRelay, $root.protos.UpdateRelayRequest, $root.protos.UpdateRelayResponse, request, callback);
        }, "name", { value: "UpdateRelay" });

        /**
         * Calls UpdateRelay.
         * @function updateRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateRelayRequest} request UpdateRelayRequest message or plain object
         * @returns {Promise<protos.UpdateRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#resumeRelay}.
         * @memberof protos.PlumberServer
         * @typedef ResumeRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ResumeRelayResponse} [response] ResumeRelayResponse
         */

        /**
         * Calls ResumeRelay.
         * @function resumeRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeRelayRequest} request ResumeRelayRequest message or plain object
         * @param {protos.PlumberServer.ResumeRelayCallback} callback Node-style callback called with the error, if any, and ResumeRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.resumeRelay = function resumeRelay(request, callback) {
            return this.rpcCall(resumeRelay, $root.protos.ResumeRelayRequest, $root.protos.ResumeRelayResponse, request, callback);
        }, "name", { value: "ResumeRelay" });

        /**
         * Calls ResumeRelay.
         * @function resumeRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeRelayRequest} request ResumeRelayRequest message or plain object
         * @returns {Promise<protos.ResumeRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#stopRelay}.
         * @memberof protos.PlumberServer
         * @typedef StopRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.StopRelayResponse} [response] StopRelayResponse
         */

        /**
         * Calls StopRelay.
         * @function stopRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopRelayRequest} request StopRelayRequest message or plain object
         * @param {protos.PlumberServer.StopRelayCallback} callback Node-style callback called with the error, if any, and StopRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.stopRelay = function stopRelay(request, callback) {
            return this.rpcCall(stopRelay, $root.protos.StopRelayRequest, $root.protos.StopRelayResponse, request, callback);
        }, "name", { value: "StopRelay" });

        /**
         * Calls StopRelay.
         * @function stopRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopRelayRequest} request StopRelayRequest message or plain object
         * @returns {Promise<protos.StopRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getAllRelays}.
         * @memberof protos.PlumberServer
         * @typedef GetAllRelaysCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllRelaysResponse} [response] GetAllRelaysResponse
         */

        /**
         * Calls GetAllRelays.
         * @function getAllRelays
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllRelaysRequest} request GetAllRelaysRequest message or plain object
         * @param {protos.PlumberServer.GetAllRelaysCallback} callback Node-style callback called with the error, if any, and GetAllRelaysResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllRelays = function getAllRelays(request, callback) {
            return this.rpcCall(getAllRelays, $root.protos.GetAllRelaysRequest, $root.protos.GetAllRelaysResponse, request, callback);
        }, "name", { value: "GetAllRelays" });

        /**
         * Calls GetAllRelays.
         * @function getAllRelays
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllRelaysRequest} request GetAllRelaysRequest message or plain object
         * @returns {Promise<protos.GetAllRelaysResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteRelay}.
         * @memberof protos.PlumberServer
         * @typedef DeleteRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteRelayResponse} [response] DeleteRelayResponse
         */

        /**
         * Calls DeleteRelay.
         * @function deleteRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteRelayRequest} request DeleteRelayRequest message or plain object
         * @param {protos.PlumberServer.DeleteRelayCallback} callback Node-style callback called with the error, if any, and DeleteRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteRelay = function deleteRelay(request, callback) {
            return this.rpcCall(deleteRelay, $root.protos.DeleteRelayRequest, $root.protos.DeleteRelayResponse, request, callback);
        }, "name", { value: "DeleteRelay" });

        /**
         * Calls DeleteRelay.
         * @function deleteRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteRelayRequest} request DeleteRelayRequest message or plain object
         * @returns {Promise<protos.DeleteRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getSchema}.
         * @memberof protos.PlumberServer
         * @typedef GetSchemaCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetSchemaResponse} [response] GetSchemaResponse
         */

        /**
         * Calls GetSchema.
         * @function getSchema
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetSchemaRequest} request GetSchemaRequest message or plain object
         * @param {protos.PlumberServer.GetSchemaCallback} callback Node-style callback called with the error, if any, and GetSchemaResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getSchema = function getSchema(request, callback) {
            return this.rpcCall(getSchema, $root.protos.GetSchemaRequest, $root.protos.GetSchemaResponse, request, callback);
        }, "name", { value: "GetSchema" });

        /**
         * Calls GetSchema.
         * @function getSchema
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetSchemaRequest} request GetSchemaRequest message or plain object
         * @returns {Promise<protos.GetSchemaResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getAllSchemas}.
         * @memberof protos.PlumberServer
         * @typedef GetAllSchemasCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllSchemasResponse} [response] GetAllSchemasResponse
         */

        /**
         * Calls GetAllSchemas.
         * @function getAllSchemas
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllSchemasRequest} request GetAllSchemasRequest message or plain object
         * @param {protos.PlumberServer.GetAllSchemasCallback} callback Node-style callback called with the error, if any, and GetAllSchemasResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllSchemas = function getAllSchemas(request, callback) {
            return this.rpcCall(getAllSchemas, $root.protos.GetAllSchemasRequest, $root.protos.GetAllSchemasResponse, request, callback);
        }, "name", { value: "GetAllSchemas" });

        /**
         * Calls GetAllSchemas.
         * @function getAllSchemas
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllSchemasRequest} request GetAllSchemasRequest message or plain object
         * @returns {Promise<protos.GetAllSchemasResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateSchema}.
         * @memberof protos.PlumberServer
         * @typedef UpdateSchemaCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateSchemaResponse} [response] UpdateSchemaResponse
         */

        /**
         * Calls UpdateSchema.
         * @function updateSchema
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateSchemaRequest} request UpdateSchemaRequest message or plain object
         * @param {protos.PlumberServer.UpdateSchemaCallback} callback Node-style callback called with the error, if any, and UpdateSchemaResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateSchema = function updateSchema(request, callback) {
            return this.rpcCall(updateSchema, $root.protos.UpdateSchemaRequest, $root.protos.UpdateSchemaResponse, request, callback);
        }, "name", { value: "UpdateSchema" });

        /**
         * Calls UpdateSchema.
         * @function updateSchema
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateSchemaRequest} request UpdateSchemaRequest message or plain object
         * @returns {Promise<protos.UpdateSchemaResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#approveSchema}.
         * @memberof protos.PlumberServer
         * @typedef ApproveSchemaCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ApproveSchemaVersionResponse} [response] ApproveSchemaVersionResponse
         */

        /**
         * Calls ApproveSchema.
         * @function approveSchema
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IApproveSchemaVersionRequest} request ApproveSchemaVersionRequest message or plain object
         * @param {protos.PlumberServer.ApproveSchemaCallback} callback Node-style callback called with the error, if any, and ApproveSchemaVersionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.approveSchema = function approveSchema(request, callback) {
            return this.rpcCall(approveSchema, $root.protos.ApproveSchemaVersionRequest, $root.protos.ApproveSchemaVersionResponse, request, callback);
        }, "name", { value: "ApproveSchema" });

        /**
         * Calls ApproveSchema.
         * @function approveSchema
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IApproveSchemaVersionRequest} request ApproveSchemaVersionRequest message or plain object
         * @returns {Promise<protos.ApproveSchemaVersionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#importGithub}.
         * @memberof protos.PlumberServer
         * @typedef ImportGithubCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ImportGithubResponse} [response] ImportGithubResponse
         */

        /**
         * Calls ImportGithub.
         * @function importGithub
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IImportGithubRequest} request ImportGithubRequest message or plain object
         * @param {protos.PlumberServer.ImportGithubCallback} callback Node-style callback called with the error, if any, and ImportGithubResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.importGithub = function importGithub(request, callback) {
            return this.rpcCall(importGithub, $root.protos.ImportGithubRequest, $root.protos.ImportGithubResponse, request, callback);
        }, "name", { value: "ImportGithub" });

        /**
         * Calls ImportGithub.
         * @function importGithub
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IImportGithubRequest} request ImportGithubRequest message or plain object
         * @returns {Promise<protos.ImportGithubResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#importGithubSelect}.
         * @memberof protos.PlumberServer
         * @typedef ImportGithubSelectCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ImportGithubSelectResponse} [response] ImportGithubSelectResponse
         */

        /**
         * Calls ImportGithubSelect.
         * @function importGithubSelect
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IImportGithubSelectRequest} request ImportGithubSelectRequest message or plain object
         * @param {protos.PlumberServer.ImportGithubSelectCallback} callback Node-style callback called with the error, if any, and ImportGithubSelectResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.importGithubSelect = function importGithubSelect(request, callback) {
            return this.rpcCall(importGithubSelect, $root.protos.ImportGithubSelectRequest, $root.protos.ImportGithubSelectResponse, request, callback);
        }, "name", { value: "ImportGithubSelect" });

        /**
         * Calls ImportGithubSelect.
         * @function importGithubSelect
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IImportGithubSelectRequest} request ImportGithubSelectRequest message or plain object
         * @returns {Promise<protos.ImportGithubSelectResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#importLocal}.
         * @memberof protos.PlumberServer
         * @typedef ImportLocalCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ImportLocalResponse} [response] ImportLocalResponse
         */

        /**
         * Calls ImportLocal.
         * @function importLocal
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IImportLocalRequest} request ImportLocalRequest message or plain object
         * @param {protos.PlumberServer.ImportLocalCallback} callback Node-style callback called with the error, if any, and ImportLocalResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.importLocal = function importLocal(request, callback) {
            return this.rpcCall(importLocal, $root.protos.ImportLocalRequest, $root.protos.ImportLocalResponse, request, callback);
        }, "name", { value: "ImportLocal" });

        /**
         * Calls ImportLocal.
         * @function importLocal
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IImportLocalRequest} request ImportLocalRequest message or plain object
         * @returns {Promise<protos.ImportLocalResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteSchema}.
         * @memberof protos.PlumberServer
         * @typedef DeleteSchemaCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteSchemaResponse} [response] DeleteSchemaResponse
         */

        /**
         * Calls DeleteSchema.
         * @function deleteSchema
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteSchemaRequest} request DeleteSchemaRequest message or plain object
         * @param {protos.PlumberServer.DeleteSchemaCallback} callback Node-style callback called with the error, if any, and DeleteSchemaResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteSchema = function deleteSchema(request, callback) {
            return this.rpcCall(deleteSchema, $root.protos.DeleteSchemaRequest, $root.protos.DeleteSchemaResponse, request, callback);
        }, "name", { value: "DeleteSchema" });

        /**
         * Calls DeleteSchema.
         * @function deleteSchema
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteSchemaRequest} request DeleteSchemaRequest message or plain object
         * @returns {Promise<protos.DeleteSchemaResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteSchemaVersion}.
         * @memberof protos.PlumberServer
         * @typedef DeleteSchemaVersionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteSchemaVersionResponse} [response] DeleteSchemaVersionResponse
         */

        /**
         * Calls DeleteSchemaVersion.
         * @function deleteSchemaVersion
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteSchemaVersionRequest} request DeleteSchemaVersionRequest message or plain object
         * @param {protos.PlumberServer.DeleteSchemaVersionCallback} callback Node-style callback called with the error, if any, and DeleteSchemaVersionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteSchemaVersion = function deleteSchemaVersion(request, callback) {
            return this.rpcCall(deleteSchemaVersion, $root.protos.DeleteSchemaVersionRequest, $root.protos.DeleteSchemaVersionResponse, request, callback);
        }, "name", { value: "DeleteSchemaVersion" });

        /**
         * Calls DeleteSchemaVersion.
         * @function deleteSchemaVersion
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteSchemaVersionRequest} request DeleteSchemaVersionRequest message or plain object
         * @returns {Promise<protos.DeleteSchemaVersionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getService}.
         * @memberof protos.PlumberServer
         * @typedef GetServiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetServiceResponse} [response] GetServiceResponse
         */

        /**
         * Calls GetService.
         * @function getService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetServiceRequest} request GetServiceRequest message or plain object
         * @param {protos.PlumberServer.GetServiceCallback} callback Node-style callback called with the error, if any, and GetServiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getService = function getService(request, callback) {
            return this.rpcCall(getService, $root.protos.GetServiceRequest, $root.protos.GetServiceResponse, request, callback);
        }, "name", { value: "GetService" });

        /**
         * Calls GetService.
         * @function getService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetServiceRequest} request GetServiceRequest message or plain object
         * @returns {Promise<protos.GetServiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getAllServices}.
         * @memberof protos.PlumberServer
         * @typedef GetAllServicesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllServicesResponse} [response] GetAllServicesResponse
         */

        /**
         * Calls GetAllServices.
         * @function getAllServices
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllServicesRequest} request GetAllServicesRequest message or plain object
         * @param {protos.PlumberServer.GetAllServicesCallback} callback Node-style callback called with the error, if any, and GetAllServicesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllServices = function getAllServices(request, callback) {
            return this.rpcCall(getAllServices, $root.protos.GetAllServicesRequest, $root.protos.GetAllServicesResponse, request, callback);
        }, "name", { value: "GetAllServices" });

        /**
         * Calls GetAllServices.
         * @function getAllServices
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllServicesRequest} request GetAllServicesRequest message or plain object
         * @returns {Promise<protos.GetAllServicesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createService}.
         * @memberof protos.PlumberServer
         * @typedef CreateServiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateServiceResponse} [response] CreateServiceResponse
         */

        /**
         * Calls CreateService.
         * @function createService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateServiceRequest} request CreateServiceRequest message or plain object
         * @param {protos.PlumberServer.CreateServiceCallback} callback Node-style callback called with the error, if any, and CreateServiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createService = function createService(request, callback) {
            return this.rpcCall(createService, $root.protos.CreateServiceRequest, $root.protos.CreateServiceResponse, request, callback);
        }, "name", { value: "CreateService" });

        /**
         * Calls CreateService.
         * @function createService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateServiceRequest} request CreateServiceRequest message or plain object
         * @returns {Promise<protos.CreateServiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateService}.
         * @memberof protos.PlumberServer
         * @typedef UpdateServiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateServiceResponse} [response] UpdateServiceResponse
         */

        /**
         * Calls UpdateService.
         * @function updateService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateServiceRequest} request UpdateServiceRequest message or plain object
         * @param {protos.PlumberServer.UpdateServiceCallback} callback Node-style callback called with the error, if any, and UpdateServiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateService = function updateService(request, callback) {
            return this.rpcCall(updateService, $root.protos.UpdateServiceRequest, $root.protos.UpdateServiceResponse, request, callback);
        }, "name", { value: "UpdateService" });

        /**
         * Calls UpdateService.
         * @function updateService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateServiceRequest} request UpdateServiceRequest message or plain object
         * @returns {Promise<protos.UpdateServiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteService}.
         * @memberof protos.PlumberServer
         * @typedef DeleteServiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteServiceResponse} [response] DeleteServiceResponse
         */

        /**
         * Calls DeleteService.
         * @function deleteService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteServiceRequest} request DeleteServiceRequest message or plain object
         * @param {protos.PlumberServer.DeleteServiceCallback} callback Node-style callback called with the error, if any, and DeleteServiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteService = function deleteService(request, callback) {
            return this.rpcCall(deleteService, $root.protos.DeleteServiceRequest, $root.protos.DeleteServiceResponse, request, callback);
        }, "name", { value: "DeleteService" });

        /**
         * Calls DeleteService.
         * @function deleteService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteServiceRequest} request DeleteServiceRequest message or plain object
         * @returns {Promise<protos.DeleteServiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#linkSchemaToService}.
         * @memberof protos.PlumberServer
         * @typedef LinkSchemaToServiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.LinkSchemaToServiceResponse} [response] LinkSchemaToServiceResponse
         */

        /**
         * Calls LinkSchemaToService.
         * @function linkSchemaToService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ILinkSchemaToServiceRequest} request LinkSchemaToServiceRequest message or plain object
         * @param {protos.PlumberServer.LinkSchemaToServiceCallback} callback Node-style callback called with the error, if any, and LinkSchemaToServiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.linkSchemaToService = function linkSchemaToService(request, callback) {
            return this.rpcCall(linkSchemaToService, $root.protos.LinkSchemaToServiceRequest, $root.protos.LinkSchemaToServiceResponse, request, callback);
        }, "name", { value: "LinkSchemaToService" });

        /**
         * Calls LinkSchemaToService.
         * @function linkSchemaToService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ILinkSchemaToServiceRequest} request LinkSchemaToServiceRequest message or plain object
         * @returns {Promise<protos.LinkSchemaToServiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#unlinkSchemaFromService}.
         * @memberof protos.PlumberServer
         * @typedef UnlinkSchemaFromServiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UnlinkSchemaFromServiceResponse} [response] UnlinkSchemaFromServiceResponse
         */

        /**
         * Calls UnlinkSchemaFromService.
         * @function unlinkSchemaFromService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUnlinkSchemaFromServiceRequest} request UnlinkSchemaFromServiceRequest message or plain object
         * @param {protos.PlumberServer.UnlinkSchemaFromServiceCallback} callback Node-style callback called with the error, if any, and UnlinkSchemaFromServiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.unlinkSchemaFromService = function unlinkSchemaFromService(request, callback) {
            return this.rpcCall(unlinkSchemaFromService, $root.protos.UnlinkSchemaFromServiceRequest, $root.protos.UnlinkSchemaFromServiceResponse, request, callback);
        }, "name", { value: "UnlinkSchemaFromService" });

        /**
         * Calls UnlinkSchemaFromService.
         * @function unlinkSchemaFromService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUnlinkSchemaFromServiceRequest} request UnlinkSchemaFromServiceRequest message or plain object
         * @returns {Promise<protos.UnlinkSchemaFromServiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#linkRepoToService}.
         * @memberof protos.PlumberServer
         * @typedef LinkRepoToServiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.LinkRepoToServiceResponse} [response] LinkRepoToServiceResponse
         */

        /**
         * Calls LinkRepoToService.
         * @function linkRepoToService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ILinkRepoToServiceRequest} request LinkRepoToServiceRequest message or plain object
         * @param {protos.PlumberServer.LinkRepoToServiceCallback} callback Node-style callback called with the error, if any, and LinkRepoToServiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.linkRepoToService = function linkRepoToService(request, callback) {
            return this.rpcCall(linkRepoToService, $root.protos.LinkRepoToServiceRequest, $root.protos.LinkRepoToServiceResponse, request, callback);
        }, "name", { value: "LinkRepoToService" });

        /**
         * Calls LinkRepoToService.
         * @function linkRepoToService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ILinkRepoToServiceRequest} request LinkRepoToServiceRequest message or plain object
         * @returns {Promise<protos.LinkRepoToServiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#unlinkRepoFromService}.
         * @memberof protos.PlumberServer
         * @typedef UnlinkRepoFromServiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UnlinkRepoFromServiceResponse} [response] UnlinkRepoFromServiceResponse
         */

        /**
         * Calls UnlinkRepoFromService.
         * @function unlinkRepoFromService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUnlinkRepoFromServiceRequest} request UnlinkRepoFromServiceRequest message or plain object
         * @param {protos.PlumberServer.UnlinkRepoFromServiceCallback} callback Node-style callback called with the error, if any, and UnlinkRepoFromServiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.unlinkRepoFromService = function unlinkRepoFromService(request, callback) {
            return this.rpcCall(unlinkRepoFromService, $root.protos.UnlinkRepoFromServiceRequest, $root.protos.UnlinkRepoFromServiceResponse, request, callback);
        }, "name", { value: "UnlinkRepoFromService" });

        /**
         * Calls UnlinkRepoFromService.
         * @function unlinkRepoFromService
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUnlinkRepoFromServiceRequest} request UnlinkRepoFromServiceRequest message or plain object
         * @returns {Promise<protos.UnlinkRepoFromServiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getServerOptions}.
         * @memberof protos.PlumberServer
         * @typedef GetServerOptionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetServerOptionsResponse} [response] GetServerOptionsResponse
         */

        /**
         * Calls GetServerOptions.
         * @function getServerOptions
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetServerOptionsRequest} request GetServerOptionsRequest message or plain object
         * @param {protos.PlumberServer.GetServerOptionsCallback} callback Node-style callback called with the error, if any, and GetServerOptionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getServerOptions = function getServerOptions(request, callback) {
            return this.rpcCall(getServerOptions, $root.protos.GetServerOptionsRequest, $root.protos.GetServerOptionsResponse, request, callback);
        }, "name", { value: "GetServerOptions" });

        /**
         * Calls GetServerOptions.
         * @function getServerOptions
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetServerOptionsRequest} request GetServerOptionsRequest message or plain object
         * @returns {Promise<protos.GetServerOptionsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#setServerOptions}.
         * @memberof protos.PlumberServer
         * @typedef SetServerOptionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.SetServerOptionsResponse} [response] SetServerOptionsResponse
         */

        /**
         * Calls SetServerOptions.
         * @function setServerOptions
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ISetServerOptionsRequest} request SetServerOptionsRequest message or plain object
         * @param {protos.PlumberServer.SetServerOptionsCallback} callback Node-style callback called with the error, if any, and SetServerOptionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.setServerOptions = function setServerOptions(request, callback) {
            return this.rpcCall(setServerOptions, $root.protos.SetServerOptionsRequest, $root.protos.SetServerOptionsResponse, request, callback);
        }, "name", { value: "SetServerOptions" });

        /**
         * Calls SetServerOptions.
         * @function setServerOptions
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ISetServerOptionsRequest} request SetServerOptionsRequest message or plain object
         * @returns {Promise<protos.SetServerOptionsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getRepoList}.
         * @memberof protos.PlumberServer
         * @typedef GetRepoListCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetRepoListResponse} [response] GetRepoListResponse
         */

        /**
         * Calls GetRepoList.
         * @function getRepoList
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetRepoListRequest} request GetRepoListRequest message or plain object
         * @param {protos.PlumberServer.GetRepoListCallback} callback Node-style callback called with the error, if any, and GetRepoListResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getRepoList = function getRepoList(request, callback) {
            return this.rpcCall(getRepoList, $root.protos.GetRepoListRequest, $root.protos.GetRepoListResponse, request, callback);
        }, "name", { value: "GetRepoList" });

        /**
         * Calls GetRepoList.
         * @function getRepoList
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetRepoListRequest} request GetRepoListRequest message or plain object
         * @returns {Promise<protos.GetRepoListResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getVCEvents}.
         * @memberof protos.PlumberServer
         * @typedef GetVCEventsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.VCEvent} [response] VCEvent
         */

        /**
         * Calls GetVCEvents.
         * @function getVCEvents
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetVCEventsRequest} request GetVCEventsRequest message or plain object
         * @param {protos.PlumberServer.GetVCEventsCallback} callback Node-style callback called with the error, if any, and VCEvent
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getVCEvents = function getVCEvents(request, callback) {
            return this.rpcCall(getVCEvents, $root.protos.GetVCEventsRequest, $root.protos.VCEvent, request, callback);
        }, "name", { value: "GetVCEvents" });

        /**
         * Calls GetVCEvents.
         * @function getVCEvents
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetVCEventsRequest} request GetVCEventsRequest message or plain object
         * @returns {Promise<protos.VCEvent>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getRepoTree}.
         * @memberof protos.PlumberServer
         * @typedef GetRepoTreeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetRepoTreeResponse} [response] GetRepoTreeResponse
         */

        /**
         * Calls GetRepoTree.
         * @function getRepoTree
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetRepoTreeRequest} request GetRepoTreeRequest message or plain object
         * @param {protos.PlumberServer.GetRepoTreeCallback} callback Node-style callback called with the error, if any, and GetRepoTreeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getRepoTree = function getRepoTree(request, callback) {
            return this.rpcCall(getRepoTree, $root.protos.GetRepoTreeRequest, $root.protos.GetRepoTreeResponse, request, callback);
        }, "name", { value: "GetRepoTree" });

        /**
         * Calls GetRepoTree.
         * @function getRepoTree
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetRepoTreeRequest} request GetRepoTreeRequest message or plain object
         * @returns {Promise<protos.GetRepoTreeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getRepoFile}.
         * @memberof protos.PlumberServer
         * @typedef GetRepoFileCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetRepoFileResponse} [response] GetRepoFileResponse
         */

        /**
         * Calls GetRepoFile.
         * @function getRepoFile
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetRepoFileRequest} request GetRepoFileRequest message or plain object
         * @param {protos.PlumberServer.GetRepoFileCallback} callback Node-style callback called with the error, if any, and GetRepoFileResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getRepoFile = function getRepoFile(request, callback) {
            return this.rpcCall(getRepoFile, $root.protos.GetRepoFileRequest, $root.protos.GetRepoFileResponse, request, callback);
        }, "name", { value: "GetRepoFile" });

        /**
         * Calls GetRepoFile.
         * @function getRepoFile
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetRepoFileRequest} request GetRepoFileRequest message or plain object
         * @returns {Promise<protos.GetRepoFileResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createPullRequest}.
         * @memberof protos.PlumberServer
         * @typedef CreatePullRequestCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreatePRResponse} [response] CreatePRResponse
         */

        /**
         * Calls CreatePullRequest.
         * @function createPullRequest
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreatePRRequest} request CreatePRRequest message or plain object
         * @param {protos.PlumberServer.CreatePullRequestCallback} callback Node-style callback called with the error, if any, and CreatePRResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createPullRequest = function createPullRequest(request, callback) {
            return this.rpcCall(createPullRequest, $root.protos.CreatePRRequest, $root.protos.CreatePRResponse, request, callback);
        }, "name", { value: "CreatePullRequest" });

        /**
         * Calls CreatePullRequest.
         * @function createPullRequest
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreatePRRequest} request CreatePRRequest message or plain object
         * @returns {Promise<protos.CreatePRResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getMonitor}.
         * @memberof protos.PlumberServer
         * @typedef GetMonitorCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetMonitorResponse} [response] GetMonitorResponse
         */

        /**
         * Calls GetMonitor.
         * @function getMonitor
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetMonitorRequest} request GetMonitorRequest message or plain object
         * @param {protos.PlumberServer.GetMonitorCallback} callback Node-style callback called with the error, if any, and GetMonitorResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getMonitor = function getMonitor(request, callback) {
            return this.rpcCall(getMonitor, $root.protos.GetMonitorRequest, $root.protos.GetMonitorResponse, request, callback);
        }, "name", { value: "GetMonitor" });

        /**
         * Calls GetMonitor.
         * @function getMonitor
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetMonitorRequest} request GetMonitorRequest message or plain object
         * @returns {Promise<protos.GetMonitorResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createMonitor}.
         * @memberof protos.PlumberServer
         * @typedef CreateMonitorCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateMonitorResponse} [response] CreateMonitorResponse
         */

        /**
         * Calls CreateMonitor.
         * @function createMonitor
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateMonitorRequest} request CreateMonitorRequest message or plain object
         * @param {protos.PlumberServer.CreateMonitorCallback} callback Node-style callback called with the error, if any, and CreateMonitorResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createMonitor = function createMonitor(request, callback) {
            return this.rpcCall(createMonitor, $root.protos.CreateMonitorRequest, $root.protos.CreateMonitorResponse, request, callback);
        }, "name", { value: "CreateMonitor" });

        /**
         * Calls CreateMonitor.
         * @function createMonitor
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateMonitorRequest} request CreateMonitorRequest message or plain object
         * @returns {Promise<protos.CreateMonitorResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteMonitor}.
         * @memberof protos.PlumberServer
         * @typedef DeleteMonitorCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteMonitorResponse} [response] DeleteMonitorResponse
         */

        /**
         * Calls DeleteMonitor.
         * @function deleteMonitor
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteMonitorRequest} request DeleteMonitorRequest message or plain object
         * @param {protos.PlumberServer.DeleteMonitorCallback} callback Node-style callback called with the error, if any, and DeleteMonitorResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteMonitor = function deleteMonitor(request, callback) {
            return this.rpcCall(deleteMonitor, $root.protos.DeleteMonitorRequest, $root.protos.DeleteMonitorResponse, request, callback);
        }, "name", { value: "DeleteMonitor" });

        /**
         * Calls DeleteMonitor.
         * @function deleteMonitor
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteMonitorRequest} request DeleteMonitorRequest message or plain object
         * @returns {Promise<protos.DeleteMonitorResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateMonitor}.
         * @memberof protos.PlumberServer
         * @typedef UpdateMonitorCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateMonitorResponse} [response] UpdateMonitorResponse
         */

        /**
         * Calls UpdateMonitor.
         * @function updateMonitor
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateMonitorRequest} request UpdateMonitorRequest message or plain object
         * @param {protos.PlumberServer.UpdateMonitorCallback} callback Node-style callback called with the error, if any, and UpdateMonitorResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateMonitor = function updateMonitor(request, callback) {
            return this.rpcCall(updateMonitor, $root.protos.UpdateMonitorRequest, $root.protos.UpdateMonitorResponse, request, callback);
        }, "name", { value: "UpdateMonitor" });

        /**
         * Calls UpdateMonitor.
         * @function updateMonitor
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateMonitorRequest} request UpdateMonitorRequest message or plain object
         * @returns {Promise<protos.UpdateMonitorResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getAlert}.
         * @memberof protos.PlumberServer
         * @typedef GetAlertCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetMonitorResponse} [response] GetMonitorResponse
         */

        /**
         * Calls GetAlert.
         * @function getAlert
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetMonitorRequest} request GetMonitorRequest message or plain object
         * @param {protos.PlumberServer.GetAlertCallback} callback Node-style callback called with the error, if any, and GetMonitorResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAlert = function getAlert(request, callback) {
            return this.rpcCall(getAlert, $root.protos.GetMonitorRequest, $root.protos.GetMonitorResponse, request, callback);
        }, "name", { value: "GetAlert" });

        /**
         * Calls GetAlert.
         * @function getAlert
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetMonitorRequest} request GetMonitorRequest message or plain object
         * @returns {Promise<protos.GetMonitorResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createAlert}.
         * @memberof protos.PlumberServer
         * @typedef CreateAlertCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateAlertResponse} [response] CreateAlertResponse
         */

        /**
         * Calls CreateAlert.
         * @function createAlert
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateAlertRequest} request CreateAlertRequest message or plain object
         * @param {protos.PlumberServer.CreateAlertCallback} callback Node-style callback called with the error, if any, and CreateAlertResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createAlert = function createAlert(request, callback) {
            return this.rpcCall(createAlert, $root.protos.CreateAlertRequest, $root.protos.CreateAlertResponse, request, callback);
        }, "name", { value: "CreateAlert" });

        /**
         * Calls CreateAlert.
         * @function createAlert
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateAlertRequest} request CreateAlertRequest message or plain object
         * @returns {Promise<protos.CreateAlertResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteAlert}.
         * @memberof protos.PlumberServer
         * @typedef DeleteAlertCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteAlertResponse} [response] DeleteAlertResponse
         */

        /**
         * Calls DeleteAlert.
         * @function deleteAlert
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteAlertRequest} request DeleteAlertRequest message or plain object
         * @param {protos.PlumberServer.DeleteAlertCallback} callback Node-style callback called with the error, if any, and DeleteAlertResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteAlert = function deleteAlert(request, callback) {
            return this.rpcCall(deleteAlert, $root.protos.DeleteAlertRequest, $root.protos.DeleteAlertResponse, request, callback);
        }, "name", { value: "DeleteAlert" });

        /**
         * Calls DeleteAlert.
         * @function deleteAlert
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteAlertRequest} request DeleteAlertRequest message or plain object
         * @returns {Promise<protos.DeleteAlertResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateAlert}.
         * @memberof protos.PlumberServer
         * @typedef UpdateAlertCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateAlertResponse} [response] UpdateAlertResponse
         */

        /**
         * Calls UpdateAlert.
         * @function updateAlert
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateAlertRequest} request UpdateAlertRequest message or plain object
         * @param {protos.PlumberServer.UpdateAlertCallback} callback Node-style callback called with the error, if any, and UpdateAlertResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateAlert = function updateAlert(request, callback) {
            return this.rpcCall(updateAlert, $root.protos.UpdateAlertRequest, $root.protos.UpdateAlertResponse, request, callback);
        }, "name", { value: "UpdateAlert" });

        /**
         * Calls UpdateAlert.
         * @function updateAlert
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateAlertRequest} request UpdateAlertRequest message or plain object
         * @returns {Promise<protos.UpdateAlertResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getValidation}.
         * @memberof protos.PlumberServer
         * @typedef GetValidationCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetValidationResponse} [response] GetValidationResponse
         */

        /**
         * Calls GetValidation.
         * @function getValidation
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetValidationRequest} request GetValidationRequest message or plain object
         * @param {protos.PlumberServer.GetValidationCallback} callback Node-style callback called with the error, if any, and GetValidationResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getValidation = function getValidation(request, callback) {
            return this.rpcCall(getValidation, $root.protos.GetValidationRequest, $root.protos.GetValidationResponse, request, callback);
        }, "name", { value: "GetValidation" });

        /**
         * Calls GetValidation.
         * @function getValidation
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetValidationRequest} request GetValidationRequest message or plain object
         * @returns {Promise<protos.GetValidationResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getAllValidations}.
         * @memberof protos.PlumberServer
         * @typedef GetAllValidationsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllValidationsResponse} [response] GetAllValidationsResponse
         */

        /**
         * Calls GetAllValidations.
         * @function getAllValidations
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllValidationsRequest} request GetAllValidationsRequest message or plain object
         * @param {protos.PlumberServer.GetAllValidationsCallback} callback Node-style callback called with the error, if any, and GetAllValidationsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllValidations = function getAllValidations(request, callback) {
            return this.rpcCall(getAllValidations, $root.protos.GetAllValidationsRequest, $root.protos.GetAllValidationsResponse, request, callback);
        }, "name", { value: "GetAllValidations" });

        /**
         * Calls GetAllValidations.
         * @function getAllValidations
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllValidationsRequest} request GetAllValidationsRequest message or plain object
         * @returns {Promise<protos.GetAllValidationsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createValidation}.
         * @memberof protos.PlumberServer
         * @typedef CreateValidationCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateValidationResponse} [response] CreateValidationResponse
         */

        /**
         * Calls CreateValidation.
         * @function createValidation
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateValidationRequest} request CreateValidationRequest message or plain object
         * @param {protos.PlumberServer.CreateValidationCallback} callback Node-style callback called with the error, if any, and CreateValidationResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createValidation = function createValidation(request, callback) {
            return this.rpcCall(createValidation, $root.protos.CreateValidationRequest, $root.protos.CreateValidationResponse, request, callback);
        }, "name", { value: "CreateValidation" });

        /**
         * Calls CreateValidation.
         * @function createValidation
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateValidationRequest} request CreateValidationRequest message or plain object
         * @returns {Promise<protos.CreateValidationResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateValidation}.
         * @memberof protos.PlumberServer
         * @typedef UpdateValidationCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateValidationResponse} [response] UpdateValidationResponse
         */

        /**
         * Calls UpdateValidation.
         * @function updateValidation
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateValidationRequest} request UpdateValidationRequest message or plain object
         * @param {protos.PlumberServer.UpdateValidationCallback} callback Node-style callback called with the error, if any, and UpdateValidationResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateValidation = function updateValidation(request, callback) {
            return this.rpcCall(updateValidation, $root.protos.UpdateValidationRequest, $root.protos.UpdateValidationResponse, request, callback);
        }, "name", { value: "UpdateValidation" });

        /**
         * Calls UpdateValidation.
         * @function updateValidation
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateValidationRequest} request UpdateValidationRequest message or plain object
         * @returns {Promise<protos.UpdateValidationResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteValidation}.
         * @memberof protos.PlumberServer
         * @typedef DeleteValidationCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteValidationResponse} [response] DeleteValidationResponse
         */

        /**
         * Calls DeleteValidation.
         * @function deleteValidation
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteValidationRequest} request DeleteValidationRequest message or plain object
         * @param {protos.PlumberServer.DeleteValidationCallback} callback Node-style callback called with the error, if any, and DeleteValidationResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteValidation = function deleteValidation(request, callback) {
            return this.rpcCall(deleteValidation, $root.protos.DeleteValidationRequest, $root.protos.DeleteValidationResponse, request, callback);
        }, "name", { value: "DeleteValidation" });

        /**
         * Calls DeleteValidation.
         * @function deleteValidation
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteValidationRequest} request DeleteValidationRequest message or plain object
         * @returns {Promise<protos.DeleteValidationResponse>} Promise
         * @variation 2
         */

        return PlumberServer;
    })();

    protos.GetAllConnectionsRequest = (function() {

        /**
         * Properties of a GetAllConnectionsRequest.
         * @memberof protos
         * @interface IGetAllConnectionsRequest
         * @property {protos.common.IAuth|null} [auth] GetAllConnectionsRequest auth
         */

        /**
         * Constructs a new GetAllConnectionsRequest.
         * @memberof protos
         * @classdesc Represents a GetAllConnectionsRequest.
         * @implements IGetAllConnectionsRequest
         * @constructor
         * @param {protos.IGetAllConnectionsRequest=} [properties] Properties to set
         */
        function GetAllConnectionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllConnectionsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllConnectionsRequest
         * @instance
         */
        GetAllConnectionsRequest.prototype.auth = null;

        /**
         * Creates a new GetAllConnectionsRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.IGetAllConnectionsRequest=} [properties] Properties to set
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest instance
         */
        GetAllConnectionsRequest.create = function create(properties) {
            return new GetAllConnectionsRequest(properties);
        };

        /**
         * Encodes the specified GetAllConnectionsRequest message. Does not implicitly {@link protos.GetAllConnectionsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.IGetAllConnectionsRequest} message GetAllConnectionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllConnectionsRequest message, length delimited. Does not implicitly {@link protos.GetAllConnectionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.IGetAllConnectionsRequest} message GetAllConnectionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllConnectionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllConnectionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllConnectionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllConnectionsRequest message.
         * @function verify
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllConnectionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllConnectionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest
         */
        GetAllConnectionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllConnectionsRequest)
                return object;
            var message = new $root.protos.GetAllConnectionsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllConnectionsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllConnectionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.GetAllConnectionsRequest} message GetAllConnectionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllConnectionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllConnectionsRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllConnectionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllConnectionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllConnectionsRequest;
    })();

    protos.GetAllConnectionsResponse = (function() {

        /**
         * Properties of a GetAllConnectionsResponse.
         * @memberof protos
         * @interface IGetAllConnectionsResponse
         * @property {Array.<protos.opts.IConnectionOptions>|null} [options] GetAllConnectionsResponse options
         */

        /**
         * Constructs a new GetAllConnectionsResponse.
         * @memberof protos
         * @classdesc Represents a GetAllConnectionsResponse.
         * @implements IGetAllConnectionsResponse
         * @constructor
         * @param {protos.IGetAllConnectionsResponse=} [properties] Properties to set
         */
        function GetAllConnectionsResponse(properties) {
            this.options = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllConnectionsResponse options.
         * @member {Array.<protos.opts.IConnectionOptions>} options
         * @memberof protos.GetAllConnectionsResponse
         * @instance
         */
        GetAllConnectionsResponse.prototype.options = $util.emptyArray;

        /**
         * Creates a new GetAllConnectionsResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.IGetAllConnectionsResponse=} [properties] Properties to set
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse instance
         */
        GetAllConnectionsResponse.create = function create(properties) {
            return new GetAllConnectionsResponse(properties);
        };

        /**
         * Encodes the specified GetAllConnectionsResponse message. Does not implicitly {@link protos.GetAllConnectionsResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.IGetAllConnectionsResponse} message GetAllConnectionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && message.options.length)
                for (var i = 0; i < message.options.length; ++i)
                    $root.protos.opts.ConnectionOptions.encode(message.options[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllConnectionsResponse message, length delimited. Does not implicitly {@link protos.GetAllConnectionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.IGetAllConnectionsResponse} message GetAllConnectionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllConnectionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllConnectionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.options && message.options.length))
                        message.options = [];
                    message.options.push($root.protos.opts.ConnectionOptions.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllConnectionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllConnectionsResponse message.
         * @function verify
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllConnectionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                if (!Array.isArray(message.options))
                    return "options: array expected";
                for (var i = 0; i < message.options.length; ++i) {
                    var error = $root.protos.opts.ConnectionOptions.verify(message.options[i]);
                    if (error)
                        return "options." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetAllConnectionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse
         */
        GetAllConnectionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllConnectionsResponse)
                return object;
            var message = new $root.protos.GetAllConnectionsResponse();
            if (object.options) {
                if (!Array.isArray(object.options))
                    throw TypeError(".protos.GetAllConnectionsResponse.options: array expected");
                message.options = [];
                for (var i = 0; i < object.options.length; ++i) {
                    if (typeof object.options[i] !== "object")
                        throw TypeError(".protos.GetAllConnectionsResponse.options: object expected");
                    message.options[i] = $root.protos.opts.ConnectionOptions.fromObject(object.options[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllConnectionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.GetAllConnectionsResponse} message GetAllConnectionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllConnectionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.options = [];
            if (message.options && message.options.length) {
                object.options = [];
                for (var j = 0; j < message.options.length; ++j)
                    object.options[j] = $root.protos.opts.ConnectionOptions.toObject(message.options[j], options);
            }
            return object;
        };

        /**
         * Converts this GetAllConnectionsResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllConnectionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllConnectionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllConnectionsResponse;
    })();

    protos.GetConnectionRequest = (function() {

        /**
         * Properties of a GetConnectionRequest.
         * @memberof protos
         * @interface IGetConnectionRequest
         * @property {protos.common.IAuth|null} [auth] GetConnectionRequest auth
         * @property {string|null} [connectionId] GetConnectionRequest connectionId
         */

        /**
         * Constructs a new GetConnectionRequest.
         * @memberof protos
         * @classdesc Represents a GetConnectionRequest.
         * @implements IGetConnectionRequest
         * @constructor
         * @param {protos.IGetConnectionRequest=} [properties] Properties to set
         */
        function GetConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetConnectionRequest
         * @instance
         */
        GetConnectionRequest.prototype.auth = null;

        /**
         * GetConnectionRequest connectionId.
         * @member {string} connectionId
         * @memberof protos.GetConnectionRequest
         * @instance
         */
        GetConnectionRequest.prototype.connectionId = "";

        /**
         * Creates a new GetConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.IGetConnectionRequest=} [properties] Properties to set
         * @returns {protos.GetConnectionRequest} GetConnectionRequest instance
         */
        GetConnectionRequest.create = function create(properties) {
            return new GetConnectionRequest(properties);
        };

        /**
         * Encodes the specified GetConnectionRequest message. Does not implicitly {@link protos.GetConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.IGetConnectionRequest} message GetConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetConnectionRequest message, length delimited. Does not implicitly {@link protos.GetConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.IGetConnectionRequest} message GetConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetConnectionRequest} GetConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetConnectionRequest} GetConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetConnectionRequest message.
         * @function verify
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            return null;
        };

        /**
         * Creates a GetConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetConnectionRequest} GetConnectionRequest
         */
        GetConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetConnectionRequest)
                return object;
            var message = new $root.protos.GetConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            return message;
        };

        /**
         * Creates a plain object from a GetConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.GetConnectionRequest} message GetConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.connectionId = "";
                object.auth = null;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.GetConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetConnectionRequest;
    })();

    protos.GetConnectionResponse = (function() {

        /**
         * Properties of a GetConnectionResponse.
         * @memberof protos
         * @interface IGetConnectionResponse
         * @property {protos.opts.IConnectionOptions|null} [options] GetConnectionResponse options
         */

        /**
         * Constructs a new GetConnectionResponse.
         * @memberof protos
         * @classdesc Represents a GetConnectionResponse.
         * @implements IGetConnectionResponse
         * @constructor
         * @param {protos.IGetConnectionResponse=} [properties] Properties to set
         */
        function GetConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetConnectionResponse options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.GetConnectionResponse
         * @instance
         */
        GetConnectionResponse.prototype.options = null;

        /**
         * Creates a new GetConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.IGetConnectionResponse=} [properties] Properties to set
         * @returns {protos.GetConnectionResponse} GetConnectionResponse instance
         */
        GetConnectionResponse.create = function create(properties) {
            return new GetConnectionResponse(properties);
        };

        /**
         * Encodes the specified GetConnectionResponse message. Does not implicitly {@link protos.GetConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.IGetConnectionResponse} message GetConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetConnectionResponse message, length delimited. Does not implicitly {@link protos.GetConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.IGetConnectionResponse} message GetConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetConnectionResponse} GetConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetConnectionResponse} GetConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetConnectionResponse message.
         * @function verify
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a GetConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetConnectionResponse} GetConnectionResponse
         */
        GetConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetConnectionResponse)
                return object;
            var message = new $root.protos.GetConnectionResponse();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.GetConnectionResponse.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.GetConnectionResponse} message GetConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.options = null;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this GetConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.GetConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetConnectionResponse;
    })();

    protos.CreateConnectionRequest = (function() {

        /**
         * Properties of a CreateConnectionRequest.
         * @memberof protos
         * @interface ICreateConnectionRequest
         * @property {protos.common.IAuth|null} [auth] CreateConnectionRequest auth
         * @property {protos.opts.IConnectionOptions|null} [options] CreateConnectionRequest options
         */

        /**
         * Constructs a new CreateConnectionRequest.
         * @memberof protos
         * @classdesc Represents a CreateConnectionRequest.
         * @implements ICreateConnectionRequest
         * @constructor
         * @param {protos.ICreateConnectionRequest=} [properties] Properties to set
         */
        function CreateConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateConnectionRequest
         * @instance
         */
        CreateConnectionRequest.prototype.auth = null;

        /**
         * CreateConnectionRequest options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.CreateConnectionRequest
         * @instance
         */
        CreateConnectionRequest.prototype.options = null;

        /**
         * Creates a new CreateConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.ICreateConnectionRequest=} [properties] Properties to set
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest instance
         */
        CreateConnectionRequest.create = function create(properties) {
            return new CreateConnectionRequest(properties);
        };

        /**
         * Encodes the specified CreateConnectionRequest message. Does not implicitly {@link protos.CreateConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.ICreateConnectionRequest} message CreateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateConnectionRequest message, length delimited. Does not implicitly {@link protos.CreateConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.ICreateConnectionRequest} message CreateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateConnectionRequest message.
         * @function verify
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a CreateConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest
         */
        CreateConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateConnectionRequest)
                return object;
            var message = new $root.protos.CreateConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.CreateConnectionRequest.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.CreateConnectionRequest} message CreateConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.options = null;
                object.auth = null;
            }
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateConnectionRequest;
    })();

    protos.CreateConnectionResponse = (function() {

        /**
         * Properties of a CreateConnectionResponse.
         * @memberof protos
         * @interface ICreateConnectionResponse
         * @property {string|null} [connectionId] CreateConnectionResponse connectionId
         */

        /**
         * Constructs a new CreateConnectionResponse.
         * @memberof protos
         * @classdesc Represents a CreateConnectionResponse.
         * @implements ICreateConnectionResponse
         * @constructor
         * @param {protos.ICreateConnectionResponse=} [properties] Properties to set
         */
        function CreateConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateConnectionResponse connectionId.
         * @member {string} connectionId
         * @memberof protos.CreateConnectionResponse
         * @instance
         */
        CreateConnectionResponse.prototype.connectionId = "";

        /**
         * Creates a new CreateConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.ICreateConnectionResponse=} [properties] Properties to set
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse instance
         */
        CreateConnectionResponse.create = function create(properties) {
            return new CreateConnectionResponse(properties);
        };

        /**
         * Encodes the specified CreateConnectionResponse message. Does not implicitly {@link protos.CreateConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.ICreateConnectionResponse} message CreateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            return writer;
        };

        /**
         * Encodes the specified CreateConnectionResponse message, length delimited. Does not implicitly {@link protos.CreateConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.ICreateConnectionResponse} message CreateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateConnectionResponse message.
         * @function verify
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            return null;
        };

        /**
         * Creates a CreateConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse
         */
        CreateConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateConnectionResponse)
                return object;
            var message = new $root.protos.CreateConnectionResponse();
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            return message;
        };

        /**
         * Creates a plain object from a CreateConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.CreateConnectionResponse} message CreateConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.connectionId = "";
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            return object;
        };

        /**
         * Converts this CreateConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateConnectionResponse;
    })();

    protos.TestConnectionRequest = (function() {

        /**
         * Properties of a TestConnectionRequest.
         * @memberof protos
         * @interface ITestConnectionRequest
         * @property {protos.common.IAuth|null} [auth] TestConnectionRequest auth
         * @property {protos.opts.IConnectionOptions|null} [options] TestConnectionRequest options
         */

        /**
         * Constructs a new TestConnectionRequest.
         * @memberof protos
         * @classdesc Represents a TestConnectionRequest.
         * @implements ITestConnectionRequest
         * @constructor
         * @param {protos.ITestConnectionRequest=} [properties] Properties to set
         */
        function TestConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.TestConnectionRequest
         * @instance
         */
        TestConnectionRequest.prototype.auth = null;

        /**
         * TestConnectionRequest options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.TestConnectionRequest
         * @instance
         */
        TestConnectionRequest.prototype.options = null;

        /**
         * Creates a new TestConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.ITestConnectionRequest=} [properties] Properties to set
         * @returns {protos.TestConnectionRequest} TestConnectionRequest instance
         */
        TestConnectionRequest.create = function create(properties) {
            return new TestConnectionRequest(properties);
        };

        /**
         * Encodes the specified TestConnectionRequest message. Does not implicitly {@link protos.TestConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.ITestConnectionRequest} message TestConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TestConnectionRequest message, length delimited. Does not implicitly {@link protos.TestConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.ITestConnectionRequest} message TestConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.TestConnectionRequest} TestConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.TestConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.TestConnectionRequest} TestConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestConnectionRequest message.
         * @function verify
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a TestConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.TestConnectionRequest} TestConnectionRequest
         */
        TestConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.TestConnectionRequest)
                return object;
            var message = new $root.protos.TestConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.TestConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.TestConnectionRequest.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a TestConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.TestConnectionRequest} message TestConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.options = null;
                object.auth = null;
            }
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this TestConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.TestConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TestConnectionRequest;
    })();

    protos.TestConnectionResponse = (function() {

        /**
         * Properties of a TestConnectionResponse.
         * @memberof protos
         * @interface ITestConnectionResponse
         * @property {protos.common.IStatus|null} [status] TestConnectionResponse status
         */

        /**
         * Constructs a new TestConnectionResponse.
         * @memberof protos
         * @classdesc Represents a TestConnectionResponse.
         * @implements ITestConnectionResponse
         * @constructor
         * @param {protos.ITestConnectionResponse=} [properties] Properties to set
         */
        function TestConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestConnectionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.TestConnectionResponse
         * @instance
         */
        TestConnectionResponse.prototype.status = null;

        /**
         * Creates a new TestConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.ITestConnectionResponse=} [properties] Properties to set
         * @returns {protos.TestConnectionResponse} TestConnectionResponse instance
         */
        TestConnectionResponse.create = function create(properties) {
            return new TestConnectionResponse(properties);
        };

        /**
         * Encodes the specified TestConnectionResponse message. Does not implicitly {@link protos.TestConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.ITestConnectionResponse} message TestConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TestConnectionResponse message, length delimited. Does not implicitly {@link protos.TestConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.ITestConnectionResponse} message TestConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.TestConnectionResponse} TestConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.TestConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.TestConnectionResponse} TestConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestConnectionResponse message.
         * @function verify
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a TestConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.TestConnectionResponse} TestConnectionResponse
         */
        TestConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.TestConnectionResponse)
                return object;
            var message = new $root.protos.TestConnectionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.TestConnectionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a TestConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.TestConnectionResponse} message TestConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this TestConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.TestConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TestConnectionResponse;
    })();

    protos.UpdateConnectionRequest = (function() {

        /**
         * Properties of an UpdateConnectionRequest.
         * @memberof protos
         * @interface IUpdateConnectionRequest
         * @property {protos.common.IAuth|null} [auth] UpdateConnectionRequest auth
         * @property {string|null} [connectionId] UpdateConnectionRequest connectionId
         * @property {protos.opts.IConnectionOptions|null} [options] UpdateConnectionRequest options
         */

        /**
         * Constructs a new UpdateConnectionRequest.
         * @memberof protos
         * @classdesc Represents an UpdateConnectionRequest.
         * @implements IUpdateConnectionRequest
         * @constructor
         * @param {protos.IUpdateConnectionRequest=} [properties] Properties to set
         */
        function UpdateConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateConnectionRequest
         * @instance
         */
        UpdateConnectionRequest.prototype.auth = null;

        /**
         * UpdateConnectionRequest connectionId.
         * @member {string} connectionId
         * @memberof protos.UpdateConnectionRequest
         * @instance
         */
        UpdateConnectionRequest.prototype.connectionId = "";

        /**
         * UpdateConnectionRequest options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.UpdateConnectionRequest
         * @instance
         */
        UpdateConnectionRequest.prototype.options = null;

        /**
         * Creates a new UpdateConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.IUpdateConnectionRequest=} [properties] Properties to set
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest instance
         */
        UpdateConnectionRequest.create = function create(properties) {
            return new UpdateConnectionRequest(properties);
        };

        /**
         * Encodes the specified UpdateConnectionRequest message. Does not implicitly {@link protos.UpdateConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.IUpdateConnectionRequest} message UpdateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateConnectionRequest message, length delimited. Does not implicitly {@link protos.UpdateConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.IUpdateConnectionRequest} message UpdateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.connectionId = reader.string();
                    break;
                case 2:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateConnectionRequest message.
         * @function verify
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest
         */
        UpdateConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateConnectionRequest)
                return object;
            var message = new $root.protos.UpdateConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.UpdateConnectionRequest.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.UpdateConnectionRequest} message UpdateConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.connectionId = "";
                object.options = null;
                object.auth = null;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateConnectionRequest;
    })();

    protos.UpdateConnectionResponse = (function() {

        /**
         * Properties of an UpdateConnectionResponse.
         * @memberof protos
         * @interface IUpdateConnectionResponse
         * @property {protos.common.IStatus|null} [status] UpdateConnectionResponse status
         */

        /**
         * Constructs a new UpdateConnectionResponse.
         * @memberof protos
         * @classdesc Represents an UpdateConnectionResponse.
         * @implements IUpdateConnectionResponse
         * @constructor
         * @param {protos.IUpdateConnectionResponse=} [properties] Properties to set
         */
        function UpdateConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateConnectionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateConnectionResponse
         * @instance
         */
        UpdateConnectionResponse.prototype.status = null;

        /**
         * Creates a new UpdateConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.IUpdateConnectionResponse=} [properties] Properties to set
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse instance
         */
        UpdateConnectionResponse.create = function create(properties) {
            return new UpdateConnectionResponse(properties);
        };

        /**
         * Encodes the specified UpdateConnectionResponse message. Does not implicitly {@link protos.UpdateConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.IUpdateConnectionResponse} message UpdateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateConnectionResponse message, length delimited. Does not implicitly {@link protos.UpdateConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.IUpdateConnectionResponse} message UpdateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateConnectionResponse message.
         * @function verify
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse
         */
        UpdateConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateConnectionResponse)
                return object;
            var message = new $root.protos.UpdateConnectionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateConnectionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.UpdateConnectionResponse} message UpdateConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateConnectionResponse;
    })();

    protos.DeleteConnectionRequest = (function() {

        /**
         * Properties of a DeleteConnectionRequest.
         * @memberof protos
         * @interface IDeleteConnectionRequest
         * @property {protos.common.IAuth|null} [auth] DeleteConnectionRequest auth
         * @property {string|null} [connectionId] DeleteConnectionRequest connectionId
         */

        /**
         * Constructs a new DeleteConnectionRequest.
         * @memberof protos
         * @classdesc Represents a DeleteConnectionRequest.
         * @implements IDeleteConnectionRequest
         * @constructor
         * @param {protos.IDeleteConnectionRequest=} [properties] Properties to set
         */
        function DeleteConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteConnectionRequest
         * @instance
         */
        DeleteConnectionRequest.prototype.auth = null;

        /**
         * DeleteConnectionRequest connectionId.
         * @member {string} connectionId
         * @memberof protos.DeleteConnectionRequest
         * @instance
         */
        DeleteConnectionRequest.prototype.connectionId = "";

        /**
         * Creates a new DeleteConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.IDeleteConnectionRequest=} [properties] Properties to set
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest instance
         */
        DeleteConnectionRequest.create = function create(properties) {
            return new DeleteConnectionRequest(properties);
        };

        /**
         * Encodes the specified DeleteConnectionRequest message. Does not implicitly {@link protos.DeleteConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.IDeleteConnectionRequest} message DeleteConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteConnectionRequest message, length delimited. Does not implicitly {@link protos.DeleteConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.IDeleteConnectionRequest} message DeleteConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteConnectionRequest message.
         * @function verify
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            return null;
        };

        /**
         * Creates a DeleteConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest
         */
        DeleteConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteConnectionRequest)
                return object;
            var message = new $root.protos.DeleteConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.DeleteConnectionRequest} message DeleteConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.connectionId = "";
                object.auth = null;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteConnectionRequest;
    })();

    protos.DeleteConnectionResponse = (function() {

        /**
         * Properties of a DeleteConnectionResponse.
         * @memberof protos
         * @interface IDeleteConnectionResponse
         * @property {protos.common.IStatus|null} [status] DeleteConnectionResponse status
         */

        /**
         * Constructs a new DeleteConnectionResponse.
         * @memberof protos
         * @classdesc Represents a DeleteConnectionResponse.
         * @implements IDeleteConnectionResponse
         * @constructor
         * @param {protos.IDeleteConnectionResponse=} [properties] Properties to set
         */
        function DeleteConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteConnectionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteConnectionResponse
         * @instance
         */
        DeleteConnectionResponse.prototype.status = null;

        /**
         * Creates a new DeleteConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.IDeleteConnectionResponse=} [properties] Properties to set
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse instance
         */
        DeleteConnectionResponse.create = function create(properties) {
            return new DeleteConnectionResponse(properties);
        };

        /**
         * Encodes the specified DeleteConnectionResponse message. Does not implicitly {@link protos.DeleteConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.IDeleteConnectionResponse} message DeleteConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteConnectionResponse message, length delimited. Does not implicitly {@link protos.DeleteConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.IDeleteConnectionResponse} message DeleteConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteConnectionResponse message.
         * @function verify
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse
         */
        DeleteConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteConnectionResponse)
                return object;
            var message = new $root.protos.DeleteConnectionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteConnectionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.DeleteConnectionResponse} message DeleteConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteConnectionResponse;
    })();

    protos.args = (function() {

        /**
         * Namespace args.
         * @memberof protos
         * @namespace
         */
        var args = {};

        /**
         * SASLType enum.
         * @name protos.args.SASLType
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} PLAIN=1 PLAIN value
         * @property {number} SCRAM=2 SCRAM value
         */
        args.SASLType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "PLAIN"] = 1;
            values[valuesById[2] = "SCRAM"] = 2;
            return values;
        })();

        args.KafkaConn = (function() {

            /**
             * Properties of a KafkaConn.
             * @memberof protos.args
             * @interface IKafkaConn
             * @property {Array.<string>|null} [address] KafkaConn address
             * @property {number|null} [timeoutSeconds] KafkaConn timeoutSeconds
             * @property {boolean|null} [useTls] KafkaConn useTls
             * @property {boolean|null} [insecureTls] KafkaConn insecureTls
             * @property {protos.args.SASLType|null} [saslType] KafkaConn saslType
             * @property {string|null} [saslUsername] KafkaConn saslUsername
             * @property {string|null} [saslPassword] KafkaConn saslPassword
             */

            /**
             * Constructs a new KafkaConn.
             * @memberof protos.args
             * @classdesc Represents a KafkaConn.
             * @implements IKafkaConn
             * @constructor
             * @param {protos.args.IKafkaConn=} [properties] Properties to set
             */
            function KafkaConn(properties) {
                this.address = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaConn address.
             * @member {Array.<string>} address
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.address = $util.emptyArray;

            /**
             * KafkaConn timeoutSeconds.
             * @member {number} timeoutSeconds
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.timeoutSeconds = 0;

            /**
             * KafkaConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.useTls = false;

            /**
             * KafkaConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.insecureTls = false;

            /**
             * KafkaConn saslType.
             * @member {protos.args.SASLType} saslType
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslType = 0;

            /**
             * KafkaConn saslUsername.
             * @member {string} saslUsername
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslUsername = "";

            /**
             * KafkaConn saslPassword.
             * @member {string} saslPassword
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslPassword = "";

            /**
             * Creates a new KafkaConn instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn=} [properties] Properties to set
             * @returns {protos.args.KafkaConn} KafkaConn instance
             */
            KafkaConn.create = function create(properties) {
                return new KafkaConn(properties);
            };

            /**
             * Encodes the specified KafkaConn message. Does not implicitly {@link protos.args.KafkaConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn} message KafkaConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && message.address.length)
                    for (var i = 0; i < message.address.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address[i]);
                if (message.timeoutSeconds != null && Object.hasOwnProperty.call(message, "timeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.timeoutSeconds);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useTls);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.insecureTls);
                if (message.saslType != null && Object.hasOwnProperty.call(message, "saslType"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.saslType);
                if (message.saslUsername != null && Object.hasOwnProperty.call(message, "saslUsername"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.saslUsername);
                if (message.saslPassword != null && Object.hasOwnProperty.call(message, "saslPassword"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.saslPassword);
                return writer;
            };

            /**
             * Encodes the specified KafkaConn message, length delimited. Does not implicitly {@link protos.args.KafkaConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn} message KafkaConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaConn} KafkaConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.address && message.address.length))
                            message.address = [];
                        message.address.push(reader.string());
                        break;
                    case 2:
                        message.timeoutSeconds = reader.int32();
                        break;
                    case 3:
                        message.useTls = reader.bool();
                        break;
                    case 4:
                        message.insecureTls = reader.bool();
                        break;
                    case 5:
                        message.saslType = reader.int32();
                        break;
                    case 6:
                        message.saslUsername = reader.string();
                        break;
                    case 7:
                        message.saslPassword = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaConn} KafkaConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaConn message.
             * @function verify
             * @memberof protos.args.KafkaConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address")) {
                    if (!Array.isArray(message.address))
                        return "address: array expected";
                    for (var i = 0; i < message.address.length; ++i)
                        if (!$util.isString(message.address[i]))
                            return "address: string[] expected";
                }
                if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                    if (!$util.isInteger(message.timeoutSeconds))
                        return "timeoutSeconds: integer expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.saslType != null && message.hasOwnProperty("saslType"))
                    switch (message.saslType) {
                    default:
                        return "saslType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.saslUsername != null && message.hasOwnProperty("saslUsername"))
                    if (!$util.isString(message.saslUsername))
                        return "saslUsername: string expected";
                if (message.saslPassword != null && message.hasOwnProperty("saslPassword"))
                    if (!$util.isString(message.saslPassword))
                        return "saslPassword: string expected";
                return null;
            };

            /**
             * Creates a KafkaConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaConn} KafkaConn
             */
            KafkaConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaConn)
                    return object;
                var message = new $root.protos.args.KafkaConn();
                if (object.address) {
                    if (!Array.isArray(object.address))
                        throw TypeError(".protos.args.KafkaConn.address: array expected");
                    message.address = [];
                    for (var i = 0; i < object.address.length; ++i)
                        message.address[i] = String(object.address[i]);
                }
                if (object.timeoutSeconds != null)
                    message.timeoutSeconds = object.timeoutSeconds | 0;
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                switch (object.saslType) {
                case "NONE":
                case 0:
                    message.saslType = 0;
                    break;
                case "PLAIN":
                case 1:
                    message.saslType = 1;
                    break;
                case "SCRAM":
                case 2:
                    message.saslType = 2;
                    break;
                }
                if (object.saslUsername != null)
                    message.saslUsername = String(object.saslUsername);
                if (object.saslPassword != null)
                    message.saslPassword = String(object.saslPassword);
                return message;
            };

            /**
             * Creates a plain object from a KafkaConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.KafkaConn} message KafkaConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.address = [];
                if (options.defaults) {
                    object.timeoutSeconds = 0;
                    object.useTls = false;
                    object.insecureTls = false;
                    object.saslType = options.enums === String ? "NONE" : 0;
                    object.saslUsername = "";
                    object.saslPassword = "";
                }
                if (message.address && message.address.length) {
                    object.address = [];
                    for (var j = 0; j < message.address.length; ++j)
                        object.address[j] = message.address[j];
                }
                if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                    object.timeoutSeconds = message.timeoutSeconds;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.saslType != null && message.hasOwnProperty("saslType"))
                    object.saslType = options.enums === String ? $root.protos.args.SASLType[message.saslType] : message.saslType;
                if (message.saslUsername != null && message.hasOwnProperty("saslUsername"))
                    object.saslUsername = message.saslUsername;
                if (message.saslPassword != null && message.hasOwnProperty("saslPassword"))
                    object.saslPassword = message.saslPassword;
                return object;
            };

            /**
             * Converts this KafkaConn to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaConn;
        })();

        args.KafkaReadArgs = (function() {

            /**
             * Properties of a KafkaReadArgs.
             * @memberof protos.args
             * @interface IKafkaReadArgs
             * @property {Array.<string>|null} [topics] KafkaReadArgs topics
             * @property {number|Long|null} [readOffset] KafkaReadArgs readOffset
             * @property {boolean|null} [useConsumerGroup] KafkaReadArgs useConsumerGroup
             * @property {string|null} [consumerGroupName] KafkaReadArgs consumerGroupName
             * @property {number|null} [maxWaitSeconds] KafkaReadArgs maxWaitSeconds
             * @property {number|null} [minBytes] KafkaReadArgs minBytes
             * @property {number|null} [maxBytes] KafkaReadArgs maxBytes
             * @property {number|null} [commitIntervalSeconds] KafkaReadArgs commitIntervalSeconds
             * @property {number|null} [rebalanceTimeoutSeconds] KafkaReadArgs rebalanceTimeoutSeconds
             * @property {number|null} [queueCapacity] KafkaReadArgs queueCapacity
             * @property {boolean|null} [includeOffsetInfo] KafkaReadArgs includeOffsetInfo
             * @property {boolean|null} [lag] KafkaReadArgs lag
             * @property {string|null} [lagConsumerGroup] KafkaReadArgs lagConsumerGroup
             */

            /**
             * Constructs a new KafkaReadArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaReadArgs.
             * @implements IKafkaReadArgs
             * @constructor
             * @param {protos.args.IKafkaReadArgs=} [properties] Properties to set
             */
            function KafkaReadArgs(properties) {
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaReadArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.topics = $util.emptyArray;

            /**
             * KafkaReadArgs readOffset.
             * @member {number|Long} readOffset
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.readOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KafkaReadArgs useConsumerGroup.
             * @member {boolean} useConsumerGroup
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.useConsumerGroup = false;

            /**
             * KafkaReadArgs consumerGroupName.
             * @member {string} consumerGroupName
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.consumerGroupName = "";

            /**
             * KafkaReadArgs maxWaitSeconds.
             * @member {number} maxWaitSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.maxWaitSeconds = 0;

            /**
             * KafkaReadArgs minBytes.
             * @member {number} minBytes
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.minBytes = 0;

            /**
             * KafkaReadArgs maxBytes.
             * @member {number} maxBytes
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.maxBytes = 0;

            /**
             * KafkaReadArgs commitIntervalSeconds.
             * @member {number} commitIntervalSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.commitIntervalSeconds = 0;

            /**
             * KafkaReadArgs rebalanceTimeoutSeconds.
             * @member {number} rebalanceTimeoutSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.rebalanceTimeoutSeconds = 0;

            /**
             * KafkaReadArgs queueCapacity.
             * @member {number} queueCapacity
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.queueCapacity = 0;

            /**
             * KafkaReadArgs includeOffsetInfo.
             * @member {boolean} includeOffsetInfo
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.includeOffsetInfo = false;

            /**
             * KafkaReadArgs lag.
             * @member {boolean} lag
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.lag = false;

            /**
             * KafkaReadArgs lagConsumerGroup.
             * @member {string} lagConsumerGroup
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.lagConsumerGroup = "";

            /**
             * Creates a new KafkaReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs instance
             */
            KafkaReadArgs.create = function create(properties) {
                return new KafkaReadArgs(properties);
            };

            /**
             * Encodes the specified KafkaReadArgs message. Does not implicitly {@link protos.args.KafkaReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs} message KafkaReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.topics[i]);
                if (message.readOffset != null && Object.hasOwnProperty.call(message, "readOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readOffset);
                if (message.useConsumerGroup != null && Object.hasOwnProperty.call(message, "useConsumerGroup"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useConsumerGroup);
                if (message.consumerGroupName != null && Object.hasOwnProperty.call(message, "consumerGroupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.consumerGroupName);
                if (message.maxWaitSeconds != null && Object.hasOwnProperty.call(message, "maxWaitSeconds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxWaitSeconds);
                if (message.minBytes != null && Object.hasOwnProperty.call(message, "minBytes"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.minBytes);
                if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxBytes);
                if (message.commitIntervalSeconds != null && Object.hasOwnProperty.call(message, "commitIntervalSeconds"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.commitIntervalSeconds);
                if (message.rebalanceTimeoutSeconds != null && Object.hasOwnProperty.call(message, "rebalanceTimeoutSeconds"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.rebalanceTimeoutSeconds);
                if (message.queueCapacity != null && Object.hasOwnProperty.call(message, "queueCapacity"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.queueCapacity);
                if (message.includeOffsetInfo != null && Object.hasOwnProperty.call(message, "includeOffsetInfo"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.includeOffsetInfo);
                if (message.lag != null && Object.hasOwnProperty.call(message, "lag"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.lag);
                if (message.lagConsumerGroup != null && Object.hasOwnProperty.call(message, "lagConsumerGroup"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.lagConsumerGroup);
                return writer;
            };

            /**
             * Encodes the specified KafkaReadArgs message, length delimited. Does not implicitly {@link protos.args.KafkaReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs} message KafkaReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    case 2:
                        message.readOffset = reader.int64();
                        break;
                    case 3:
                        message.useConsumerGroup = reader.bool();
                        break;
                    case 4:
                        message.consumerGroupName = reader.string();
                        break;
                    case 5:
                        message.maxWaitSeconds = reader.int32();
                        break;
                    case 6:
                        message.minBytes = reader.int32();
                        break;
                    case 7:
                        message.maxBytes = reader.int32();
                        break;
                    case 8:
                        message.commitIntervalSeconds = reader.int32();
                        break;
                    case 9:
                        message.rebalanceTimeoutSeconds = reader.int32();
                        break;
                    case 10:
                        message.queueCapacity = reader.int32();
                        break;
                    case 11:
                        message.includeOffsetInfo = reader.bool();
                        break;
                    case 12:
                        message.lag = reader.bool();
                        break;
                    case 13:
                        message.lagConsumerGroup = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaReadArgs message.
             * @function verify
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (!$util.isInteger(message.readOffset) && !(message.readOffset && $util.isInteger(message.readOffset.low) && $util.isInteger(message.readOffset.high)))
                        return "readOffset: integer|Long expected";
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    if (typeof message.useConsumerGroup !== "boolean")
                        return "useConsumerGroup: boolean expected";
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    if (!$util.isString(message.consumerGroupName))
                        return "consumerGroupName: string expected";
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    if (!$util.isInteger(message.maxWaitSeconds))
                        return "maxWaitSeconds: integer expected";
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    if (!$util.isInteger(message.minBytes))
                        return "minBytes: integer expected";
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    if (!$util.isInteger(message.maxBytes))
                        return "maxBytes: integer expected";
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    if (!$util.isInteger(message.commitIntervalSeconds))
                        return "commitIntervalSeconds: integer expected";
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    if (!$util.isInteger(message.rebalanceTimeoutSeconds))
                        return "rebalanceTimeoutSeconds: integer expected";
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    if (!$util.isInteger(message.queueCapacity))
                        return "queueCapacity: integer expected";
                if (message.includeOffsetInfo != null && message.hasOwnProperty("includeOffsetInfo"))
                    if (typeof message.includeOffsetInfo !== "boolean")
                        return "includeOffsetInfo: boolean expected";
                if (message.lag != null && message.hasOwnProperty("lag"))
                    if (typeof message.lag !== "boolean")
                        return "lag: boolean expected";
                if (message.lagConsumerGroup != null && message.hasOwnProperty("lagConsumerGroup"))
                    if (!$util.isString(message.lagConsumerGroup))
                        return "lagConsumerGroup: string expected";
                return null;
            };

            /**
             * Creates a KafkaReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             */
            KafkaReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaReadArgs)
                    return object;
                var message = new $root.protos.args.KafkaReadArgs();
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaReadArgs.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                if (object.readOffset != null)
                    if ($util.Long)
                        (message.readOffset = $util.Long.fromValue(object.readOffset)).unsigned = false;
                    else if (typeof object.readOffset === "string")
                        message.readOffset = parseInt(object.readOffset, 10);
                    else if (typeof object.readOffset === "number")
                        message.readOffset = object.readOffset;
                    else if (typeof object.readOffset === "object")
                        message.readOffset = new $util.LongBits(object.readOffset.low >>> 0, object.readOffset.high >>> 0).toNumber();
                if (object.useConsumerGroup != null)
                    message.useConsumerGroup = Boolean(object.useConsumerGroup);
                if (object.consumerGroupName != null)
                    message.consumerGroupName = String(object.consumerGroupName);
                if (object.maxWaitSeconds != null)
                    message.maxWaitSeconds = object.maxWaitSeconds | 0;
                if (object.minBytes != null)
                    message.minBytes = object.minBytes | 0;
                if (object.maxBytes != null)
                    message.maxBytes = object.maxBytes | 0;
                if (object.commitIntervalSeconds != null)
                    message.commitIntervalSeconds = object.commitIntervalSeconds | 0;
                if (object.rebalanceTimeoutSeconds != null)
                    message.rebalanceTimeoutSeconds = object.rebalanceTimeoutSeconds | 0;
                if (object.queueCapacity != null)
                    message.queueCapacity = object.queueCapacity | 0;
                if (object.includeOffsetInfo != null)
                    message.includeOffsetInfo = Boolean(object.includeOffsetInfo);
                if (object.lag != null)
                    message.lag = Boolean(object.lag);
                if (object.lagConsumerGroup != null)
                    message.lagConsumerGroup = String(object.lagConsumerGroup);
                return message;
            };

            /**
             * Creates a plain object from a KafkaReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.KafkaReadArgs} message KafkaReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.readOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readOffset = options.longs === String ? "0" : 0;
                    object.useConsumerGroup = false;
                    object.consumerGroupName = "";
                    object.maxWaitSeconds = 0;
                    object.minBytes = 0;
                    object.maxBytes = 0;
                    object.commitIntervalSeconds = 0;
                    object.rebalanceTimeoutSeconds = 0;
                    object.queueCapacity = 0;
                    object.includeOffsetInfo = false;
                    object.lag = false;
                    object.lagConsumerGroup = "";
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (typeof message.readOffset === "number")
                        object.readOffset = options.longs === String ? String(message.readOffset) : message.readOffset;
                    else
                        object.readOffset = options.longs === String ? $util.Long.prototype.toString.call(message.readOffset) : options.longs === Number ? new $util.LongBits(message.readOffset.low >>> 0, message.readOffset.high >>> 0).toNumber() : message.readOffset;
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    object.useConsumerGroup = message.useConsumerGroup;
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    object.consumerGroupName = message.consumerGroupName;
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    object.maxWaitSeconds = message.maxWaitSeconds;
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    object.minBytes = message.minBytes;
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    object.maxBytes = message.maxBytes;
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    object.commitIntervalSeconds = message.commitIntervalSeconds;
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    object.rebalanceTimeoutSeconds = message.rebalanceTimeoutSeconds;
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    object.queueCapacity = message.queueCapacity;
                if (message.includeOffsetInfo != null && message.hasOwnProperty("includeOffsetInfo"))
                    object.includeOffsetInfo = message.includeOffsetInfo;
                if (message.lag != null && message.hasOwnProperty("lag"))
                    object.lag = message.lag;
                if (message.lagConsumerGroup != null && message.hasOwnProperty("lagConsumerGroup"))
                    object.lagConsumerGroup = message.lagConsumerGroup;
                return object;
            };

            /**
             * Converts this KafkaReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaReadArgs;
        })();

        args.KafkaWriteArgs = (function() {

            /**
             * Properties of a KafkaWriteArgs.
             * @memberof protos.args
             * @interface IKafkaWriteArgs
             * @property {string|null} [key] KafkaWriteArgs key
             * @property {Object.<string,string>|null} [headers] KafkaWriteArgs headers
             * @property {Array.<string>|null} [topics] KafkaWriteArgs topics
             */

            /**
             * Constructs a new KafkaWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaWriteArgs.
             * @implements IKafkaWriteArgs
             * @constructor
             * @param {protos.args.IKafkaWriteArgs=} [properties] Properties to set
             */
            function KafkaWriteArgs(properties) {
                this.headers = {};
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaWriteArgs key.
             * @member {string} key
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.key = "";

            /**
             * KafkaWriteArgs headers.
             * @member {Object.<string,string>} headers
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.headers = $util.emptyObject;

            /**
             * KafkaWriteArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.topics = $util.emptyArray;

            /**
             * Creates a new KafkaWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs instance
             */
            KafkaWriteArgs.create = function create(properties) {
                return new KafkaWriteArgs(properties);
            };

            /**
             * Encodes the specified KafkaWriteArgs message. Does not implicitly {@link protos.args.KafkaWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs} message KafkaWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    for (var keys = Object.keys(message.headers), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.headers[keys[i]]).ldelim();
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.topics[i]);
                return writer;
            };

            /**
             * Encodes the specified KafkaWriteArgs message, length delimited. Does not implicitly {@link protos.args.KafkaWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs} message KafkaWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaWriteArgs(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        if (message.headers === $util.emptyObject)
                            message.headers = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.headers[key] = value;
                        break;
                    case 3:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaWriteArgs message.
             * @function verify
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!$util.isObject(message.headers))
                        return "headers: object expected";
                    var key = Object.keys(message.headers);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.headers[key[i]]))
                            return "headers: string{k:string} expected";
                }
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                return null;
            };

            /**
             * Creates a KafkaWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             */
            KafkaWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaWriteArgs)
                    return object;
                var message = new $root.protos.args.KafkaWriteArgs();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.headers) {
                    if (typeof object.headers !== "object")
                        throw TypeError(".protos.args.KafkaWriteArgs.headers: object expected");
                    message.headers = {};
                    for (var keys = Object.keys(object.headers), i = 0; i < keys.length; ++i)
                        message.headers[keys[i]] = String(object.headers[keys[i]]);
                }
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaWriteArgs.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a KafkaWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.KafkaWriteArgs} message KafkaWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.objects || options.defaults)
                    object.headers = {};
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                var keys2;
                if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                    object.headers = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.headers[keys2[j]] = message.headers[keys2[j]];
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                return object;
            };

            /**
             * Converts this KafkaWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaWriteArgs;
        })();

        args.KafkaRelayArgs = (function() {

            /**
             * Properties of a KafkaRelayArgs.
             * @memberof protos.args
             * @interface IKafkaRelayArgs
             * @property {Array.<string>|null} [topics] KafkaRelayArgs topics
             * @property {number|Long|null} [readOffset] KafkaRelayArgs readOffset
             * @property {boolean|null} [useConsumerGroup] KafkaRelayArgs useConsumerGroup
             * @property {string|null} [consumerGroupName] KafkaRelayArgs consumerGroupName
             * @property {number|null} [maxWaitSeconds] KafkaRelayArgs maxWaitSeconds
             * @property {number|null} [minBytes] KafkaRelayArgs minBytes
             * @property {number|null} [maxBytes] KafkaRelayArgs maxBytes
             * @property {number|null} [commitIntervalSeconds] KafkaRelayArgs commitIntervalSeconds
             * @property {number|null} [rebalanceTimeoutSeconds] KafkaRelayArgs rebalanceTimeoutSeconds
             * @property {number|null} [queueCapacity] KafkaRelayArgs queueCapacity
             */

            /**
             * Constructs a new KafkaRelayArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaRelayArgs.
             * @implements IKafkaRelayArgs
             * @constructor
             * @param {protos.args.IKafkaRelayArgs=} [properties] Properties to set
             */
            function KafkaRelayArgs(properties) {
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaRelayArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.topics = $util.emptyArray;

            /**
             * KafkaRelayArgs readOffset.
             * @member {number|Long} readOffset
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.readOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KafkaRelayArgs useConsumerGroup.
             * @member {boolean} useConsumerGroup
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.useConsumerGroup = false;

            /**
             * KafkaRelayArgs consumerGroupName.
             * @member {string} consumerGroupName
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.consumerGroupName = "";

            /**
             * KafkaRelayArgs maxWaitSeconds.
             * @member {number} maxWaitSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.maxWaitSeconds = 0;

            /**
             * KafkaRelayArgs minBytes.
             * @member {number} minBytes
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.minBytes = 0;

            /**
             * KafkaRelayArgs maxBytes.
             * @member {number} maxBytes
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.maxBytes = 0;

            /**
             * KafkaRelayArgs commitIntervalSeconds.
             * @member {number} commitIntervalSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.commitIntervalSeconds = 0;

            /**
             * KafkaRelayArgs rebalanceTimeoutSeconds.
             * @member {number} rebalanceTimeoutSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.rebalanceTimeoutSeconds = 0;

            /**
             * KafkaRelayArgs queueCapacity.
             * @member {number} queueCapacity
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.queueCapacity = 0;

            /**
             * Creates a new KafkaRelayArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs instance
             */
            KafkaRelayArgs.create = function create(properties) {
                return new KafkaRelayArgs(properties);
            };

            /**
             * Encodes the specified KafkaRelayArgs message. Does not implicitly {@link protos.args.KafkaRelayArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs} message KafkaRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaRelayArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.topics[i]);
                if (message.readOffset != null && Object.hasOwnProperty.call(message, "readOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readOffset);
                if (message.useConsumerGroup != null && Object.hasOwnProperty.call(message, "useConsumerGroup"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useConsumerGroup);
                if (message.consumerGroupName != null && Object.hasOwnProperty.call(message, "consumerGroupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.consumerGroupName);
                if (message.maxWaitSeconds != null && Object.hasOwnProperty.call(message, "maxWaitSeconds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxWaitSeconds);
                if (message.minBytes != null && Object.hasOwnProperty.call(message, "minBytes"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.minBytes);
                if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxBytes);
                if (message.commitIntervalSeconds != null && Object.hasOwnProperty.call(message, "commitIntervalSeconds"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.commitIntervalSeconds);
                if (message.rebalanceTimeoutSeconds != null && Object.hasOwnProperty.call(message, "rebalanceTimeoutSeconds"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.rebalanceTimeoutSeconds);
                if (message.queueCapacity != null && Object.hasOwnProperty.call(message, "queueCapacity"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.queueCapacity);
                return writer;
            };

            /**
             * Encodes the specified KafkaRelayArgs message, length delimited. Does not implicitly {@link protos.args.KafkaRelayArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs} message KafkaRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaRelayArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaRelayArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaRelayArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaRelayArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    case 2:
                        message.readOffset = reader.int64();
                        break;
                    case 3:
                        message.useConsumerGroup = reader.bool();
                        break;
                    case 4:
                        message.consumerGroupName = reader.string();
                        break;
                    case 5:
                        message.maxWaitSeconds = reader.int32();
                        break;
                    case 6:
                        message.minBytes = reader.int32();
                        break;
                    case 7:
                        message.maxBytes = reader.int32();
                        break;
                    case 8:
                        message.commitIntervalSeconds = reader.int32();
                        break;
                    case 9:
                        message.rebalanceTimeoutSeconds = reader.int32();
                        break;
                    case 10:
                        message.queueCapacity = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaRelayArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaRelayArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaRelayArgs message.
             * @function verify
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaRelayArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (!$util.isInteger(message.readOffset) && !(message.readOffset && $util.isInteger(message.readOffset.low) && $util.isInteger(message.readOffset.high)))
                        return "readOffset: integer|Long expected";
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    if (typeof message.useConsumerGroup !== "boolean")
                        return "useConsumerGroup: boolean expected";
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    if (!$util.isString(message.consumerGroupName))
                        return "consumerGroupName: string expected";
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    if (!$util.isInteger(message.maxWaitSeconds))
                        return "maxWaitSeconds: integer expected";
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    if (!$util.isInteger(message.minBytes))
                        return "minBytes: integer expected";
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    if (!$util.isInteger(message.maxBytes))
                        return "maxBytes: integer expected";
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    if (!$util.isInteger(message.commitIntervalSeconds))
                        return "commitIntervalSeconds: integer expected";
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    if (!$util.isInteger(message.rebalanceTimeoutSeconds))
                        return "rebalanceTimeoutSeconds: integer expected";
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    if (!$util.isInteger(message.queueCapacity))
                        return "queueCapacity: integer expected";
                return null;
            };

            /**
             * Creates a KafkaRelayArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             */
            KafkaRelayArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaRelayArgs)
                    return object;
                var message = new $root.protos.args.KafkaRelayArgs();
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaRelayArgs.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                if (object.readOffset != null)
                    if ($util.Long)
                        (message.readOffset = $util.Long.fromValue(object.readOffset)).unsigned = false;
                    else if (typeof object.readOffset === "string")
                        message.readOffset = parseInt(object.readOffset, 10);
                    else if (typeof object.readOffset === "number")
                        message.readOffset = object.readOffset;
                    else if (typeof object.readOffset === "object")
                        message.readOffset = new $util.LongBits(object.readOffset.low >>> 0, object.readOffset.high >>> 0).toNumber();
                if (object.useConsumerGroup != null)
                    message.useConsumerGroup = Boolean(object.useConsumerGroup);
                if (object.consumerGroupName != null)
                    message.consumerGroupName = String(object.consumerGroupName);
                if (object.maxWaitSeconds != null)
                    message.maxWaitSeconds = object.maxWaitSeconds | 0;
                if (object.minBytes != null)
                    message.minBytes = object.minBytes | 0;
                if (object.maxBytes != null)
                    message.maxBytes = object.maxBytes | 0;
                if (object.commitIntervalSeconds != null)
                    message.commitIntervalSeconds = object.commitIntervalSeconds | 0;
                if (object.rebalanceTimeoutSeconds != null)
                    message.rebalanceTimeoutSeconds = object.rebalanceTimeoutSeconds | 0;
                if (object.queueCapacity != null)
                    message.queueCapacity = object.queueCapacity | 0;
                return message;
            };

            /**
             * Creates a plain object from a KafkaRelayArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.KafkaRelayArgs} message KafkaRelayArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaRelayArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.readOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readOffset = options.longs === String ? "0" : 0;
                    object.useConsumerGroup = false;
                    object.consumerGroupName = "";
                    object.maxWaitSeconds = 0;
                    object.minBytes = 0;
                    object.maxBytes = 0;
                    object.commitIntervalSeconds = 0;
                    object.rebalanceTimeoutSeconds = 0;
                    object.queueCapacity = 0;
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (typeof message.readOffset === "number")
                        object.readOffset = options.longs === String ? String(message.readOffset) : message.readOffset;
                    else
                        object.readOffset = options.longs === String ? $util.Long.prototype.toString.call(message.readOffset) : options.longs === Number ? new $util.LongBits(message.readOffset.low >>> 0, message.readOffset.high >>> 0).toNumber() : message.readOffset;
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    object.useConsumerGroup = message.useConsumerGroup;
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    object.consumerGroupName = message.consumerGroupName;
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    object.maxWaitSeconds = message.maxWaitSeconds;
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    object.minBytes = message.minBytes;
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    object.maxBytes = message.maxBytes;
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    object.commitIntervalSeconds = message.commitIntervalSeconds;
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    object.rebalanceTimeoutSeconds = message.rebalanceTimeoutSeconds;
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    object.queueCapacity = message.queueCapacity;
                return object;
            };

            /**
             * Converts this KafkaRelayArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaRelayArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaRelayArgs;
        })();

        args.ActiveMQConn = (function() {

            /**
             * Properties of an ActiveMQConn.
             * @memberof protos.args
             * @interface IActiveMQConn
             * @property {string|null} [address] ActiveMQConn address
             */

            /**
             * Constructs a new ActiveMQConn.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQConn.
             * @implements IActiveMQConn
             * @constructor
             * @param {protos.args.IActiveMQConn=} [properties] Properties to set
             */
            function ActiveMQConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQConn address.
             * @member {string} address
             * @memberof protos.args.ActiveMQConn
             * @instance
             */
            ActiveMQConn.prototype.address = "";

            /**
             * Creates a new ActiveMQConn instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn=} [properties] Properties to set
             * @returns {protos.args.ActiveMQConn} ActiveMQConn instance
             */
            ActiveMQConn.create = function create(properties) {
                return new ActiveMQConn(properties);
            };

            /**
             * Encodes the specified ActiveMQConn message. Does not implicitly {@link protos.args.ActiveMQConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn} message ActiveMQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQConn message, length delimited. Does not implicitly {@link protos.args.ActiveMQConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn} message ActiveMQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQConn message.
             * @function verify
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             */
            ActiveMQConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQConn)
                    return object;
                var message = new $root.protos.args.ActiveMQConn();
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.ActiveMQConn} message ActiveMQConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.address = "";
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this ActiveMQConn to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQConn;
        })();

        args.ActiveMQReadArgs = (function() {

            /**
             * Properties of an ActiveMQReadArgs.
             * @memberof protos.args
             * @interface IActiveMQReadArgs
             * @property {string|null} [topic] ActiveMQReadArgs topic
             * @property {string|null} [queue] ActiveMQReadArgs queue
             */

            /**
             * Constructs a new ActiveMQReadArgs.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQReadArgs.
             * @implements IActiveMQReadArgs
             * @constructor
             * @param {protos.args.IActiveMQReadArgs=} [properties] Properties to set
             */
            function ActiveMQReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             */
            ActiveMQReadArgs.prototype.topic = "";

            /**
             * ActiveMQReadArgs queue.
             * @member {string} queue
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             */
            ActiveMQReadArgs.prototype.queue = "";

            /**
             * Creates a new ActiveMQReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs=} [properties] Properties to set
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs instance
             */
            ActiveMQReadArgs.create = function create(properties) {
                return new ActiveMQReadArgs(properties);
            };

            /**
             * Encodes the specified ActiveMQReadArgs message. Does not implicitly {@link protos.args.ActiveMQReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs} message ActiveMQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queue);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQReadArgs message, length delimited. Does not implicitly {@link protos.args.ActiveMQReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs} message ActiveMQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.queue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQReadArgs message.
             * @function verify
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             */
            ActiveMQReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQReadArgs)
                    return object;
                var message = new $root.protos.args.ActiveMQReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.queue != null)
                    message.queue = String(object.queue);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.ActiveMQReadArgs} message ActiveMQReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.queue = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                return object;
            };

            /**
             * Converts this ActiveMQReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQReadArgs;
        })();

        args.ActiveMQWriteArgs = (function() {

            /**
             * Properties of an ActiveMQWriteArgs.
             * @memberof protos.args
             * @interface IActiveMQWriteArgs
             * @property {string|null} [topic] ActiveMQWriteArgs topic
             * @property {string|null} [queue] ActiveMQWriteArgs queue
             */

            /**
             * Constructs a new ActiveMQWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQWriteArgs.
             * @implements IActiveMQWriteArgs
             * @constructor
             * @param {protos.args.IActiveMQWriteArgs=} [properties] Properties to set
             */
            function ActiveMQWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             */
            ActiveMQWriteArgs.prototype.topic = "";

            /**
             * ActiveMQWriteArgs queue.
             * @member {string} queue
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             */
            ActiveMQWriteArgs.prototype.queue = "";

            /**
             * Creates a new ActiveMQWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs=} [properties] Properties to set
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs instance
             */
            ActiveMQWriteArgs.create = function create(properties) {
                return new ActiveMQWriteArgs(properties);
            };

            /**
             * Encodes the specified ActiveMQWriteArgs message. Does not implicitly {@link protos.args.ActiveMQWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs} message ActiveMQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queue);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQWriteArgs message, length delimited. Does not implicitly {@link protos.args.ActiveMQWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs} message ActiveMQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.queue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQWriteArgs message.
             * @function verify
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             */
            ActiveMQWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQWriteArgs)
                    return object;
                var message = new $root.protos.args.ActiveMQWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.queue != null)
                    message.queue = String(object.queue);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.ActiveMQWriteArgs} message ActiveMQWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.queue = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                return object;
            };

            /**
             * Converts this ActiveMQWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQWriteArgs;
        })();

        args.AWSSNSConn = (function() {

            /**
             * Properties of a AWSSNSConn.
             * @memberof protos.args
             * @interface IAWSSNSConn
             * @property {string|null} [awsRegion] AWSSNSConn awsRegion
             * @property {string|null} [awsAccessKeyId] AWSSNSConn awsAccessKeyId
             * @property {string|null} [awsSecretAccessKey] AWSSNSConn awsSecretAccessKey
             */

            /**
             * Constructs a new AWSSNSConn.
             * @memberof protos.args
             * @classdesc Represents a AWSSNSConn.
             * @implements IAWSSNSConn
             * @constructor
             * @param {protos.args.IAWSSNSConn=} [properties] Properties to set
             */
            function AWSSNSConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSNSConn awsRegion.
             * @member {string} awsRegion
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsRegion = "";

            /**
             * AWSSNSConn awsAccessKeyId.
             * @member {string} awsAccessKeyId
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsAccessKeyId = "";

            /**
             * AWSSNSConn awsSecretAccessKey.
             * @member {string} awsSecretAccessKey
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsSecretAccessKey = "";

            /**
             * Creates a new AWSSNSConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn=} [properties] Properties to set
             * @returns {protos.args.AWSSNSConn} AWSSNSConn instance
             */
            AWSSNSConn.create = function create(properties) {
                return new AWSSNSConn(properties);
            };

            /**
             * Encodes the specified AWSSNSConn message. Does not implicitly {@link protos.args.AWSSNSConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn} message AWSSNSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.awsRegion != null && Object.hasOwnProperty.call(message, "awsRegion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.awsRegion);
                if (message.awsAccessKeyId != null && Object.hasOwnProperty.call(message, "awsAccessKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.awsAccessKeyId);
                if (message.awsSecretAccessKey != null && Object.hasOwnProperty.call(message, "awsSecretAccessKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.awsSecretAccessKey);
                return writer;
            };

            /**
             * Encodes the specified AWSSNSConn message, length delimited. Does not implicitly {@link protos.args.AWSSNSConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn} message AWSSNSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSNSConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSNSConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.awsRegion = reader.string();
                        break;
                    case 2:
                        message.awsAccessKeyId = reader.string();
                        break;
                    case 3:
                        message.awsSecretAccessKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSNSConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSNSConn message.
             * @function verify
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSNSConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    if (!$util.isString(message.awsRegion))
                        return "awsRegion: string expected";
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    if (!$util.isString(message.awsAccessKeyId))
                        return "awsAccessKeyId: string expected";
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    if (!$util.isString(message.awsSecretAccessKey))
                        return "awsSecretAccessKey: string expected";
                return null;
            };

            /**
             * Creates a AWSSNSConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             */
            AWSSNSConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSNSConn)
                    return object;
                var message = new $root.protos.args.AWSSNSConn();
                if (object.awsRegion != null)
                    message.awsRegion = String(object.awsRegion);
                if (object.awsAccessKeyId != null)
                    message.awsAccessKeyId = String(object.awsAccessKeyId);
                if (object.awsSecretAccessKey != null)
                    message.awsSecretAccessKey = String(object.awsSecretAccessKey);
                return message;
            };

            /**
             * Creates a plain object from a AWSSNSConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.AWSSNSConn} message AWSSNSConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSNSConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.awsRegion = "";
                    object.awsAccessKeyId = "";
                    object.awsSecretAccessKey = "";
                }
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    object.awsRegion = message.awsRegion;
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    object.awsAccessKeyId = message.awsAccessKeyId;
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    object.awsSecretAccessKey = message.awsSecretAccessKey;
                return object;
            };

            /**
             * Converts this AWSSNSConn to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSNSConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSNSConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSNSConn;
        })();

        args.AWSSNSWriteArgs = (function() {

            /**
             * Properties of a AWSSNSWriteArgs.
             * @memberof protos.args
             * @interface IAWSSNSWriteArgs
             * @property {string|null} [topic] AWSSNSWriteArgs topic
             */

            /**
             * Constructs a new AWSSNSWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSNSWriteArgs.
             * @implements IAWSSNSWriteArgs
             * @constructor
             * @param {protos.args.IAWSSNSWriteArgs=} [properties] Properties to set
             */
            function AWSSNSWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSNSWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.AWSSNSWriteArgs
             * @instance
             */
            AWSSNSWriteArgs.prototype.topic = "";

            /**
             * Creates a new AWSSNSWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs instance
             */
            AWSSNSWriteArgs.create = function create(properties) {
                return new AWSSNSWriteArgs(properties);
            };

            /**
             * Encodes the specified AWSSNSWriteArgs message. Does not implicitly {@link protos.args.AWSSNSWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs} message AWSSNSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified AWSSNSWriteArgs message, length delimited. Does not implicitly {@link protos.args.AWSSNSWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs} message AWSSNSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSNSWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSNSWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSNSWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSNSWriteArgs message.
             * @function verify
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSNSWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a AWSSNSWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             */
            AWSSNSWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSNSWriteArgs)
                    return object;
                var message = new $root.protos.args.AWSSNSWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a AWSSNSWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.AWSSNSWriteArgs} message AWSSNSWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSNSWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this AWSSNSWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSNSWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSNSWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSNSWriteArgs;
        })();

        args.AWSSQSConn = (function() {

            /**
             * Properties of a AWSSQSConn.
             * @memberof protos.args
             * @interface IAWSSQSConn
             * @property {string|null} [awsRegion] AWSSQSConn awsRegion
             * @property {string|null} [awsAccessKeyId] AWSSQSConn awsAccessKeyId
             * @property {string|null} [awsSecretAccessKey] AWSSQSConn awsSecretAccessKey
             */

            /**
             * Constructs a new AWSSQSConn.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSConn.
             * @implements IAWSSQSConn
             * @constructor
             * @param {protos.args.IAWSSQSConn=} [properties] Properties to set
             */
            function AWSSQSConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSConn awsRegion.
             * @member {string} awsRegion
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsRegion = "";

            /**
             * AWSSQSConn awsAccessKeyId.
             * @member {string} awsAccessKeyId
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsAccessKeyId = "";

            /**
             * AWSSQSConn awsSecretAccessKey.
             * @member {string} awsSecretAccessKey
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsSecretAccessKey = "";

            /**
             * Creates a new AWSSQSConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn=} [properties] Properties to set
             * @returns {protos.args.AWSSQSConn} AWSSQSConn instance
             */
            AWSSQSConn.create = function create(properties) {
                return new AWSSQSConn(properties);
            };

            /**
             * Encodes the specified AWSSQSConn message. Does not implicitly {@link protos.args.AWSSQSConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn} message AWSSQSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.awsRegion != null && Object.hasOwnProperty.call(message, "awsRegion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.awsRegion);
                if (message.awsAccessKeyId != null && Object.hasOwnProperty.call(message, "awsAccessKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.awsAccessKeyId);
                if (message.awsSecretAccessKey != null && Object.hasOwnProperty.call(message, "awsSecretAccessKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.awsSecretAccessKey);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSConn message, length delimited. Does not implicitly {@link protos.args.AWSSQSConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn} message AWSSQSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.awsRegion = reader.string();
                        break;
                    case 2:
                        message.awsAccessKeyId = reader.string();
                        break;
                    case 3:
                        message.awsSecretAccessKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSConn message.
             * @function verify
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    if (!$util.isString(message.awsRegion))
                        return "awsRegion: string expected";
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    if (!$util.isString(message.awsAccessKeyId))
                        return "awsAccessKeyId: string expected";
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    if (!$util.isString(message.awsSecretAccessKey))
                        return "awsSecretAccessKey: string expected";
                return null;
            };

            /**
             * Creates a AWSSQSConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             */
            AWSSQSConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSConn)
                    return object;
                var message = new $root.protos.args.AWSSQSConn();
                if (object.awsRegion != null)
                    message.awsRegion = String(object.awsRegion);
                if (object.awsAccessKeyId != null)
                    message.awsAccessKeyId = String(object.awsAccessKeyId);
                if (object.awsSecretAccessKey != null)
                    message.awsSecretAccessKey = String(object.awsSecretAccessKey);
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.AWSSQSConn} message AWSSQSConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.awsRegion = "";
                    object.awsAccessKeyId = "";
                    object.awsSecretAccessKey = "";
                }
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    object.awsRegion = message.awsRegion;
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    object.awsAccessKeyId = message.awsAccessKeyId;
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    object.awsSecretAccessKey = message.awsSecretAccessKey;
                return object;
            };

            /**
             * Converts this AWSSQSConn to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSConn;
        })();

        args.AWSSQSReadArgs = (function() {

            /**
             * Properties of a AWSSQSReadArgs.
             * @memberof protos.args
             * @interface IAWSSQSReadArgs
             * @property {string|null} [queueName] AWSSQSReadArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSReadArgs remoteAccountId
             * @property {number|null} [maxNumMessages] AWSSQSReadArgs maxNumMessages
             * @property {string|null} [receiveRequestAttemptId] AWSSQSReadArgs receiveRequestAttemptId
             * @property {boolean|null} [autoDelete] AWSSQSReadArgs autoDelete
             * @property {number|null} [waitTimeSeconds] AWSSQSReadArgs waitTimeSeconds
             */

            /**
             * Constructs a new AWSSQSReadArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSReadArgs.
             * @implements IAWSSQSReadArgs
             * @constructor
             * @param {protos.args.IAWSSQSReadArgs=} [properties] Properties to set
             */
            function AWSSQSReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.queueName = "";

            /**
             * AWSSQSReadArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSReadArgs maxNumMessages.
             * @member {number} maxNumMessages
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.maxNumMessages = 0;

            /**
             * AWSSQSReadArgs receiveRequestAttemptId.
             * @member {string} receiveRequestAttemptId
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.receiveRequestAttemptId = "";

            /**
             * AWSSQSReadArgs autoDelete.
             * @member {boolean} autoDelete
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.autoDelete = false;

            /**
             * AWSSQSReadArgs waitTimeSeconds.
             * @member {number} waitTimeSeconds
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.waitTimeSeconds = 0;

            /**
             * Creates a new AWSSQSReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs instance
             */
            AWSSQSReadArgs.create = function create(properties) {
                return new AWSSQSReadArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSReadArgs message. Does not implicitly {@link protos.args.AWSSQSReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs} message AWSSQSReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.maxNumMessages != null && Object.hasOwnProperty.call(message, "maxNumMessages"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxNumMessages);
                if (message.receiveRequestAttemptId != null && Object.hasOwnProperty.call(message, "receiveRequestAttemptId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.receiveRequestAttemptId);
                if (message.autoDelete != null && Object.hasOwnProperty.call(message, "autoDelete"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.autoDelete);
                if (message.waitTimeSeconds != null && Object.hasOwnProperty.call(message, "waitTimeSeconds"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.waitTimeSeconds);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSReadArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs} message AWSSQSReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.maxNumMessages = reader.uint32();
                        break;
                    case 4:
                        message.receiveRequestAttemptId = reader.string();
                        break;
                    case 5:
                        message.autoDelete = reader.bool();
                        break;
                    case 6:
                        message.waitTimeSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSReadArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (!$util.isInteger(message.maxNumMessages))
                        return "maxNumMessages: integer expected";
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    if (!$util.isString(message.receiveRequestAttemptId))
                        return "receiveRequestAttemptId: string expected";
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    if (typeof message.autoDelete !== "boolean")
                        return "autoDelete: boolean expected";
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (!$util.isInteger(message.waitTimeSeconds))
                        return "waitTimeSeconds: integer expected";
                return null;
            };

            /**
             * Creates a AWSSQSReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             */
            AWSSQSReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSReadArgs)
                    return object;
                var message = new $root.protos.args.AWSSQSReadArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.maxNumMessages != null)
                    message.maxNumMessages = object.maxNumMessages >>> 0;
                if (object.receiveRequestAttemptId != null)
                    message.receiveRequestAttemptId = String(object.receiveRequestAttemptId);
                if (object.autoDelete != null)
                    message.autoDelete = Boolean(object.autoDelete);
                if (object.waitTimeSeconds != null)
                    message.waitTimeSeconds = object.waitTimeSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.AWSSQSReadArgs} message AWSSQSReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    object.maxNumMessages = 0;
                    object.receiveRequestAttemptId = "";
                    object.autoDelete = false;
                    object.waitTimeSeconds = 0;
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    object.maxNumMessages = message.maxNumMessages;
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    object.receiveRequestAttemptId = message.receiveRequestAttemptId;
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    object.autoDelete = message.autoDelete;
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    object.waitTimeSeconds = message.waitTimeSeconds;
                return object;
            };

            /**
             * Converts this AWSSQSReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSReadArgs;
        })();

        args.AWSSQSWriteArgs = (function() {

            /**
             * Properties of a AWSSQSWriteArgs.
             * @memberof protos.args
             * @interface IAWSSQSWriteArgs
             * @property {string|null} [queueName] AWSSQSWriteArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSWriteArgs remoteAccountId
             * @property {number|null} [delaySeconds] AWSSQSWriteArgs delaySeconds
             * @property {Object.<string,string>|null} [attributes] AWSSQSWriteArgs attributes
             * @property {string|null} [messageGroupId] AWSSQSWriteArgs messageGroupId
             * @property {string|null} [messageDeduplicationId] AWSSQSWriteArgs messageDeduplicationId
             */

            /**
             * Constructs a new AWSSQSWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSWriteArgs.
             * @implements IAWSSQSWriteArgs
             * @constructor
             * @param {protos.args.IAWSSQSWriteArgs=} [properties] Properties to set
             */
            function AWSSQSWriteArgs(properties) {
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSWriteArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.queueName = "";

            /**
             * AWSSQSWriteArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSWriteArgs delaySeconds.
             * @member {number} delaySeconds
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.delaySeconds = 0;

            /**
             * AWSSQSWriteArgs attributes.
             * @member {Object.<string,string>} attributes
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.attributes = $util.emptyObject;

            /**
             * AWSSQSWriteArgs messageGroupId.
             * @member {string} messageGroupId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.messageGroupId = "";

            /**
             * AWSSQSWriteArgs messageDeduplicationId.
             * @member {string} messageDeduplicationId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.messageDeduplicationId = "";

            /**
             * Creates a new AWSSQSWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs instance
             */
            AWSSQSWriteArgs.create = function create(properties) {
                return new AWSSQSWriteArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSWriteArgs message. Does not implicitly {@link protos.args.AWSSQSWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs} message AWSSQSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.delaySeconds != null && Object.hasOwnProperty.call(message, "delaySeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.delaySeconds);
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.messageGroupId != null && Object.hasOwnProperty.call(message, "messageGroupId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.messageGroupId);
                if (message.messageDeduplicationId != null && Object.hasOwnProperty.call(message, "messageDeduplicationId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.messageDeduplicationId);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSWriteArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs} message AWSSQSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSWriteArgs(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.delaySeconds = reader.uint32();
                        break;
                    case 4:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 5:
                        message.messageGroupId = reader.string();
                        break;
                    case 6:
                        message.messageDeduplicationId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSWriteArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                    if (!$util.isInteger(message.delaySeconds))
                        return "delaySeconds: integer expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.messageGroupId != null && message.hasOwnProperty("messageGroupId"))
                    if (!$util.isString(message.messageGroupId))
                        return "messageGroupId: string expected";
                if (message.messageDeduplicationId != null && message.hasOwnProperty("messageDeduplicationId"))
                    if (!$util.isString(message.messageDeduplicationId))
                        return "messageDeduplicationId: string expected";
                return null;
            };

            /**
             * Creates a AWSSQSWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             */
            AWSSQSWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSWriteArgs)
                    return object;
                var message = new $root.protos.args.AWSSQSWriteArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.delaySeconds != null)
                    message.delaySeconds = object.delaySeconds >>> 0;
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".protos.args.AWSSQSWriteArgs.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.messageGroupId != null)
                    message.messageGroupId = String(object.messageGroupId);
                if (object.messageDeduplicationId != null)
                    message.messageDeduplicationId = String(object.messageDeduplicationId);
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.AWSSQSWriteArgs} message AWSSQSWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    object.delaySeconds = 0;
                    object.messageGroupId = "";
                    object.messageDeduplicationId = "";
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                    object.delaySeconds = message.delaySeconds;
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.messageGroupId != null && message.hasOwnProperty("messageGroupId"))
                    object.messageGroupId = message.messageGroupId;
                if (message.messageDeduplicationId != null && message.hasOwnProperty("messageDeduplicationId"))
                    object.messageDeduplicationId = message.messageDeduplicationId;
                return object;
            };

            /**
             * Converts this AWSSQSWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSWriteArgs;
        })();

        args.AWSSQSRelayArgs = (function() {

            /**
             * Properties of a AWSSQSRelayArgs.
             * @memberof protos.args
             * @interface IAWSSQSRelayArgs
             * @property {string|null} [queueName] AWSSQSRelayArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSRelayArgs remoteAccountId
             * @property {number|null} [maxNumMessages] AWSSQSRelayArgs maxNumMessages
             * @property {string|null} [receiveRequestAttemptId] AWSSQSRelayArgs receiveRequestAttemptId
             * @property {boolean|null} [autoDelete] AWSSQSRelayArgs autoDelete
             * @property {number|null} [waitTimeSeconds] AWSSQSRelayArgs waitTimeSeconds
             */

            /**
             * Constructs a new AWSSQSRelayArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSRelayArgs.
             * @implements IAWSSQSRelayArgs
             * @constructor
             * @param {protos.args.IAWSSQSRelayArgs=} [properties] Properties to set
             */
            function AWSSQSRelayArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSRelayArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.queueName = "";

            /**
             * AWSSQSRelayArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSRelayArgs maxNumMessages.
             * @member {number} maxNumMessages
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.maxNumMessages = 0;

            /**
             * AWSSQSRelayArgs receiveRequestAttemptId.
             * @member {string} receiveRequestAttemptId
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.receiveRequestAttemptId = "";

            /**
             * AWSSQSRelayArgs autoDelete.
             * @member {boolean} autoDelete
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.autoDelete = false;

            /**
             * AWSSQSRelayArgs waitTimeSeconds.
             * @member {number} waitTimeSeconds
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.waitTimeSeconds = 0;

            /**
             * Creates a new AWSSQSRelayArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs instance
             */
            AWSSQSRelayArgs.create = function create(properties) {
                return new AWSSQSRelayArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSRelayArgs message. Does not implicitly {@link protos.args.AWSSQSRelayArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs} message AWSSQSRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSRelayArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.maxNumMessages != null && Object.hasOwnProperty.call(message, "maxNumMessages"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxNumMessages);
                if (message.receiveRequestAttemptId != null && Object.hasOwnProperty.call(message, "receiveRequestAttemptId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.receiveRequestAttemptId);
                if (message.autoDelete != null && Object.hasOwnProperty.call(message, "autoDelete"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.autoDelete);
                if (message.waitTimeSeconds != null && Object.hasOwnProperty.call(message, "waitTimeSeconds"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.waitTimeSeconds);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSRelayArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSRelayArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs} message AWSSQSRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSRelayArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSRelayArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSRelayArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSRelayArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.maxNumMessages = reader.uint32();
                        break;
                    case 4:
                        message.receiveRequestAttemptId = reader.string();
                        break;
                    case 5:
                        message.autoDelete = reader.bool();
                        break;
                    case 6:
                        message.waitTimeSeconds = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSRelayArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSRelayArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSRelayArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSRelayArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (!$util.isInteger(message.maxNumMessages))
                        return "maxNumMessages: integer expected";
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    if (!$util.isString(message.receiveRequestAttemptId))
                        return "receiveRequestAttemptId: string expected";
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    if (typeof message.autoDelete !== "boolean")
                        return "autoDelete: boolean expected";
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (!$util.isInteger(message.waitTimeSeconds))
                        return "waitTimeSeconds: integer expected";
                return null;
            };

            /**
             * Creates a AWSSQSRelayArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             */
            AWSSQSRelayArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSRelayArgs)
                    return object;
                var message = new $root.protos.args.AWSSQSRelayArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.maxNumMessages != null)
                    message.maxNumMessages = object.maxNumMessages >>> 0;
                if (object.receiveRequestAttemptId != null)
                    message.receiveRequestAttemptId = String(object.receiveRequestAttemptId);
                if (object.autoDelete != null)
                    message.autoDelete = Boolean(object.autoDelete);
                if (object.waitTimeSeconds != null)
                    message.waitTimeSeconds = object.waitTimeSeconds | 0;
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSRelayArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.AWSSQSRelayArgs} message AWSSQSRelayArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSRelayArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    object.maxNumMessages = 0;
                    object.receiveRequestAttemptId = "";
                    object.autoDelete = false;
                    object.waitTimeSeconds = 0;
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    object.maxNumMessages = message.maxNumMessages;
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    object.receiveRequestAttemptId = message.receiveRequestAttemptId;
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    object.autoDelete = message.autoDelete;
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    object.waitTimeSeconds = message.waitTimeSeconds;
                return object;
            };

            /**
             * Converts this AWSSQSRelayArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSRelayArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSRelayArgs;
        })();

        args.MongoConn = (function() {

            /**
             * Properties of a MongoConn.
             * @memberof protos.args
             * @interface IMongoConn
             * @property {string|null} [dsn] MongoConn dsn
             */

            /**
             * Constructs a new MongoConn.
             * @memberof protos.args
             * @classdesc Represents a MongoConn.
             * @implements IMongoConn
             * @constructor
             * @param {protos.args.IMongoConn=} [properties] Properties to set
             */
            function MongoConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MongoConn dsn.
             * @member {string} dsn
             * @memberof protos.args.MongoConn
             * @instance
             */
            MongoConn.prototype.dsn = "";

            /**
             * Creates a new MongoConn instance using the specified properties.
             * @function create
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn=} [properties] Properties to set
             * @returns {protos.args.MongoConn} MongoConn instance
             */
            MongoConn.create = function create(properties) {
                return new MongoConn(properties);
            };

            /**
             * Encodes the specified MongoConn message. Does not implicitly {@link protos.args.MongoConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn} message MongoConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                return writer;
            };

            /**
             * Encodes the specified MongoConn message, length delimited. Does not implicitly {@link protos.args.MongoConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn} message MongoConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MongoConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MongoConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MongoConn} MongoConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MongoConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MongoConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MongoConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MongoConn} MongoConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MongoConn message.
             * @function verify
             * @memberof protos.args.MongoConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MongoConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                return null;
            };

            /**
             * Creates a MongoConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MongoConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MongoConn} MongoConn
             */
            MongoConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MongoConn)
                    return object;
                var message = new $root.protos.args.MongoConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                return message;
            };

            /**
             * Creates a plain object from a MongoConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.MongoConn} message MongoConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MongoConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.dsn = "";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                return object;
            };

            /**
             * Converts this MongoConn to JSON.
             * @function toJSON
             * @memberof protos.args.MongoConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MongoConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MongoConn;
        })();

        args.MongoReadArgs = (function() {

            /**
             * Properties of a MongoReadArgs.
             * @memberof protos.args
             * @interface IMongoReadArgs
             * @property {string|null} [database] MongoReadArgs database
             * @property {string|null} [collection] MongoReadArgs collection
             * @property {boolean|null} [includeFullDocument] MongoReadArgs includeFullDocument
             */

            /**
             * Constructs a new MongoReadArgs.
             * @memberof protos.args
             * @classdesc Represents a MongoReadArgs.
             * @implements IMongoReadArgs
             * @constructor
             * @param {protos.args.IMongoReadArgs=} [properties] Properties to set
             */
            function MongoReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MongoReadArgs database.
             * @member {string} database
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.database = "";

            /**
             * MongoReadArgs collection.
             * @member {string} collection
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.collection = "";

            /**
             * MongoReadArgs includeFullDocument.
             * @member {boolean} includeFullDocument
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.includeFullDocument = false;

            /**
             * Creates a new MongoReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs=} [properties] Properties to set
             * @returns {protos.args.MongoReadArgs} MongoReadArgs instance
             */
            MongoReadArgs.create = function create(properties) {
                return new MongoReadArgs(properties);
            };

            /**
             * Encodes the specified MongoReadArgs message. Does not implicitly {@link protos.args.MongoReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs} message MongoReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                if (message.includeFullDocument != null && Object.hasOwnProperty.call(message, "includeFullDocument"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeFullDocument);
                return writer;
            };

            /**
             * Encodes the specified MongoReadArgs message, length delimited. Does not implicitly {@link protos.args.MongoReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs} message MongoReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MongoReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MongoReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    case 3:
                        message.includeFullDocument = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MongoReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MongoReadArgs message.
             * @function verify
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MongoReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.includeFullDocument != null && message.hasOwnProperty("includeFullDocument"))
                    if (typeof message.includeFullDocument !== "boolean")
                        return "includeFullDocument: boolean expected";
                return null;
            };

            /**
             * Creates a MongoReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             */
            MongoReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MongoReadArgs)
                    return object;
                var message = new $root.protos.args.MongoReadArgs();
                if (object.database != null)
                    message.database = String(object.database);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.includeFullDocument != null)
                    message.includeFullDocument = Boolean(object.includeFullDocument);
                return message;
            };

            /**
             * Creates a plain object from a MongoReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.MongoReadArgs} message MongoReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MongoReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.database = "";
                    object.collection = "";
                    object.includeFullDocument = false;
                }
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.includeFullDocument != null && message.hasOwnProperty("includeFullDocument"))
                    object.includeFullDocument = message.includeFullDocument;
                return object;
            };

            /**
             * Converts this MongoReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MongoReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MongoReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MongoReadArgs;
        })();

        args.NatsConn = (function() {

            /**
             * Properties of a NatsConn.
             * @memberof protos.args
             * @interface INatsConn
             * @property {string|null} [dsn] NatsConn dsn
             * @property {boolean|null} [insecureTls] NatsConn insecureTls
             * @property {Uint8Array|null} [tlsCaCert] NatsConn tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] NatsConn tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] NatsConn tlsClientKey
             * @property {Uint8Array|null} [userCredentials] NatsConn userCredentials
             */

            /**
             * Constructs a new NatsConn.
             * @memberof protos.args
             * @classdesc Represents a NatsConn.
             * @implements INatsConn
             * @constructor
             * @param {protos.args.INatsConn=} [properties] Properties to set
             */
            function NatsConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsConn dsn.
             * @member {string} dsn
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.dsn = "";

            /**
             * NatsConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.insecureTls = false;

            /**
             * NatsConn tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * NatsConn tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * NatsConn tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * NatsConn userCredentials.
             * @member {Uint8Array} userCredentials
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.userCredentials = $util.newBuffer([]);

            /**
             * Creates a new NatsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn=} [properties] Properties to set
             * @returns {protos.args.NatsConn} NatsConn instance
             */
            NatsConn.create = function create(properties) {
                return new NatsConn(properties);
            };

            /**
             * Encodes the specified NatsConn message. Does not implicitly {@link protos.args.NatsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn} message NatsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.insecureTls);
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.tlsClientKey);
                if (message.userCredentials != null && Object.hasOwnProperty.call(message, "userCredentials"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.userCredentials);
                return writer;
            };

            /**
             * Encodes the specified NatsConn message, length delimited. Does not implicitly {@link protos.args.NatsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn} message NatsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsConn} NatsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.insecureTls = reader.bool();
                        break;
                    case 3:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 4:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 5:
                        message.tlsClientKey = reader.bytes();
                        break;
                    case 6:
                        message.userCredentials = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsConn} NatsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsConn message.
             * @function verify
             * @memberof protos.args.NatsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    if (!(message.userCredentials && typeof message.userCredentials.length === "number" || $util.isString(message.userCredentials)))
                        return "userCredentials: buffer expected";
                return null;
            };

            /**
             * Creates a NatsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsConn} NatsConn
             */
            NatsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsConn)
                    return object;
                var message = new $root.protos.args.NatsConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                if (object.userCredentials != null)
                    if (typeof object.userCredentials === "string")
                        $util.base64.decode(object.userCredentials, message.userCredentials = $util.newBuffer($util.base64.length(object.userCredentials)), 0);
                    else if (object.userCredentials.length)
                        message.userCredentials = object.userCredentials;
                return message;
            };

            /**
             * Creates a plain object from a NatsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.NatsConn} message NatsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.insecureTls = false;
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                    if (options.bytes === String)
                        object.userCredentials = "";
                    else {
                        object.userCredentials = [];
                        if (options.bytes !== Array)
                            object.userCredentials = $util.newBuffer(object.userCredentials);
                    }
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    object.userCredentials = options.bytes === String ? $util.base64.encode(message.userCredentials, 0, message.userCredentials.length) : options.bytes === Array ? Array.prototype.slice.call(message.userCredentials) : message.userCredentials;
                return object;
            };

            /**
             * Converts this NatsConn to JSON.
             * @function toJSON
             * @memberof protos.args.NatsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsConn;
        })();

        args.NatsReadArgs = (function() {

            /**
             * Properties of a NatsReadArgs.
             * @memberof protos.args
             * @interface INatsReadArgs
             * @property {string|null} [subject] NatsReadArgs subject
             */

            /**
             * Constructs a new NatsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsReadArgs.
             * @implements INatsReadArgs
             * @constructor
             * @param {protos.args.INatsReadArgs=} [properties] Properties to set
             */
            function NatsReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsReadArgs subject.
             * @member {string} subject
             * @memberof protos.args.NatsReadArgs
             * @instance
             */
            NatsReadArgs.prototype.subject = "";

            /**
             * Creates a new NatsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs=} [properties] Properties to set
             * @returns {protos.args.NatsReadArgs} NatsReadArgs instance
             */
            NatsReadArgs.create = function create(properties) {
                return new NatsReadArgs(properties);
            };

            /**
             * Encodes the specified NatsReadArgs message. Does not implicitly {@link protos.args.NatsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs} message NatsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                return writer;
            };

            /**
             * Encodes the specified NatsReadArgs message, length delimited. Does not implicitly {@link protos.args.NatsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs} message NatsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsReadArgs message.
             * @function verify
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                return null;
            };

            /**
             * Creates a NatsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             */
            NatsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsReadArgs)
                    return object;
                var message = new $root.protos.args.NatsReadArgs();
                if (object.subject != null)
                    message.subject = String(object.subject);
                return message;
            };

            /**
             * Creates a plain object from a NatsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.NatsReadArgs} message NatsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                return object;
            };

            /**
             * Converts this NatsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsReadArgs;
        })();

        args.NatsWriteArgs = (function() {

            /**
             * Properties of a NatsWriteArgs.
             * @memberof protos.args
             * @interface INatsWriteArgs
             * @property {string|null} [subject] NatsWriteArgs subject
             */

            /**
             * Constructs a new NatsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsWriteArgs.
             * @implements INatsWriteArgs
             * @constructor
             * @param {protos.args.INatsWriteArgs=} [properties] Properties to set
             */
            function NatsWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsWriteArgs subject.
             * @member {string} subject
             * @memberof protos.args.NatsWriteArgs
             * @instance
             */
            NatsWriteArgs.prototype.subject = "";

            /**
             * Creates a new NatsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs instance
             */
            NatsWriteArgs.create = function create(properties) {
                return new NatsWriteArgs(properties);
            };

            /**
             * Encodes the specified NatsWriteArgs message. Does not implicitly {@link protos.args.NatsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs} message NatsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                return writer;
            };

            /**
             * Encodes the specified NatsWriteArgs message, length delimited. Does not implicitly {@link protos.args.NatsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs} message NatsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsWriteArgs message.
             * @function verify
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                return null;
            };

            /**
             * Creates a NatsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             */
            NatsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsWriteArgs)
                    return object;
                var message = new $root.protos.args.NatsWriteArgs();
                if (object.subject != null)
                    message.subject = String(object.subject);
                return message;
            };

            /**
             * Creates a plain object from a NatsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.NatsWriteArgs} message NatsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                return object;
            };

            /**
             * Converts this NatsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsWriteArgs;
        })();

        args.NatsStreamingConn = (function() {

            /**
             * Properties of a NatsStreamingConn.
             * @memberof protos.args
             * @interface INatsStreamingConn
             * @property {string|null} [dsn] NatsStreamingConn dsn
             * @property {boolean|null} [insecureTls] NatsStreamingConn insecureTls
             * @property {Uint8Array|null} [tlsCaCert] NatsStreamingConn tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] NatsStreamingConn tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] NatsStreamingConn tlsClientKey
             * @property {Uint8Array|null} [userCredentials] NatsStreamingConn userCredentials
             * @property {string|null} [clusterId] NatsStreamingConn clusterId
             * @property {string|null} [clientId] NatsStreamingConn clientId
             */

            /**
             * Constructs a new NatsStreamingConn.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingConn.
             * @implements INatsStreamingConn
             * @constructor
             * @param {protos.args.INatsStreamingConn=} [properties] Properties to set
             */
            function NatsStreamingConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingConn dsn.
             * @member {string} dsn
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.dsn = "";

            /**
             * NatsStreamingConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.insecureTls = false;

            /**
             * NatsStreamingConn tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * NatsStreamingConn tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * NatsStreamingConn tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * NatsStreamingConn userCredentials.
             * @member {Uint8Array} userCredentials
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.userCredentials = $util.newBuffer([]);

            /**
             * NatsStreamingConn clusterId.
             * @member {string} clusterId
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.clusterId = "";

            /**
             * NatsStreamingConn clientId.
             * @member {string} clientId
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.clientId = "";

            /**
             * Creates a new NatsStreamingConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn instance
             */
            NatsStreamingConn.create = function create(properties) {
                return new NatsStreamingConn(properties);
            };

            /**
             * Encodes the specified NatsStreamingConn message. Does not implicitly {@link protos.args.NatsStreamingConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn} message NatsStreamingConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.insecureTls);
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.tlsClientKey);
                if (message.userCredentials != null && Object.hasOwnProperty.call(message, "userCredentials"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.userCredentials);
                if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.clusterId);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.clientId);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingConn message, length delimited. Does not implicitly {@link protos.args.NatsStreamingConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn} message NatsStreamingConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.insecureTls = reader.bool();
                        break;
                    case 3:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 4:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 5:
                        message.tlsClientKey = reader.bytes();
                        break;
                    case 6:
                        message.userCredentials = reader.bytes();
                        break;
                    case 7:
                        message.clusterId = reader.string();
                        break;
                    case 8:
                        message.clientId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingConn message.
             * @function verify
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    if (!(message.userCredentials && typeof message.userCredentials.length === "number" || $util.isString(message.userCredentials)))
                        return "userCredentials: buffer expected";
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    if (!$util.isString(message.clusterId))
                        return "clusterId: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                return null;
            };

            /**
             * Creates a NatsStreamingConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             */
            NatsStreamingConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingConn)
                    return object;
                var message = new $root.protos.args.NatsStreamingConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                if (object.userCredentials != null)
                    if (typeof object.userCredentials === "string")
                        $util.base64.decode(object.userCredentials, message.userCredentials = $util.newBuffer($util.base64.length(object.userCredentials)), 0);
                    else if (object.userCredentials.length)
                        message.userCredentials = object.userCredentials;
                if (object.clusterId != null)
                    message.clusterId = String(object.clusterId);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.NatsStreamingConn} message NatsStreamingConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.insecureTls = false;
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                    if (options.bytes === String)
                        object.userCredentials = "";
                    else {
                        object.userCredentials = [];
                        if (options.bytes !== Array)
                            object.userCredentials = $util.newBuffer(object.userCredentials);
                    }
                    object.clusterId = "";
                    object.clientId = "";
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    object.userCredentials = options.bytes === String ? $util.base64.encode(message.userCredentials, 0, message.userCredentials.length) : options.bytes === Array ? Array.prototype.slice.call(message.userCredentials) : message.userCredentials;
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    object.clusterId = message.clusterId;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                return object;
            };

            /**
             * Converts this NatsStreamingConn to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingConn;
        })();

        args.NatsStreamingReadArgs = (function() {

            /**
             * Properties of a NatsStreamingReadArgs.
             * @memberof protos.args
             * @interface INatsStreamingReadArgs
             * @property {string|null} [channel] NatsStreamingReadArgs channel
             * @property {string|null} [durableName] NatsStreamingReadArgs durableName
             * @property {boolean|null} [readLastAvailable] NatsStreamingReadArgs readLastAvailable
             * @property {number|null} [readSequenceNumber] NatsStreamingReadArgs readSequenceNumber
             * @property {string|null} [readSince] NatsStreamingReadArgs readSince
             * @property {boolean|null} [readAll] NatsStreamingReadArgs readAll
             */

            /**
             * Constructs a new NatsStreamingReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingReadArgs.
             * @implements INatsStreamingReadArgs
             * @constructor
             * @param {protos.args.INatsStreamingReadArgs=} [properties] Properties to set
             */
            function NatsStreamingReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingReadArgs channel.
             * @member {string} channel
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.channel = "";

            /**
             * NatsStreamingReadArgs durableName.
             * @member {string} durableName
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.durableName = "";

            /**
             * NatsStreamingReadArgs readLastAvailable.
             * @member {boolean} readLastAvailable
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readLastAvailable = false;

            /**
             * NatsStreamingReadArgs readSequenceNumber.
             * @member {number} readSequenceNumber
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readSequenceNumber = 0;

            /**
             * NatsStreamingReadArgs readSince.
             * @member {string} readSince
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readSince = "";

            /**
             * NatsStreamingReadArgs readAll.
             * @member {boolean} readAll
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readAll = false;

            /**
             * Creates a new NatsStreamingReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs instance
             */
            NatsStreamingReadArgs.create = function create(properties) {
                return new NatsStreamingReadArgs(properties);
            };

            /**
             * Encodes the specified NatsStreamingReadArgs message. Does not implicitly {@link protos.args.NatsStreamingReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs} message NatsStreamingReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.durableName != null && Object.hasOwnProperty.call(message, "durableName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.durableName);
                if (message.readLastAvailable != null && Object.hasOwnProperty.call(message, "readLastAvailable"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.readLastAvailable);
                if (message.readSequenceNumber != null && Object.hasOwnProperty.call(message, "readSequenceNumber"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.readSequenceNumber);
                if (message.readSince != null && Object.hasOwnProperty.call(message, "readSince"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.readSince);
                if (message.readAll != null && Object.hasOwnProperty.call(message, "readAll"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.readAll);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingReadArgs message, length delimited. Does not implicitly {@link protos.args.NatsStreamingReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs} message NatsStreamingReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.durableName = reader.string();
                        break;
                    case 3:
                        message.readLastAvailable = reader.bool();
                        break;
                    case 4:
                        message.readSequenceNumber = reader.uint32();
                        break;
                    case 5:
                        message.readSince = reader.string();
                        break;
                    case 6:
                        message.readAll = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingReadArgs message.
             * @function verify
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.durableName != null && message.hasOwnProperty("durableName"))
                    if (!$util.isString(message.durableName))
                        return "durableName: string expected";
                if (message.readLastAvailable != null && message.hasOwnProperty("readLastAvailable"))
                    if (typeof message.readLastAvailable !== "boolean")
                        return "readLastAvailable: boolean expected";
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    if (!$util.isInteger(message.readSequenceNumber))
                        return "readSequenceNumber: integer expected";
                if (message.readSince != null && message.hasOwnProperty("readSince"))
                    if (!$util.isString(message.readSince))
                        return "readSince: string expected";
                if (message.readAll != null && message.hasOwnProperty("readAll"))
                    if (typeof message.readAll !== "boolean")
                        return "readAll: boolean expected";
                return null;
            };

            /**
             * Creates a NatsStreamingReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             */
            NatsStreamingReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingReadArgs)
                    return object;
                var message = new $root.protos.args.NatsStreamingReadArgs();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.durableName != null)
                    message.durableName = String(object.durableName);
                if (object.readLastAvailable != null)
                    message.readLastAvailable = Boolean(object.readLastAvailable);
                if (object.readSequenceNumber != null)
                    message.readSequenceNumber = object.readSequenceNumber >>> 0;
                if (object.readSince != null)
                    message.readSince = String(object.readSince);
                if (object.readAll != null)
                    message.readAll = Boolean(object.readAll);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.NatsStreamingReadArgs} message NatsStreamingReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = "";
                    object.durableName = "";
                    object.readLastAvailable = false;
                    object.readSequenceNumber = 0;
                    object.readSince = "";
                    object.readAll = false;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.durableName != null && message.hasOwnProperty("durableName"))
                    object.durableName = message.durableName;
                if (message.readLastAvailable != null && message.hasOwnProperty("readLastAvailable"))
                    object.readLastAvailable = message.readLastAvailable;
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    object.readSequenceNumber = message.readSequenceNumber;
                if (message.readSince != null && message.hasOwnProperty("readSince"))
                    object.readSince = message.readSince;
                if (message.readAll != null && message.hasOwnProperty("readAll"))
                    object.readAll = message.readAll;
                return object;
            };

            /**
             * Converts this NatsStreamingReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingReadArgs;
        })();

        args.NatsStreamingWriteArgs = (function() {

            /**
             * Properties of a NatsStreamingWriteArgs.
             * @memberof protos.args
             * @interface INatsStreamingWriteArgs
             * @property {string|null} [channel] NatsStreamingWriteArgs channel
             */

            /**
             * Constructs a new NatsStreamingWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingWriteArgs.
             * @implements INatsStreamingWriteArgs
             * @constructor
             * @param {protos.args.INatsStreamingWriteArgs=} [properties] Properties to set
             */
            function NatsStreamingWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingWriteArgs channel.
             * @member {string} channel
             * @memberof protos.args.NatsStreamingWriteArgs
             * @instance
             */
            NatsStreamingWriteArgs.prototype.channel = "";

            /**
             * Creates a new NatsStreamingWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs instance
             */
            NatsStreamingWriteArgs.create = function create(properties) {
                return new NatsStreamingWriteArgs(properties);
            };

            /**
             * Encodes the specified NatsStreamingWriteArgs message. Does not implicitly {@link protos.args.NatsStreamingWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs} message NatsStreamingWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingWriteArgs message, length delimited. Does not implicitly {@link protos.args.NatsStreamingWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs} message NatsStreamingWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingWriteArgs message.
             * @function verify
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                return null;
            };

            /**
             * Creates a NatsStreamingWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             */
            NatsStreamingWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingWriteArgs)
                    return object;
                var message = new $root.protos.args.NatsStreamingWriteArgs();
                if (object.channel != null)
                    message.channel = String(object.channel);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.NatsStreamingWriteArgs} message NatsStreamingWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.channel = "";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                return object;
            };

            /**
             * Converts this NatsStreamingWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingWriteArgs;
        })();

        args.NSQConn = (function() {

            /**
             * Properties of a NSQConn.
             * @memberof protos.args
             * @interface INSQConn
             * @property {string|null} [nsqdAddress] NSQConn nsqdAddress
             * @property {string|null} [lookupdAddress] NSQConn lookupdAddress
             * @property {boolean|null} [useTls] NSQConn useTls
             * @property {boolean|null} [insecureTls] NSQConn insecureTls
             * @property {Uint8Array|null} [tlsCaCert] NSQConn tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] NSQConn tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] NSQConn tlsClientKey
             * @property {string|null} [authSecret] NSQConn authSecret
             * @property {string|null} [clientId] NSQConn clientId
             */

            /**
             * Constructs a new NSQConn.
             * @memberof protos.args
             * @classdesc Represents a NSQConn.
             * @implements INSQConn
             * @constructor
             * @param {protos.args.INSQConn=} [properties] Properties to set
             */
            function NSQConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQConn nsqdAddress.
             * @member {string} nsqdAddress
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.nsqdAddress = "";

            /**
             * NSQConn lookupdAddress.
             * @member {string} lookupdAddress
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.lookupdAddress = "";

            /**
             * NSQConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.useTls = false;

            /**
             * NSQConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.insecureTls = false;

            /**
             * NSQConn tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * NSQConn tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * NSQConn tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * NSQConn authSecret.
             * @member {string} authSecret
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.authSecret = "";

            /**
             * NSQConn clientId.
             * @member {string} clientId
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.clientId = "";

            /**
             * Creates a new NSQConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn=} [properties] Properties to set
             * @returns {protos.args.NSQConn} NSQConn instance
             */
            NSQConn.create = function create(properties) {
                return new NSQConn(properties);
            };

            /**
             * Encodes the specified NSQConn message. Does not implicitly {@link protos.args.NSQConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn} message NSQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nsqdAddress != null && Object.hasOwnProperty.call(message, "nsqdAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nsqdAddress);
                if (message.lookupdAddress != null && Object.hasOwnProperty.call(message, "lookupdAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.lookupdAddress);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useTls);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.insecureTls);
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.tlsClientKey);
                if (message.authSecret != null && Object.hasOwnProperty.call(message, "authSecret"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.authSecret);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.clientId);
                return writer;
            };

            /**
             * Encodes the specified NSQConn message, length delimited. Does not implicitly {@link protos.args.NSQConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn} message NSQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQConn} NSQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nsqdAddress = reader.string();
                        break;
                    case 2:
                        message.lookupdAddress = reader.string();
                        break;
                    case 3:
                        message.useTls = reader.bool();
                        break;
                    case 4:
                        message.insecureTls = reader.bool();
                        break;
                    case 5:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 6:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 7:
                        message.tlsClientKey = reader.bytes();
                        break;
                    case 8:
                        message.authSecret = reader.string();
                        break;
                    case 9:
                        message.clientId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQConn} NSQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQConn message.
             * @function verify
             * @memberof protos.args.NSQConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    if (!$util.isString(message.nsqdAddress))
                        return "nsqdAddress: string expected";
                if (message.lookupdAddress != null && message.hasOwnProperty("lookupdAddress"))
                    if (!$util.isString(message.lookupdAddress))
                        return "lookupdAddress: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                if (message.authSecret != null && message.hasOwnProperty("authSecret"))
                    if (!$util.isString(message.authSecret))
                        return "authSecret: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                return null;
            };

            /**
             * Creates a NSQConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQConn} NSQConn
             */
            NSQConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQConn)
                    return object;
                var message = new $root.protos.args.NSQConn();
                if (object.nsqdAddress != null)
                    message.nsqdAddress = String(object.nsqdAddress);
                if (object.lookupdAddress != null)
                    message.lookupdAddress = String(object.lookupdAddress);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                if (object.authSecret != null)
                    message.authSecret = String(object.authSecret);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                return message;
            };

            /**
             * Creates a plain object from a NSQConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.NSQConn} message NSQConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.nsqdAddress = "";
                    object.lookupdAddress = "";
                    object.useTls = false;
                    object.insecureTls = false;
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                    object.authSecret = "";
                    object.clientId = "";
                }
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    object.nsqdAddress = message.nsqdAddress;
                if (message.lookupdAddress != null && message.hasOwnProperty("lookupdAddress"))
                    object.lookupdAddress = message.lookupdAddress;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                if (message.authSecret != null && message.hasOwnProperty("authSecret"))
                    object.authSecret = message.authSecret;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                return object;
            };

            /**
             * Converts this NSQConn to JSON.
             * @function toJSON
             * @memberof protos.args.NSQConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQConn;
        })();

        args.NSQReadArgs = (function() {

            /**
             * Properties of a NSQReadArgs.
             * @memberof protos.args
             * @interface INSQReadArgs
             * @property {string|null} [topic] NSQReadArgs topic
             * @property {string|null} [channel] NSQReadArgs channel
             */

            /**
             * Constructs a new NSQReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NSQReadArgs.
             * @implements INSQReadArgs
             * @constructor
             * @param {protos.args.INSQReadArgs=} [properties] Properties to set
             */
            function NSQReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.NSQReadArgs
             * @instance
             */
            NSQReadArgs.prototype.topic = "";

            /**
             * NSQReadArgs channel.
             * @member {string} channel
             * @memberof protos.args.NSQReadArgs
             * @instance
             */
            NSQReadArgs.prototype.channel = "";

            /**
             * Creates a new NSQReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs=} [properties] Properties to set
             * @returns {protos.args.NSQReadArgs} NSQReadArgs instance
             */
            NSQReadArgs.create = function create(properties) {
                return new NSQReadArgs(properties);
            };

            /**
             * Encodes the specified NSQReadArgs message. Does not implicitly {@link protos.args.NSQReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs} message NSQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel);
                return writer;
            };

            /**
             * Encodes the specified NSQReadArgs message, length delimited. Does not implicitly {@link protos.args.NSQReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs} message NSQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.channel = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQReadArgs message.
             * @function verify
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                return null;
            };

            /**
             * Creates a NSQReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             */
            NSQReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQReadArgs)
                    return object;
                var message = new $root.protos.args.NSQReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.channel != null)
                    message.channel = String(object.channel);
                return message;
            };

            /**
             * Creates a plain object from a NSQReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.NSQReadArgs} message NSQReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.channel = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                return object;
            };

            /**
             * Converts this NSQReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NSQReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQReadArgs;
        })();

        args.NSQWriteArgs = (function() {

            /**
             * Properties of a NSQWriteArgs.
             * @memberof protos.args
             * @interface INSQWriteArgs
             * @property {string|null} [topic] NSQWriteArgs topic
             */

            /**
             * Constructs a new NSQWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NSQWriteArgs.
             * @implements INSQWriteArgs
             * @constructor
             * @param {protos.args.INSQWriteArgs=} [properties] Properties to set
             */
            function NSQWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.NSQWriteArgs
             * @instance
             */
            NSQWriteArgs.prototype.topic = "";

            /**
             * Creates a new NSQWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs instance
             */
            NSQWriteArgs.create = function create(properties) {
                return new NSQWriteArgs(properties);
            };

            /**
             * Encodes the specified NSQWriteArgs message. Does not implicitly {@link protos.args.NSQWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs} message NSQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified NSQWriteArgs message, length delimited. Does not implicitly {@link protos.args.NSQWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs} message NSQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQWriteArgs message.
             * @function verify
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a NSQWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             */
            NSQWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQWriteArgs)
                    return object;
                var message = new $root.protos.args.NSQWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a NSQWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.NSQWriteArgs} message NSQWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this NSQWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NSQWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQWriteArgs;
        })();

        /**
         * MQTTQoSLevel enum.
         * @name protos.args.MQTTQoSLevel
         * @enum {number}
         * @property {number} MQTT_QOS_LEVEL_AT_MOST_ONCE=0 MQTT_QOS_LEVEL_AT_MOST_ONCE value
         * @property {number} MQTT_QOS_LEVEL_AT_LEAST_ONCE=1 MQTT_QOS_LEVEL_AT_LEAST_ONCE value
         * @property {number} MQTT_QOS_LEVEL_EXACTLY_ONCE=2 MQTT_QOS_LEVEL_EXACTLY_ONCE value
         */
        args.MQTTQoSLevel = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MQTT_QOS_LEVEL_AT_MOST_ONCE"] = 0;
            values[valuesById[1] = "MQTT_QOS_LEVEL_AT_LEAST_ONCE"] = 1;
            values[valuesById[2] = "MQTT_QOS_LEVEL_EXACTLY_ONCE"] = 2;
            return values;
        })();

        args.MQTTTLSOptions = (function() {

            /**
             * Properties of a MQTTTLSOptions.
             * @memberof protos.args
             * @interface IMQTTTLSOptions
             * @property {string|null} [caFile] MQTTTLSOptions caFile
             * @property {string|null} [certFile] MQTTTLSOptions certFile
             * @property {string|null} [keyFile] MQTTTLSOptions keyFile
             * @property {boolean|null} [skipVerify] MQTTTLSOptions skipVerify
             */

            /**
             * Constructs a new MQTTTLSOptions.
             * @memberof protos.args
             * @classdesc Represents a MQTTTLSOptions.
             * @implements IMQTTTLSOptions
             * @constructor
             * @param {protos.args.IMQTTTLSOptions=} [properties] Properties to set
             */
            function MQTTTLSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTTLSOptions caFile.
             * @member {string} caFile
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.caFile = "";

            /**
             * MQTTTLSOptions certFile.
             * @member {string} certFile
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.certFile = "";

            /**
             * MQTTTLSOptions keyFile.
             * @member {string} keyFile
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.keyFile = "";

            /**
             * MQTTTLSOptions skipVerify.
             * @member {boolean} skipVerify
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.skipVerify = false;

            /**
             * Creates a new MQTTTLSOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions=} [properties] Properties to set
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions instance
             */
            MQTTTLSOptions.create = function create(properties) {
                return new MQTTTLSOptions(properties);
            };

            /**
             * Encodes the specified MQTTTLSOptions message. Does not implicitly {@link protos.args.MQTTTLSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions} message MQTTTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTTLSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.caFile != null && Object.hasOwnProperty.call(message, "caFile"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.caFile);
                if (message.certFile != null && Object.hasOwnProperty.call(message, "certFile"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.certFile);
                if (message.keyFile != null && Object.hasOwnProperty.call(message, "keyFile"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyFile);
                if (message.skipVerify != null && Object.hasOwnProperty.call(message, "skipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.skipVerify);
                return writer;
            };

            /**
             * Encodes the specified MQTTTLSOptions message, length delimited. Does not implicitly {@link protos.args.MQTTTLSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions} message MQTTTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTTLSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTTLSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTTLSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTTLSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.caFile = reader.string();
                        break;
                    case 2:
                        message.certFile = reader.string();
                        break;
                    case 3:
                        message.keyFile = reader.string();
                        break;
                    case 4:
                        message.skipVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTTLSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTTLSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTTLSOptions message.
             * @function verify
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTTLSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.caFile != null && message.hasOwnProperty("caFile"))
                    if (!$util.isString(message.caFile))
                        return "caFile: string expected";
                if (message.certFile != null && message.hasOwnProperty("certFile"))
                    if (!$util.isString(message.certFile))
                        return "certFile: string expected";
                if (message.keyFile != null && message.hasOwnProperty("keyFile"))
                    if (!$util.isString(message.keyFile))
                        return "keyFile: string expected";
                if (message.skipVerify != null && message.hasOwnProperty("skipVerify"))
                    if (typeof message.skipVerify !== "boolean")
                        return "skipVerify: boolean expected";
                return null;
            };

            /**
             * Creates a MQTTTLSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             */
            MQTTTLSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTTLSOptions)
                    return object;
                var message = new $root.protos.args.MQTTTLSOptions();
                if (object.caFile != null)
                    message.caFile = String(object.caFile);
                if (object.certFile != null)
                    message.certFile = String(object.certFile);
                if (object.keyFile != null)
                    message.keyFile = String(object.keyFile);
                if (object.skipVerify != null)
                    message.skipVerify = Boolean(object.skipVerify);
                return message;
            };

            /**
             * Creates a plain object from a MQTTTLSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.MQTTTLSOptions} message MQTTTLSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTTLSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.caFile = "";
                    object.certFile = "";
                    object.keyFile = "";
                    object.skipVerify = false;
                }
                if (message.caFile != null && message.hasOwnProperty("caFile"))
                    object.caFile = message.caFile;
                if (message.certFile != null && message.hasOwnProperty("certFile"))
                    object.certFile = message.certFile;
                if (message.keyFile != null && message.hasOwnProperty("keyFile"))
                    object.keyFile = message.keyFile;
                if (message.skipVerify != null && message.hasOwnProperty("skipVerify"))
                    object.skipVerify = message.skipVerify;
                return object;
            };

            /**
             * Converts this MQTTTLSOptions to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTTLSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTTLSOptions;
        })();

        args.MQTTConn = (function() {

            /**
             * Properties of a MQTTConn.
             * @memberof protos.args
             * @interface IMQTTConn
             * @property {string|null} [address] MQTTConn address
             * @property {number|null} [connTimeoutSeconds] MQTTConn connTimeoutSeconds
             * @property {string|null} [clientId] MQTTConn clientId
             * @property {protos.args.MQTTQoSLevel|null} [qosLevel] MQTTConn qosLevel
             * @property {protos.args.IMQTTTLSOptions|null} [tlsOptions] MQTTConn tlsOptions
             */

            /**
             * Constructs a new MQTTConn.
             * @memberof protos.args
             * @classdesc Represents a MQTTConn.
             * @implements IMQTTConn
             * @constructor
             * @param {protos.args.IMQTTConn=} [properties] Properties to set
             */
            function MQTTConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTConn address.
             * @member {string} address
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.address = "";

            /**
             * MQTTConn connTimeoutSeconds.
             * @member {number} connTimeoutSeconds
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.connTimeoutSeconds = 0;

            /**
             * MQTTConn clientId.
             * @member {string} clientId
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.clientId = "";

            /**
             * MQTTConn qosLevel.
             * @member {protos.args.MQTTQoSLevel} qosLevel
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.qosLevel = 0;

            /**
             * MQTTConn tlsOptions.
             * @member {protos.args.IMQTTTLSOptions|null|undefined} tlsOptions
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.tlsOptions = null;

            /**
             * Creates a new MQTTConn instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn=} [properties] Properties to set
             * @returns {protos.args.MQTTConn} MQTTConn instance
             */
            MQTTConn.create = function create(properties) {
                return new MQTTConn(properties);
            };

            /**
             * Encodes the specified MQTTConn message. Does not implicitly {@link protos.args.MQTTConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn} message MQTTConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.connTimeoutSeconds != null && Object.hasOwnProperty.call(message, "connTimeoutSeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.connTimeoutSeconds);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientId);
                if (message.qosLevel != null && Object.hasOwnProperty.call(message, "qosLevel"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.qosLevel);
                if (message.tlsOptions != null && Object.hasOwnProperty.call(message, "tlsOptions"))
                    $root.protos.args.MQTTTLSOptions.encode(message.tlsOptions, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MQTTConn message, length delimited. Does not implicitly {@link protos.args.MQTTConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn} message MQTTConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTConn} MQTTConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 3:
                        message.connTimeoutSeconds = reader.uint32();
                        break;
                    case 4:
                        message.clientId = reader.string();
                        break;
                    case 5:
                        message.qosLevel = reader.int32();
                        break;
                    case 6:
                        message.tlsOptions = $root.protos.args.MQTTTLSOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTConn} MQTTConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTConn message.
             * @function verify
             * @memberof protos.args.MQTTConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.connTimeoutSeconds != null && message.hasOwnProperty("connTimeoutSeconds"))
                    if (!$util.isInteger(message.connTimeoutSeconds))
                        return "connTimeoutSeconds: integer expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.qosLevel != null && message.hasOwnProperty("qosLevel"))
                    switch (message.qosLevel) {
                    default:
                        return "qosLevel: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions")) {
                    var error = $root.protos.args.MQTTTLSOptions.verify(message.tlsOptions);
                    if (error)
                        return "tlsOptions." + error;
                }
                return null;
            };

            /**
             * Creates a MQTTConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTConn} MQTTConn
             */
            MQTTConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTConn)
                    return object;
                var message = new $root.protos.args.MQTTConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.connTimeoutSeconds != null)
                    message.connTimeoutSeconds = object.connTimeoutSeconds >>> 0;
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                switch (object.qosLevel) {
                case "MQTT_QOS_LEVEL_AT_MOST_ONCE":
                case 0:
                    message.qosLevel = 0;
                    break;
                case "MQTT_QOS_LEVEL_AT_LEAST_ONCE":
                case 1:
                    message.qosLevel = 1;
                    break;
                case "MQTT_QOS_LEVEL_EXACTLY_ONCE":
                case 2:
                    message.qosLevel = 2;
                    break;
                }
                if (object.tlsOptions != null) {
                    if (typeof object.tlsOptions !== "object")
                        throw TypeError(".protos.args.MQTTConn.tlsOptions: object expected");
                    message.tlsOptions = $root.protos.args.MQTTTLSOptions.fromObject(object.tlsOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a MQTTConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.MQTTConn} message MQTTConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.connTimeoutSeconds = 0;
                    object.clientId = "";
                    object.qosLevel = options.enums === String ? "MQTT_QOS_LEVEL_AT_MOST_ONCE" : 0;
                    object.tlsOptions = null;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.connTimeoutSeconds != null && message.hasOwnProperty("connTimeoutSeconds"))
                    object.connTimeoutSeconds = message.connTimeoutSeconds;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.qosLevel != null && message.hasOwnProperty("qosLevel"))
                    object.qosLevel = options.enums === String ? $root.protos.args.MQTTQoSLevel[message.qosLevel] : message.qosLevel;
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions"))
                    object.tlsOptions = $root.protos.args.MQTTTLSOptions.toObject(message.tlsOptions, options);
                return object;
            };

            /**
             * Converts this MQTTConn to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTConn;
        })();

        args.MQTTReadArgs = (function() {

            /**
             * Properties of a MQTTReadArgs.
             * @memberof protos.args
             * @interface IMQTTReadArgs
             * @property {string|null} [topic] MQTTReadArgs topic
             * @property {number|null} [readTimeoutSeconds] MQTTReadArgs readTimeoutSeconds
             */

            /**
             * Constructs a new MQTTReadArgs.
             * @memberof protos.args
             * @classdesc Represents a MQTTReadArgs.
             * @implements IMQTTReadArgs
             * @constructor
             * @param {protos.args.IMQTTReadArgs=} [properties] Properties to set
             */
            function MQTTReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.MQTTReadArgs
             * @instance
             */
            MQTTReadArgs.prototype.topic = "";

            /**
             * MQTTReadArgs readTimeoutSeconds.
             * @member {number} readTimeoutSeconds
             * @memberof protos.args.MQTTReadArgs
             * @instance
             */
            MQTTReadArgs.prototype.readTimeoutSeconds = 0;

            /**
             * Creates a new MQTTReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs=} [properties] Properties to set
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs instance
             */
            MQTTReadArgs.create = function create(properties) {
                return new MQTTReadArgs(properties);
            };

            /**
             * Encodes the specified MQTTReadArgs message. Does not implicitly {@link protos.args.MQTTReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs} message MQTTReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.readTimeoutSeconds != null && Object.hasOwnProperty.call(message, "readTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.readTimeoutSeconds);
                return writer;
            };

            /**
             * Encodes the specified MQTTReadArgs message, length delimited. Does not implicitly {@link protos.args.MQTTReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs} message MQTTReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.readTimeoutSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTReadArgs message.
             * @function verify
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.readTimeoutSeconds != null && message.hasOwnProperty("readTimeoutSeconds"))
                    if (!$util.isInteger(message.readTimeoutSeconds))
                        return "readTimeoutSeconds: integer expected";
                return null;
            };

            /**
             * Creates a MQTTReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             */
            MQTTReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTReadArgs)
                    return object;
                var message = new $root.protos.args.MQTTReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.readTimeoutSeconds != null)
                    message.readTimeoutSeconds = object.readTimeoutSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a MQTTReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.MQTTReadArgs} message MQTTReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.readTimeoutSeconds = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.readTimeoutSeconds != null && message.hasOwnProperty("readTimeoutSeconds"))
                    object.readTimeoutSeconds = message.readTimeoutSeconds;
                return object;
            };

            /**
             * Converts this MQTTReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTReadArgs;
        })();

        args.MQTTWriteArgs = (function() {

            /**
             * Properties of a MQTTWriteArgs.
             * @memberof protos.args
             * @interface IMQTTWriteArgs
             * @property {string|null} [topic] MQTTWriteArgs topic
             * @property {number|null} [writeTimeoutSeconds] MQTTWriteArgs writeTimeoutSeconds
             */

            /**
             * Constructs a new MQTTWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a MQTTWriteArgs.
             * @implements IMQTTWriteArgs
             * @constructor
             * @param {protos.args.IMQTTWriteArgs=} [properties] Properties to set
             */
            function MQTTWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             */
            MQTTWriteArgs.prototype.topic = "";

            /**
             * MQTTWriteArgs writeTimeoutSeconds.
             * @member {number} writeTimeoutSeconds
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             */
            MQTTWriteArgs.prototype.writeTimeoutSeconds = 0;

            /**
             * Creates a new MQTTWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs=} [properties] Properties to set
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs instance
             */
            MQTTWriteArgs.create = function create(properties) {
                return new MQTTWriteArgs(properties);
            };

            /**
             * Encodes the specified MQTTWriteArgs message. Does not implicitly {@link protos.args.MQTTWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs} message MQTTWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.writeTimeoutSeconds != null && Object.hasOwnProperty.call(message, "writeTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.writeTimeoutSeconds);
                return writer;
            };

            /**
             * Encodes the specified MQTTWriteArgs message, length delimited. Does not implicitly {@link protos.args.MQTTWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs} message MQTTWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.writeTimeoutSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTWriteArgs message.
             * @function verify
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.writeTimeoutSeconds != null && message.hasOwnProperty("writeTimeoutSeconds"))
                    if (!$util.isInteger(message.writeTimeoutSeconds))
                        return "writeTimeoutSeconds: integer expected";
                return null;
            };

            /**
             * Creates a MQTTWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             */
            MQTTWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTWriteArgs)
                    return object;
                var message = new $root.protos.args.MQTTWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.writeTimeoutSeconds != null)
                    message.writeTimeoutSeconds = object.writeTimeoutSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a MQTTWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.MQTTWriteArgs} message MQTTWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.writeTimeoutSeconds = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.writeTimeoutSeconds != null && message.hasOwnProperty("writeTimeoutSeconds"))
                    object.writeTimeoutSeconds = message.writeTimeoutSeconds;
                return object;
            };

            /**
             * Converts this MQTTWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTWriteArgs;
        })();

        args.GCPPubSubConn = (function() {

            /**
             * Properties of a GCPPubSubConn.
             * @memberof protos.args
             * @interface IGCPPubSubConn
             * @property {string|null} [projectId] GCPPubSubConn projectId
             */

            /**
             * Constructs a new GCPPubSubConn.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubConn.
             * @implements IGCPPubSubConn
             * @constructor
             * @param {protos.args.IGCPPubSubConn=} [properties] Properties to set
             */
            function GCPPubSubConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubConn projectId.
             * @member {string} projectId
             * @memberof protos.args.GCPPubSubConn
             * @instance
             */
            GCPPubSubConn.prototype.projectId = "";

            /**
             * Creates a new GCPPubSubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn instance
             */
            GCPPubSubConn.create = function create(properties) {
                return new GCPPubSubConn(properties);
            };

            /**
             * Encodes the specified GCPPubSubConn message. Does not implicitly {@link protos.args.GCPPubSubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn} message GCPPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.projectId != null && Object.hasOwnProperty.call(message, "projectId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectId);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubConn message, length delimited. Does not implicitly {@link protos.args.GCPPubSubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn} message GCPPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.projectId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubConn message.
             * @function verify
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.projectId != null && message.hasOwnProperty("projectId"))
                    if (!$util.isString(message.projectId))
                        return "projectId: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             */
            GCPPubSubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubConn)
                    return object;
                var message = new $root.protos.args.GCPPubSubConn();
                if (object.projectId != null)
                    message.projectId = String(object.projectId);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.GCPPubSubConn} message GCPPubSubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.projectId = "";
                if (message.projectId != null && message.hasOwnProperty("projectId"))
                    object.projectId = message.projectId;
                return object;
            };

            /**
             * Converts this GCPPubSubConn to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubConn;
        })();

        args.GCPPubSubReadArgs = (function() {

            /**
             * Properties of a GCPPubSubReadArgs.
             * @memberof protos.args
             * @interface IGCPPubSubReadArgs
             * @property {string|null} [subscriptionId] GCPPubSubReadArgs subscriptionId
             * @property {boolean|null} [ackMessages] GCPPubSubReadArgs ackMessages
             */

            /**
             * Constructs a new GCPPubSubReadArgs.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubReadArgs.
             * @implements IGCPPubSubReadArgs
             * @constructor
             * @param {protos.args.IGCPPubSubReadArgs=} [properties] Properties to set
             */
            function GCPPubSubReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubReadArgs subscriptionId.
             * @member {string} subscriptionId
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             */
            GCPPubSubReadArgs.prototype.subscriptionId = "";

            /**
             * GCPPubSubReadArgs ackMessages.
             * @member {boolean} ackMessages
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             */
            GCPPubSubReadArgs.prototype.ackMessages = false;

            /**
             * Creates a new GCPPubSubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs instance
             */
            GCPPubSubReadArgs.create = function create(properties) {
                return new GCPPubSubReadArgs(properties);
            };

            /**
             * Encodes the specified GCPPubSubReadArgs message. Does not implicitly {@link protos.args.GCPPubSubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs} message GCPPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subscriptionId != null && Object.hasOwnProperty.call(message, "subscriptionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subscriptionId);
                if (message.ackMessages != null && Object.hasOwnProperty.call(message, "ackMessages"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ackMessages);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubReadArgs message, length delimited. Does not implicitly {@link protos.args.GCPPubSubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs} message GCPPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subscriptionId = reader.string();
                        break;
                    case 2:
                        message.ackMessages = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubReadArgs message.
             * @function verify
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    if (!$util.isString(message.subscriptionId))
                        return "subscriptionId: string expected";
                if (message.ackMessages != null && message.hasOwnProperty("ackMessages"))
                    if (typeof message.ackMessages !== "boolean")
                        return "ackMessages: boolean expected";
                return null;
            };

            /**
             * Creates a GCPPubSubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             */
            GCPPubSubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubReadArgs)
                    return object;
                var message = new $root.protos.args.GCPPubSubReadArgs();
                if (object.subscriptionId != null)
                    message.subscriptionId = String(object.subscriptionId);
                if (object.ackMessages != null)
                    message.ackMessages = Boolean(object.ackMessages);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.GCPPubSubReadArgs} message GCPPubSubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.subscriptionId = "";
                    object.ackMessages = false;
                }
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    object.subscriptionId = message.subscriptionId;
                if (message.ackMessages != null && message.hasOwnProperty("ackMessages"))
                    object.ackMessages = message.ackMessages;
                return object;
            };

            /**
             * Converts this GCPPubSubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubReadArgs;
        })();

        args.GCPPubSubWriteArgs = (function() {

            /**
             * Properties of a GCPPubSubWriteArgs.
             * @memberof protos.args
             * @interface IGCPPubSubWriteArgs
             * @property {string|null} [topicId] GCPPubSubWriteArgs topicId
             */

            /**
             * Constructs a new GCPPubSubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubWriteArgs.
             * @implements IGCPPubSubWriteArgs
             * @constructor
             * @param {protos.args.IGCPPubSubWriteArgs=} [properties] Properties to set
             */
            function GCPPubSubWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubWriteArgs topicId.
             * @member {string} topicId
             * @memberof protos.args.GCPPubSubWriteArgs
             * @instance
             */
            GCPPubSubWriteArgs.prototype.topicId = "";

            /**
             * Creates a new GCPPubSubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs instance
             */
            GCPPubSubWriteArgs.create = function create(properties) {
                return new GCPPubSubWriteArgs(properties);
            };

            /**
             * Encodes the specified GCPPubSubWriteArgs message. Does not implicitly {@link protos.args.GCPPubSubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs} message GCPPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topicId != null && Object.hasOwnProperty.call(message, "topicId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topicId);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubWriteArgs message, length delimited. Does not implicitly {@link protos.args.GCPPubSubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs} message GCPPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topicId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubWriteArgs message.
             * @function verify
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topicId != null && message.hasOwnProperty("topicId"))
                    if (!$util.isString(message.topicId))
                        return "topicId: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             */
            GCPPubSubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubWriteArgs)
                    return object;
                var message = new $root.protos.args.GCPPubSubWriteArgs();
                if (object.topicId != null)
                    message.topicId = String(object.topicId);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.GCPPubSubWriteArgs} message GCPPubSubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topicId = "";
                if (message.topicId != null && message.hasOwnProperty("topicId"))
                    object.topicId = message.topicId;
                return object;
            };

            /**
             * Converts this GCPPubSubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubWriteArgs;
        })();

        args.KubeMQQueueConn = (function() {

            /**
             * Properties of a KubeMQQueueConn.
             * @memberof protos.args
             * @interface IKubeMQQueueConn
             * @property {string|null} [address] KubeMQQueueConn address
             * @property {string|null} [authToken] KubeMQQueueConn authToken
             * @property {string|null} [tlsCertFile] KubeMQQueueConn tlsCertFile
             */

            /**
             * Constructs a new KubeMQQueueConn.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueConn.
             * @implements IKubeMQQueueConn
             * @constructor
             * @param {protos.args.IKubeMQQueueConn=} [properties] Properties to set
             */
            function KubeMQQueueConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueConn address.
             * @member {string} address
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.address = "";

            /**
             * KubeMQQueueConn authToken.
             * @member {string} authToken
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.authToken = "";

            /**
             * KubeMQQueueConn tlsCertFile.
             * @member {string} tlsCertFile
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.tlsCertFile = "";

            /**
             * Creates a new KubeMQQueueConn instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn instance
             */
            KubeMQQueueConn.create = function create(properties) {
                return new KubeMQQueueConn(properties);
            };

            /**
             * Encodes the specified KubeMQQueueConn message. Does not implicitly {@link protos.args.KubeMQQueueConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn} message KubeMQQueueConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.authToken);
                if (message.tlsCertFile != null && Object.hasOwnProperty.call(message, "tlsCertFile"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tlsCertFile);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueConn message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn} message KubeMQQueueConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.authToken = reader.string();
                        break;
                    case 3:
                        message.tlsCertFile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueConn message.
             * @function verify
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    if (!$util.isString(message.authToken))
                        return "authToken: string expected";
                if (message.tlsCertFile != null && message.hasOwnProperty("tlsCertFile"))
                    if (!$util.isString(message.tlsCertFile))
                        return "tlsCertFile: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             */
            KubeMQQueueConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueConn)
                    return object;
                var message = new $root.protos.args.KubeMQQueueConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.authToken != null)
                    message.authToken = String(object.authToken);
                if (object.tlsCertFile != null)
                    message.tlsCertFile = String(object.tlsCertFile);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.KubeMQQueueConn} message KubeMQQueueConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.authToken = "";
                    object.tlsCertFile = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    object.authToken = message.authToken;
                if (message.tlsCertFile != null && message.hasOwnProperty("tlsCertFile"))
                    object.tlsCertFile = message.tlsCertFile;
                return object;
            };

            /**
             * Converts this KubeMQQueueConn to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueConn;
        })();

        args.KubeMQQueueReadArgs = (function() {

            /**
             * Properties of a KubeMQQueueReadArgs.
             * @memberof protos.args
             * @interface IKubeMQQueueReadArgs
             * @property {string|null} [clientId] KubeMQQueueReadArgs clientId
             * @property {string|null} [queueName] KubeMQQueueReadArgs queueName
             */

            /**
             * Constructs a new KubeMQQueueReadArgs.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueReadArgs.
             * @implements IKubeMQQueueReadArgs
             * @constructor
             * @param {protos.args.IKubeMQQueueReadArgs=} [properties] Properties to set
             */
            function KubeMQQueueReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueReadArgs clientId.
             * @member {string} clientId
             * @memberof protos.args.KubeMQQueueReadArgs
             * @instance
             */
            KubeMQQueueReadArgs.prototype.clientId = "";

            /**
             * KubeMQQueueReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.KubeMQQueueReadArgs
             * @instance
             */
            KubeMQQueueReadArgs.prototype.queueName = "";

            /**
             * Creates a new KubeMQQueueReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs instance
             */
            KubeMQQueueReadArgs.create = function create(properties) {
                return new KubeMQQueueReadArgs(properties);
            };

            /**
             * Encodes the specified KubeMQQueueReadArgs message. Does not implicitly {@link protos.args.KubeMQQueueReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs} message KubeMQQueueReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientId);
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.queueName);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueReadArgs message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs} message KubeMQQueueReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.clientId = reader.string();
                        break;
                    case 3:
                        message.queueName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueReadArgs message.
             * @function verify
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             */
            KubeMQQueueReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueReadArgs)
                    return object;
                var message = new $root.protos.args.KubeMQQueueReadArgs();
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.KubeMQQueueReadArgs} message KubeMQQueueReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.clientId = "";
                    object.queueName = "";
                }
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                return object;
            };

            /**
             * Converts this KubeMQQueueReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueReadArgs;
        })();

        args.KubeMQQueueWriteArgs = (function() {

            /**
             * Properties of a KubeMQQueueWriteArgs.
             * @memberof protos.args
             * @interface IKubeMQQueueWriteArgs
             * @property {string|null} [clientId] KubeMQQueueWriteArgs clientId
             * @property {string|null} [queueName] KubeMQQueueWriteArgs queueName
             */

            /**
             * Constructs a new KubeMQQueueWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueWriteArgs.
             * @implements IKubeMQQueueWriteArgs
             * @constructor
             * @param {protos.args.IKubeMQQueueWriteArgs=} [properties] Properties to set
             */
            function KubeMQQueueWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueWriteArgs clientId.
             * @member {string} clientId
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @instance
             */
            KubeMQQueueWriteArgs.prototype.clientId = "";

            /**
             * KubeMQQueueWriteArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @instance
             */
            KubeMQQueueWriteArgs.prototype.queueName = "";

            /**
             * Creates a new KubeMQQueueWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs instance
             */
            KubeMQQueueWriteArgs.create = function create(properties) {
                return new KubeMQQueueWriteArgs(properties);
            };

            /**
             * Encodes the specified KubeMQQueueWriteArgs message. Does not implicitly {@link protos.args.KubeMQQueueWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs} message KubeMQQueueWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientId);
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queueName);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueWriteArgs message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs} message KubeMQQueueWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.clientId = reader.string();
                        break;
                    case 2:
                        message.queueName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueWriteArgs message.
             * @function verify
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             */
            KubeMQQueueWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueWriteArgs)
                    return object;
                var message = new $root.protos.args.KubeMQQueueWriteArgs();
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.KubeMQQueueWriteArgs} message KubeMQQueueWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.clientId = "";
                    object.queueName = "";
                }
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                return object;
            };

            /**
             * Converts this KubeMQQueueWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueWriteArgs;
        })();

        args.PostgresConn = (function() {

            /**
             * Properties of a PostgresConn.
             * @memberof protos.args
             * @interface IPostgresConn
             * @property {string|null} [address] PostgresConn address
             * @property {number|null} [port] PostgresConn port
             * @property {string|null} [username] PostgresConn username
             * @property {string|null} [password] PostgresConn password
             * @property {string|null} [database] PostgresConn database
             * @property {boolean|null} [useTls] PostgresConn useTls
             * @property {boolean|null} [insecureTls] PostgresConn insecureTls
             */

            /**
             * Constructs a new PostgresConn.
             * @memberof protos.args
             * @classdesc Represents a PostgresConn.
             * @implements IPostgresConn
             * @constructor
             * @param {protos.args.IPostgresConn=} [properties] Properties to set
             */
            function PostgresConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PostgresConn address.
             * @member {string} address
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.address = "";

            /**
             * PostgresConn port.
             * @member {number} port
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.port = 0;

            /**
             * PostgresConn username.
             * @member {string} username
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.username = "";

            /**
             * PostgresConn password.
             * @member {string} password
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.password = "";

            /**
             * PostgresConn database.
             * @member {string} database
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.database = "";

            /**
             * PostgresConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.useTls = false;

            /**
             * PostgresConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.insecureTls = false;

            /**
             * Creates a new PostgresConn instance using the specified properties.
             * @function create
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn=} [properties] Properties to set
             * @returns {protos.args.PostgresConn} PostgresConn instance
             */
            PostgresConn.create = function create(properties) {
                return new PostgresConn(properties);
            };

            /**
             * Encodes the specified PostgresConn message. Does not implicitly {@link protos.args.PostgresConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn} message PostgresConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.database);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.useTls);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.insecureTls);
                return writer;
            };

            /**
             * Encodes the specified PostgresConn message, length delimited. Does not implicitly {@link protos.args.PostgresConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn} message PostgresConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PostgresConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PostgresConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PostgresConn} PostgresConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PostgresConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.username = reader.string();
                        break;
                    case 4:
                        message.password = reader.string();
                        break;
                    case 5:
                        message.database = reader.string();
                        break;
                    case 6:
                        message.useTls = reader.bool();
                        break;
                    case 7:
                        message.insecureTls = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PostgresConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PostgresConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PostgresConn} PostgresConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PostgresConn message.
             * @function verify
             * @memberof protos.args.PostgresConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PostgresConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                return null;
            };

            /**
             * Creates a PostgresConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PostgresConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PostgresConn} PostgresConn
             */
            PostgresConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PostgresConn)
                    return object;
                var message = new $root.protos.args.PostgresConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.database != null)
                    message.database = String(object.database);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                return message;
            };

            /**
             * Creates a plain object from a PostgresConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.PostgresConn} message PostgresConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PostgresConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.port = 0;
                    object.username = "";
                    object.password = "";
                    object.database = "";
                    object.useTls = false;
                    object.insecureTls = false;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                return object;
            };

            /**
             * Converts this PostgresConn to JSON.
             * @function toJSON
             * @memberof protos.args.PostgresConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PostgresConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PostgresConn;
        })();

        args.PostgresReadArgs = (function() {

            /**
             * Properties of a PostgresReadArgs.
             * @memberof protos.args
             * @interface IPostgresReadArgs
             * @property {string|null} [replicationSlotName] PostgresReadArgs replicationSlotName
             * @property {string|null} [publisherName] PostgresReadArgs publisherName
             */

            /**
             * Constructs a new PostgresReadArgs.
             * @memberof protos.args
             * @classdesc Represents a PostgresReadArgs.
             * @implements IPostgresReadArgs
             * @constructor
             * @param {protos.args.IPostgresReadArgs=} [properties] Properties to set
             */
            function PostgresReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PostgresReadArgs replicationSlotName.
             * @member {string} replicationSlotName
             * @memberof protos.args.PostgresReadArgs
             * @instance
             */
            PostgresReadArgs.prototype.replicationSlotName = "";

            /**
             * PostgresReadArgs publisherName.
             * @member {string} publisherName
             * @memberof protos.args.PostgresReadArgs
             * @instance
             */
            PostgresReadArgs.prototype.publisherName = "";

            /**
             * Creates a new PostgresReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs=} [properties] Properties to set
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs instance
             */
            PostgresReadArgs.create = function create(properties) {
                return new PostgresReadArgs(properties);
            };

            /**
             * Encodes the specified PostgresReadArgs message. Does not implicitly {@link protos.args.PostgresReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs} message PostgresReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replicationSlotName != null && Object.hasOwnProperty.call(message, "replicationSlotName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.replicationSlotName);
                if (message.publisherName != null && Object.hasOwnProperty.call(message, "publisherName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.publisherName);
                return writer;
            };

            /**
             * Encodes the specified PostgresReadArgs message, length delimited. Does not implicitly {@link protos.args.PostgresReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs} message PostgresReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PostgresReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PostgresReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.replicationSlotName = reader.string();
                        break;
                    case 3:
                        message.publisherName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PostgresReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PostgresReadArgs message.
             * @function verify
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PostgresReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replicationSlotName != null && message.hasOwnProperty("replicationSlotName"))
                    if (!$util.isString(message.replicationSlotName))
                        return "replicationSlotName: string expected";
                if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                    if (!$util.isString(message.publisherName))
                        return "publisherName: string expected";
                return null;
            };

            /**
             * Creates a PostgresReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             */
            PostgresReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PostgresReadArgs)
                    return object;
                var message = new $root.protos.args.PostgresReadArgs();
                if (object.replicationSlotName != null)
                    message.replicationSlotName = String(object.replicationSlotName);
                if (object.publisherName != null)
                    message.publisherName = String(object.publisherName);
                return message;
            };

            /**
             * Creates a plain object from a PostgresReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.PostgresReadArgs} message PostgresReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PostgresReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.replicationSlotName = "";
                    object.publisherName = "";
                }
                if (message.replicationSlotName != null && message.hasOwnProperty("replicationSlotName"))
                    object.replicationSlotName = message.replicationSlotName;
                if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                    object.publisherName = message.publisherName;
                return object;
            };

            /**
             * Converts this PostgresReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PostgresReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PostgresReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PostgresReadArgs;
        })();

        /**
         * SubscriptionType enum.
         * @name protos.args.SubscriptionType
         * @enum {number}
         * @property {number} SHARED=0 SHARED value
         * @property {number} EXCLUSIVE=1 EXCLUSIVE value
         * @property {number} FAILOVER=2 FAILOVER value
         * @property {number} KEYSHARED=3 KEYSHARED value
         */
        args.SubscriptionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SHARED"] = 0;
            values[valuesById[1] = "EXCLUSIVE"] = 1;
            values[valuesById[2] = "FAILOVER"] = 2;
            values[valuesById[3] = "KEYSHARED"] = 3;
            return values;
        })();

        args.PulsarConn = (function() {

            /**
             * Properties of a PulsarConn.
             * @memberof protos.args
             * @interface IPulsarConn
             * @property {string|null} [dsn] PulsarConn dsn
             * @property {number|null} [connectTimeoutSeconds] PulsarConn connectTimeoutSeconds
             * @property {boolean|null} [insecureTls] PulsarConn insecureTls
             * @property {Uint8Array|null} [tlsClientCert] PulsarConn tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] PulsarConn tlsClientKey
             */

            /**
             * Constructs a new PulsarConn.
             * @memberof protos.args
             * @classdesc Represents a PulsarConn.
             * @implements IPulsarConn
             * @constructor
             * @param {protos.args.IPulsarConn=} [properties] Properties to set
             */
            function PulsarConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarConn dsn.
             * @member {string} dsn
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.dsn = "";

            /**
             * PulsarConn connectTimeoutSeconds.
             * @member {number} connectTimeoutSeconds
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.connectTimeoutSeconds = 0;

            /**
             * PulsarConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.insecureTls = false;

            /**
             * PulsarConn tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * PulsarConn tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * Creates a new PulsarConn instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn=} [properties] Properties to set
             * @returns {protos.args.PulsarConn} PulsarConn instance
             */
            PulsarConn.create = function create(properties) {
                return new PulsarConn(properties);
            };

            /**
             * Encodes the specified PulsarConn message. Does not implicitly {@link protos.args.PulsarConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn} message PulsarConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.connectTimeoutSeconds != null && Object.hasOwnProperty.call(message, "connectTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.connectTimeoutSeconds);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.insecureTls);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.tlsClientKey);
                return writer;
            };

            /**
             * Encodes the specified PulsarConn message, length delimited. Does not implicitly {@link protos.args.PulsarConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn} message PulsarConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarConn} PulsarConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.connectTimeoutSeconds = reader.uint32();
                        break;
                    case 3:
                        message.insecureTls = reader.bool();
                        break;
                    case 4:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 5:
                        message.tlsClientKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarConn} PulsarConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarConn message.
             * @function verify
             * @memberof protos.args.PulsarConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.connectTimeoutSeconds != null && message.hasOwnProperty("connectTimeoutSeconds"))
                    if (!$util.isInteger(message.connectTimeoutSeconds))
                        return "connectTimeoutSeconds: integer expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                return null;
            };

            /**
             * Creates a PulsarConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarConn} PulsarConn
             */
            PulsarConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarConn)
                    return object;
                var message = new $root.protos.args.PulsarConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.connectTimeoutSeconds != null)
                    message.connectTimeoutSeconds = object.connectTimeoutSeconds >>> 0;
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                return message;
            };

            /**
             * Creates a plain object from a PulsarConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.PulsarConn} message PulsarConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.connectTimeoutSeconds = 0;
                    object.insecureTls = false;
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.connectTimeoutSeconds != null && message.hasOwnProperty("connectTimeoutSeconds"))
                    object.connectTimeoutSeconds = message.connectTimeoutSeconds;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                return object;
            };

            /**
             * Converts this PulsarConn to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarConn;
        })();

        args.PulsarReadArgs = (function() {

            /**
             * Properties of a PulsarReadArgs.
             * @memberof protos.args
             * @interface IPulsarReadArgs
             * @property {string|null} [topic] PulsarReadArgs topic
             * @property {string|null} [subscriptionName] PulsarReadArgs subscriptionName
             * @property {protos.args.SubscriptionType|null} [subscriptionType] PulsarReadArgs subscriptionType
             */

            /**
             * Constructs a new PulsarReadArgs.
             * @memberof protos.args
             * @classdesc Represents a PulsarReadArgs.
             * @implements IPulsarReadArgs
             * @constructor
             * @param {protos.args.IPulsarReadArgs=} [properties] Properties to set
             */
            function PulsarReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.topic = "";

            /**
             * PulsarReadArgs subscriptionName.
             * @member {string} subscriptionName
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.subscriptionName = "";

            /**
             * PulsarReadArgs subscriptionType.
             * @member {protos.args.SubscriptionType} subscriptionType
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.subscriptionType = 0;

            /**
             * Creates a new PulsarReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs=} [properties] Properties to set
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs instance
             */
            PulsarReadArgs.create = function create(properties) {
                return new PulsarReadArgs(properties);
            };

            /**
             * Encodes the specified PulsarReadArgs message. Does not implicitly {@link protos.args.PulsarReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs} message PulsarReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.subscriptionName != null && Object.hasOwnProperty.call(message, "subscriptionName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.subscriptionName);
                if (message.subscriptionType != null && Object.hasOwnProperty.call(message, "subscriptionType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.subscriptionType);
                return writer;
            };

            /**
             * Encodes the specified PulsarReadArgs message, length delimited. Does not implicitly {@link protos.args.PulsarReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs} message PulsarReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.subscriptionName = reader.string();
                        break;
                    case 3:
                        message.subscriptionType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarReadArgs message.
             * @function verify
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    if (!$util.isString(message.subscriptionName))
                        return "subscriptionName: string expected";
                if (message.subscriptionType != null && message.hasOwnProperty("subscriptionType"))
                    switch (message.subscriptionType) {
                    default:
                        return "subscriptionType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a PulsarReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             */
            PulsarReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarReadArgs)
                    return object;
                var message = new $root.protos.args.PulsarReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.subscriptionName != null)
                    message.subscriptionName = String(object.subscriptionName);
                switch (object.subscriptionType) {
                case "SHARED":
                case 0:
                    message.subscriptionType = 0;
                    break;
                case "EXCLUSIVE":
                case 1:
                    message.subscriptionType = 1;
                    break;
                case "FAILOVER":
                case 2:
                    message.subscriptionType = 2;
                    break;
                case "KEYSHARED":
                case 3:
                    message.subscriptionType = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a PulsarReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.PulsarReadArgs} message PulsarReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.subscriptionName = "";
                    object.subscriptionType = options.enums === String ? "SHARED" : 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    object.subscriptionName = message.subscriptionName;
                if (message.subscriptionType != null && message.hasOwnProperty("subscriptionType"))
                    object.subscriptionType = options.enums === String ? $root.protos.args.SubscriptionType[message.subscriptionType] : message.subscriptionType;
                return object;
            };

            /**
             * Converts this PulsarReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarReadArgs;
        })();

        args.PulsarWriteArgs = (function() {

            /**
             * Properties of a PulsarWriteArgs.
             * @memberof protos.args
             * @interface IPulsarWriteArgs
             * @property {string|null} [topic] PulsarWriteArgs topic
             */

            /**
             * Constructs a new PulsarWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a PulsarWriteArgs.
             * @implements IPulsarWriteArgs
             * @constructor
             * @param {protos.args.IPulsarWriteArgs=} [properties] Properties to set
             */
            function PulsarWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.PulsarWriteArgs
             * @instance
             */
            PulsarWriteArgs.prototype.topic = "";

            /**
             * Creates a new PulsarWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs=} [properties] Properties to set
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs instance
             */
            PulsarWriteArgs.create = function create(properties) {
                return new PulsarWriteArgs(properties);
            };

            /**
             * Encodes the specified PulsarWriteArgs message. Does not implicitly {@link protos.args.PulsarWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs} message PulsarWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified PulsarWriteArgs message, length delimited. Does not implicitly {@link protos.args.PulsarWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs} message PulsarWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarWriteArgs message.
             * @function verify
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a PulsarWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             */
            PulsarWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarWriteArgs)
                    return object;
                var message = new $root.protos.args.PulsarWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a PulsarWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.PulsarWriteArgs} message PulsarWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this PulsarWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarWriteArgs;
        })();

        args.RabbitConn = (function() {

            /**
             * Properties of a RabbitConn.
             * @memberof protos.args
             * @interface IRabbitConn
             * @property {string|null} [address] RabbitConn address
             * @property {boolean|null} [useTls] RabbitConn useTls
             * @property {boolean|null} [insecureTls] RabbitConn insecureTls
             */

            /**
             * Constructs a new RabbitConn.
             * @memberof protos.args
             * @classdesc Represents a RabbitConn.
             * @implements IRabbitConn
             * @constructor
             * @param {protos.args.IRabbitConn=} [properties] Properties to set
             */
            function RabbitConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitConn address.
             * @member {string} address
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.address = "";

            /**
             * RabbitConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.useTls = false;

            /**
             * RabbitConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.insecureTls = false;

            /**
             * Creates a new RabbitConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn=} [properties] Properties to set
             * @returns {protos.args.RabbitConn} RabbitConn instance
             */
            RabbitConn.create = function create(properties) {
                return new RabbitConn(properties);
            };

            /**
             * Encodes the specified RabbitConn message. Does not implicitly {@link protos.args.RabbitConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn} message RabbitConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.useTls);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.insecureTls);
                return writer;
            };

            /**
             * Encodes the specified RabbitConn message, length delimited. Does not implicitly {@link protos.args.RabbitConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn} message RabbitConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitConn} RabbitConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.useTls = reader.bool();
                        break;
                    case 3:
                        message.insecureTls = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitConn} RabbitConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitConn message.
             * @function verify
             * @memberof protos.args.RabbitConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitConn} RabbitConn
             */
            RabbitConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitConn)
                    return object;
                var message = new $root.protos.args.RabbitConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                return message;
            };

            /**
             * Creates a plain object from a RabbitConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.RabbitConn} message RabbitConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.useTls = false;
                    object.insecureTls = false;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                return object;
            };

            /**
             * Converts this RabbitConn to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitConn;
        })();

        args.RabbitReadArgs = (function() {

            /**
             * Properties of a RabbitReadArgs.
             * @memberof protos.args
             * @interface IRabbitReadArgs
             * @property {string|null} [exchangeName] RabbitReadArgs exchangeName
             * @property {string|null} [queueName] RabbitReadArgs queueName
             * @property {string|null} [bindingKey] RabbitReadArgs bindingKey
             * @property {boolean|null} [queueExclusive] RabbitReadArgs queueExclusive
             * @property {boolean|null} [queueDeclare] RabbitReadArgs queueDeclare
             * @property {boolean|null} [queueDurable] RabbitReadArgs queueDurable
             * @property {boolean|null} [autoAck] RabbitReadArgs autoAck
             * @property {string|null} [consumerTag] RabbitReadArgs consumerTag
             * @property {boolean|null} [queueDelete] RabbitReadArgs queueDelete
             */

            /**
             * Constructs a new RabbitReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitReadArgs.
             * @implements IRabbitReadArgs
             * @constructor
             * @param {protos.args.IRabbitReadArgs=} [properties] Properties to set
             */
            function RabbitReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitReadArgs exchangeName.
             * @member {string} exchangeName
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.exchangeName = "";

            /**
             * RabbitReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueName = "";

            /**
             * RabbitReadArgs bindingKey.
             * @member {string} bindingKey
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.bindingKey = "";

            /**
             * RabbitReadArgs queueExclusive.
             * @member {boolean} queueExclusive
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueExclusive = false;

            /**
             * RabbitReadArgs queueDeclare.
             * @member {boolean} queueDeclare
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDeclare = false;

            /**
             * RabbitReadArgs queueDurable.
             * @member {boolean} queueDurable
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDurable = false;

            /**
             * RabbitReadArgs autoAck.
             * @member {boolean} autoAck
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.autoAck = false;

            /**
             * RabbitReadArgs consumerTag.
             * @member {string} consumerTag
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.consumerTag = "";

            /**
             * RabbitReadArgs queueDelete.
             * @member {boolean} queueDelete
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDelete = false;

            /**
             * Creates a new RabbitReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs instance
             */
            RabbitReadArgs.create = function create(properties) {
                return new RabbitReadArgs(properties);
            };

            /**
             * Encodes the specified RabbitReadArgs message. Does not implicitly {@link protos.args.RabbitReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs} message RabbitReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exchangeName != null && Object.hasOwnProperty.call(message, "exchangeName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.exchangeName);
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queueName);
                if (message.bindingKey != null && Object.hasOwnProperty.call(message, "bindingKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.bindingKey);
                if (message.queueExclusive != null && Object.hasOwnProperty.call(message, "queueExclusive"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.queueExclusive);
                if (message.queueDeclare != null && Object.hasOwnProperty.call(message, "queueDeclare"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.queueDeclare);
                if (message.queueDurable != null && Object.hasOwnProperty.call(message, "queueDurable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.queueDurable);
                if (message.autoAck != null && Object.hasOwnProperty.call(message, "autoAck"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.autoAck);
                if (message.consumerTag != null && Object.hasOwnProperty.call(message, "consumerTag"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.consumerTag);
                if (message.queueDelete != null && Object.hasOwnProperty.call(message, "queueDelete"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.queueDelete);
                return writer;
            };

            /**
             * Encodes the specified RabbitReadArgs message, length delimited. Does not implicitly {@link protos.args.RabbitReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs} message RabbitReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exchangeName = reader.string();
                        break;
                    case 2:
                        message.queueName = reader.string();
                        break;
                    case 3:
                        message.bindingKey = reader.string();
                        break;
                    case 4:
                        message.queueExclusive = reader.bool();
                        break;
                    case 5:
                        message.queueDeclare = reader.bool();
                        break;
                    case 6:
                        message.queueDurable = reader.bool();
                        break;
                    case 7:
                        message.autoAck = reader.bool();
                        break;
                    case 8:
                        message.consumerTag = reader.string();
                        break;
                    case 9:
                        message.queueDelete = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitReadArgs message.
             * @function verify
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    if (!$util.isString(message.exchangeName))
                        return "exchangeName: string expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.bindingKey != null && message.hasOwnProperty("bindingKey"))
                    if (!$util.isString(message.bindingKey))
                        return "bindingKey: string expected";
                if (message.queueExclusive != null && message.hasOwnProperty("queueExclusive"))
                    if (typeof message.queueExclusive !== "boolean")
                        return "queueExclusive: boolean expected";
                if (message.queueDeclare != null && message.hasOwnProperty("queueDeclare"))
                    if (typeof message.queueDeclare !== "boolean")
                        return "queueDeclare: boolean expected";
                if (message.queueDurable != null && message.hasOwnProperty("queueDurable"))
                    if (typeof message.queueDurable !== "boolean")
                        return "queueDurable: boolean expected";
                if (message.autoAck != null && message.hasOwnProperty("autoAck"))
                    if (typeof message.autoAck !== "boolean")
                        return "autoAck: boolean expected";
                if (message.consumerTag != null && message.hasOwnProperty("consumerTag"))
                    if (!$util.isString(message.consumerTag))
                        return "consumerTag: string expected";
                if (message.queueDelete != null && message.hasOwnProperty("queueDelete"))
                    if (typeof message.queueDelete !== "boolean")
                        return "queueDelete: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             */
            RabbitReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitReadArgs)
                    return object;
                var message = new $root.protos.args.RabbitReadArgs();
                if (object.exchangeName != null)
                    message.exchangeName = String(object.exchangeName);
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.bindingKey != null)
                    message.bindingKey = String(object.bindingKey);
                if (object.queueExclusive != null)
                    message.queueExclusive = Boolean(object.queueExclusive);
                if (object.queueDeclare != null)
                    message.queueDeclare = Boolean(object.queueDeclare);
                if (object.queueDurable != null)
                    message.queueDurable = Boolean(object.queueDurable);
                if (object.autoAck != null)
                    message.autoAck = Boolean(object.autoAck);
                if (object.consumerTag != null)
                    message.consumerTag = String(object.consumerTag);
                if (object.queueDelete != null)
                    message.queueDelete = Boolean(object.queueDelete);
                return message;
            };

            /**
             * Creates a plain object from a RabbitReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.RabbitReadArgs} message RabbitReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.exchangeName = "";
                    object.queueName = "";
                    object.bindingKey = "";
                    object.queueExclusive = false;
                    object.queueDeclare = false;
                    object.queueDurable = false;
                    object.autoAck = false;
                    object.consumerTag = "";
                    object.queueDelete = false;
                }
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    object.exchangeName = message.exchangeName;
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.bindingKey != null && message.hasOwnProperty("bindingKey"))
                    object.bindingKey = message.bindingKey;
                if (message.queueExclusive != null && message.hasOwnProperty("queueExclusive"))
                    object.queueExclusive = message.queueExclusive;
                if (message.queueDeclare != null && message.hasOwnProperty("queueDeclare"))
                    object.queueDeclare = message.queueDeclare;
                if (message.queueDurable != null && message.hasOwnProperty("queueDurable"))
                    object.queueDurable = message.queueDurable;
                if (message.autoAck != null && message.hasOwnProperty("autoAck"))
                    object.autoAck = message.autoAck;
                if (message.consumerTag != null && message.hasOwnProperty("consumerTag"))
                    object.consumerTag = message.consumerTag;
                if (message.queueDelete != null && message.hasOwnProperty("queueDelete"))
                    object.queueDelete = message.queueDelete;
                return object;
            };

            /**
             * Converts this RabbitReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitReadArgs;
        })();

        args.RabbitWriteArgs = (function() {

            /**
             * Properties of a RabbitWriteArgs.
             * @memberof protos.args
             * @interface IRabbitWriteArgs
             * @property {string|null} [exchangeName] RabbitWriteArgs exchangeName
             * @property {string|null} [routingKey] RabbitWriteArgs routingKey
             * @property {string|null} [appId] RabbitWriteArgs appId
             * @property {string|null} [exchangeType] RabbitWriteArgs exchangeType
             * @property {boolean|null} [exchangeDeclare] RabbitWriteArgs exchangeDeclare
             * @property {boolean|null} [exchangeDurable] RabbitWriteArgs exchangeDurable
             * @property {boolean|null} [exchangeAutoDelete] RabbitWriteArgs exchangeAutoDelete
             */

            /**
             * Constructs a new RabbitWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitWriteArgs.
             * @implements IRabbitWriteArgs
             * @constructor
             * @param {protos.args.IRabbitWriteArgs=} [properties] Properties to set
             */
            function RabbitWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitWriteArgs exchangeName.
             * @member {string} exchangeName
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeName = "";

            /**
             * RabbitWriteArgs routingKey.
             * @member {string} routingKey
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.routingKey = "";

            /**
             * RabbitWriteArgs appId.
             * @member {string} appId
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.appId = "";

            /**
             * RabbitWriteArgs exchangeType.
             * @member {string} exchangeType
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeType = "";

            /**
             * RabbitWriteArgs exchangeDeclare.
             * @member {boolean} exchangeDeclare
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeDeclare = false;

            /**
             * RabbitWriteArgs exchangeDurable.
             * @member {boolean} exchangeDurable
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeDurable = false;

            /**
             * RabbitWriteArgs exchangeAutoDelete.
             * @member {boolean} exchangeAutoDelete
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeAutoDelete = false;

            /**
             * Creates a new RabbitWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs instance
             */
            RabbitWriteArgs.create = function create(properties) {
                return new RabbitWriteArgs(properties);
            };

            /**
             * Encodes the specified RabbitWriteArgs message. Does not implicitly {@link protos.args.RabbitWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs} message RabbitWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exchangeName != null && Object.hasOwnProperty.call(message, "exchangeName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.exchangeName);
                if (message.routingKey != null && Object.hasOwnProperty.call(message, "routingKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.routingKey);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.appId);
                if (message.exchangeType != null && Object.hasOwnProperty.call(message, "exchangeType"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.exchangeType);
                if (message.exchangeDeclare != null && Object.hasOwnProperty.call(message, "exchangeDeclare"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.exchangeDeclare);
                if (message.exchangeDurable != null && Object.hasOwnProperty.call(message, "exchangeDurable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.exchangeDurable);
                if (message.exchangeAutoDelete != null && Object.hasOwnProperty.call(message, "exchangeAutoDelete"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.exchangeAutoDelete);
                return writer;
            };

            /**
             * Encodes the specified RabbitWriteArgs message, length delimited. Does not implicitly {@link protos.args.RabbitWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs} message RabbitWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exchangeName = reader.string();
                        break;
                    case 2:
                        message.routingKey = reader.string();
                        break;
                    case 3:
                        message.appId = reader.string();
                        break;
                    case 4:
                        message.exchangeType = reader.string();
                        break;
                    case 5:
                        message.exchangeDeclare = reader.bool();
                        break;
                    case 6:
                        message.exchangeDurable = reader.bool();
                        break;
                    case 7:
                        message.exchangeAutoDelete = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitWriteArgs message.
             * @function verify
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    if (!$util.isString(message.exchangeName))
                        return "exchangeName: string expected";
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    if (!$util.isString(message.routingKey))
                        return "routingKey: string expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!$util.isString(message.appId))
                        return "appId: string expected";
                if (message.exchangeType != null && message.hasOwnProperty("exchangeType"))
                    if (!$util.isString(message.exchangeType))
                        return "exchangeType: string expected";
                if (message.exchangeDeclare != null && message.hasOwnProperty("exchangeDeclare"))
                    if (typeof message.exchangeDeclare !== "boolean")
                        return "exchangeDeclare: boolean expected";
                if (message.exchangeDurable != null && message.hasOwnProperty("exchangeDurable"))
                    if (typeof message.exchangeDurable !== "boolean")
                        return "exchangeDurable: boolean expected";
                if (message.exchangeAutoDelete != null && message.hasOwnProperty("exchangeAutoDelete"))
                    if (typeof message.exchangeAutoDelete !== "boolean")
                        return "exchangeAutoDelete: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             */
            RabbitWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitWriteArgs)
                    return object;
                var message = new $root.protos.args.RabbitWriteArgs();
                if (object.exchangeName != null)
                    message.exchangeName = String(object.exchangeName);
                if (object.routingKey != null)
                    message.routingKey = String(object.routingKey);
                if (object.appId != null)
                    message.appId = String(object.appId);
                if (object.exchangeType != null)
                    message.exchangeType = String(object.exchangeType);
                if (object.exchangeDeclare != null)
                    message.exchangeDeclare = Boolean(object.exchangeDeclare);
                if (object.exchangeDurable != null)
                    message.exchangeDurable = Boolean(object.exchangeDurable);
                if (object.exchangeAutoDelete != null)
                    message.exchangeAutoDelete = Boolean(object.exchangeAutoDelete);
                return message;
            };

            /**
             * Creates a plain object from a RabbitWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.RabbitWriteArgs} message RabbitWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.exchangeName = "";
                    object.routingKey = "";
                    object.appId = "";
                    object.exchangeType = "";
                    object.exchangeDeclare = false;
                    object.exchangeDurable = false;
                    object.exchangeAutoDelete = false;
                }
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    object.exchangeName = message.exchangeName;
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    object.routingKey = message.routingKey;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = message.appId;
                if (message.exchangeType != null && message.hasOwnProperty("exchangeType"))
                    object.exchangeType = message.exchangeType;
                if (message.exchangeDeclare != null && message.hasOwnProperty("exchangeDeclare"))
                    object.exchangeDeclare = message.exchangeDeclare;
                if (message.exchangeDurable != null && message.hasOwnProperty("exchangeDurable"))
                    object.exchangeDurable = message.exchangeDurable;
                if (message.exchangeAutoDelete != null && message.hasOwnProperty("exchangeAutoDelete"))
                    object.exchangeAutoDelete = message.exchangeAutoDelete;
                return object;
            };

            /**
             * Converts this RabbitWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitWriteArgs;
        })();

        args.RabbitStreamsConn = (function() {

            /**
             * Properties of a RabbitStreamsConn.
             * @memberof protos.args
             * @interface IRabbitStreamsConn
             * @property {string|null} [dsn] RabbitStreamsConn dsn
             * @property {boolean|null} [useTls] RabbitStreamsConn useTls
             * @property {boolean|null} [insecureTls] RabbitStreamsConn insecureTls
             * @property {string|null} [username] RabbitStreamsConn username
             * @property {string|null} [password] RabbitStreamsConn password
             * @property {string|null} [clientName] RabbitStreamsConn clientName
             */

            /**
             * Constructs a new RabbitStreamsConn.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsConn.
             * @implements IRabbitStreamsConn
             * @constructor
             * @param {protos.args.IRabbitStreamsConn=} [properties] Properties to set
             */
            function RabbitStreamsConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsConn dsn.
             * @member {string} dsn
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.dsn = "";

            /**
             * RabbitStreamsConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.useTls = false;

            /**
             * RabbitStreamsConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.insecureTls = false;

            /**
             * RabbitStreamsConn username.
             * @member {string} username
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.username = "";

            /**
             * RabbitStreamsConn password.
             * @member {string} password
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.password = "";

            /**
             * RabbitStreamsConn clientName.
             * @member {string} clientName
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.clientName = "";

            /**
             * Creates a new RabbitStreamsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn instance
             */
            RabbitStreamsConn.create = function create(properties) {
                return new RabbitStreamsConn(properties);
            };

            /**
             * Encodes the specified RabbitStreamsConn message. Does not implicitly {@link protos.args.RabbitStreamsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn} message RabbitStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.useTls);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.insecureTls);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
                if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.clientName);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsConn message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn} message RabbitStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.useTls = reader.bool();
                        break;
                    case 3:
                        message.insecureTls = reader.bool();
                        break;
                    case 4:
                        message.username = reader.string();
                        break;
                    case 5:
                        message.password = reader.string();
                        break;
                    case 6:
                        message.clientName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsConn message.
             * @function verify
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.clientName != null && message.hasOwnProperty("clientName"))
                    if (!$util.isString(message.clientName))
                        return "clientName: string expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             */
            RabbitStreamsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsConn)
                    return object;
                var message = new $root.protos.args.RabbitStreamsConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.clientName != null)
                    message.clientName = String(object.clientName);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.RabbitStreamsConn} message RabbitStreamsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.useTls = false;
                    object.insecureTls = false;
                    object.username = "";
                    object.password = "";
                    object.clientName = "";
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.clientName != null && message.hasOwnProperty("clientName"))
                    object.clientName = message.clientName;
                return object;
            };

            /**
             * Converts this RabbitStreamsConn to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsConn;
        })();

        args.RabbitStreamsOffsetOptions = (function() {

            /**
             * Properties of a RabbitStreamsOffsetOptions.
             * @memberof protos.args
             * @interface IRabbitStreamsOffsetOptions
             * @property {number|Long|null} [specificOffset] RabbitStreamsOffsetOptions specificOffset
             * @property {number|Long|null} [lastOffset] RabbitStreamsOffsetOptions lastOffset
             * @property {boolean|null} [lastConsumed] RabbitStreamsOffsetOptions lastConsumed
             * @property {boolean|null} [firstOffset] RabbitStreamsOffsetOptions firstOffset
             * @property {boolean|null} [nextOffset] RabbitStreamsOffsetOptions nextOffset
             */

            /**
             * Constructs a new RabbitStreamsOffsetOptions.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsOffsetOptions.
             * @implements IRabbitStreamsOffsetOptions
             * @constructor
             * @param {protos.args.IRabbitStreamsOffsetOptions=} [properties] Properties to set
             */
            function RabbitStreamsOffsetOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsOffsetOptions specificOffset.
             * @member {number|Long} specificOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.specificOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RabbitStreamsOffsetOptions lastOffset.
             * @member {number|Long} lastOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.lastOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RabbitStreamsOffsetOptions lastConsumed.
             * @member {boolean} lastConsumed
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.lastConsumed = false;

            /**
             * RabbitStreamsOffsetOptions firstOffset.
             * @member {boolean} firstOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.firstOffset = false;

            /**
             * RabbitStreamsOffsetOptions nextOffset.
             * @member {boolean} nextOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.nextOffset = false;

            /**
             * Creates a new RabbitStreamsOffsetOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions instance
             */
            RabbitStreamsOffsetOptions.create = function create(properties) {
                return new RabbitStreamsOffsetOptions(properties);
            };

            /**
             * Encodes the specified RabbitStreamsOffsetOptions message. Does not implicitly {@link protos.args.RabbitStreamsOffsetOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsOffsetOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.specificOffset != null && Object.hasOwnProperty.call(message, "specificOffset"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.specificOffset);
                if (message.lastOffset != null && Object.hasOwnProperty.call(message, "lastOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lastOffset);
                if (message.lastConsumed != null && Object.hasOwnProperty.call(message, "lastConsumed"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.lastConsumed);
                if (message.firstOffset != null && Object.hasOwnProperty.call(message, "firstOffset"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.firstOffset);
                if (message.nextOffset != null && Object.hasOwnProperty.call(message, "nextOffset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.nextOffset);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsOffsetOptions message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsOffsetOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsOffsetOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsOffsetOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsOffsetOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsOffsetOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.specificOffset = reader.uint64();
                        break;
                    case 2:
                        message.lastOffset = reader.uint64();
                        break;
                    case 3:
                        message.lastConsumed = reader.bool();
                        break;
                    case 4:
                        message.firstOffset = reader.bool();
                        break;
                    case 5:
                        message.nextOffset = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsOffsetOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsOffsetOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsOffsetOptions message.
             * @function verify
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsOffsetOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.specificOffset != null && message.hasOwnProperty("specificOffset"))
                    if (!$util.isInteger(message.specificOffset) && !(message.specificOffset && $util.isInteger(message.specificOffset.low) && $util.isInteger(message.specificOffset.high)))
                        return "specificOffset: integer|Long expected";
                if (message.lastOffset != null && message.hasOwnProperty("lastOffset"))
                    if (!$util.isInteger(message.lastOffset) && !(message.lastOffset && $util.isInteger(message.lastOffset.low) && $util.isInteger(message.lastOffset.high)))
                        return "lastOffset: integer|Long expected";
                if (message.lastConsumed != null && message.hasOwnProperty("lastConsumed"))
                    if (typeof message.lastConsumed !== "boolean")
                        return "lastConsumed: boolean expected";
                if (message.firstOffset != null && message.hasOwnProperty("firstOffset"))
                    if (typeof message.firstOffset !== "boolean")
                        return "firstOffset: boolean expected";
                if (message.nextOffset != null && message.hasOwnProperty("nextOffset"))
                    if (typeof message.nextOffset !== "boolean")
                        return "nextOffset: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsOffsetOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             */
            RabbitStreamsOffsetOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsOffsetOptions)
                    return object;
                var message = new $root.protos.args.RabbitStreamsOffsetOptions();
                if (object.specificOffset != null)
                    if ($util.Long)
                        (message.specificOffset = $util.Long.fromValue(object.specificOffset)).unsigned = true;
                    else if (typeof object.specificOffset === "string")
                        message.specificOffset = parseInt(object.specificOffset, 10);
                    else if (typeof object.specificOffset === "number")
                        message.specificOffset = object.specificOffset;
                    else if (typeof object.specificOffset === "object")
                        message.specificOffset = new $util.LongBits(object.specificOffset.low >>> 0, object.specificOffset.high >>> 0).toNumber(true);
                if (object.lastOffset != null)
                    if ($util.Long)
                        (message.lastOffset = $util.Long.fromValue(object.lastOffset)).unsigned = true;
                    else if (typeof object.lastOffset === "string")
                        message.lastOffset = parseInt(object.lastOffset, 10);
                    else if (typeof object.lastOffset === "number")
                        message.lastOffset = object.lastOffset;
                    else if (typeof object.lastOffset === "object")
                        message.lastOffset = new $util.LongBits(object.lastOffset.low >>> 0, object.lastOffset.high >>> 0).toNumber(true);
                if (object.lastConsumed != null)
                    message.lastConsumed = Boolean(object.lastConsumed);
                if (object.firstOffset != null)
                    message.firstOffset = Boolean(object.firstOffset);
                if (object.nextOffset != null)
                    message.nextOffset = Boolean(object.nextOffset);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsOffsetOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.RabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsOffsetOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.specificOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.specificOffset = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.lastOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastOffset = options.longs === String ? "0" : 0;
                    object.lastConsumed = false;
                    object.firstOffset = false;
                    object.nextOffset = false;
                }
                if (message.specificOffset != null && message.hasOwnProperty("specificOffset"))
                    if (typeof message.specificOffset === "number")
                        object.specificOffset = options.longs === String ? String(message.specificOffset) : message.specificOffset;
                    else
                        object.specificOffset = options.longs === String ? $util.Long.prototype.toString.call(message.specificOffset) : options.longs === Number ? new $util.LongBits(message.specificOffset.low >>> 0, message.specificOffset.high >>> 0).toNumber(true) : message.specificOffset;
                if (message.lastOffset != null && message.hasOwnProperty("lastOffset"))
                    if (typeof message.lastOffset === "number")
                        object.lastOffset = options.longs === String ? String(message.lastOffset) : message.lastOffset;
                    else
                        object.lastOffset = options.longs === String ? $util.Long.prototype.toString.call(message.lastOffset) : options.longs === Number ? new $util.LongBits(message.lastOffset.low >>> 0, message.lastOffset.high >>> 0).toNumber(true) : message.lastOffset;
                if (message.lastConsumed != null && message.hasOwnProperty("lastConsumed"))
                    object.lastConsumed = message.lastConsumed;
                if (message.firstOffset != null && message.hasOwnProperty("firstOffset"))
                    object.firstOffset = message.firstOffset;
                if (message.nextOffset != null && message.hasOwnProperty("nextOffset"))
                    object.nextOffset = message.nextOffset;
                return object;
            };

            /**
             * Converts this RabbitStreamsOffsetOptions to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsOffsetOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsOffsetOptions;
        })();

        args.RabbitStreamsReadArgs = (function() {

            /**
             * Properties of a RabbitStreamsReadArgs.
             * @memberof protos.args
             * @interface IRabbitStreamsReadArgs
             * @property {string|null} [stream] RabbitStreamsReadArgs stream
             * @property {boolean|null} [declareStream] RabbitStreamsReadArgs declareStream
             * @property {string|null} [declareStreamSize] RabbitStreamsReadArgs declareStreamSize
             * @property {protos.args.IRabbitStreamsOffsetOptions|null} [offsetOptions] RabbitStreamsReadArgs offsetOptions
             */

            /**
             * Constructs a new RabbitStreamsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsReadArgs.
             * @implements IRabbitStreamsReadArgs
             * @constructor
             * @param {protos.args.IRabbitStreamsReadArgs=} [properties] Properties to set
             */
            function RabbitStreamsReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsReadArgs stream.
             * @member {string} stream
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.stream = "";

            /**
             * RabbitStreamsReadArgs declareStream.
             * @member {boolean} declareStream
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.declareStream = false;

            /**
             * RabbitStreamsReadArgs declareStreamSize.
             * @member {string} declareStreamSize
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.declareStreamSize = "";

            /**
             * RabbitStreamsReadArgs offsetOptions.
             * @member {protos.args.IRabbitStreamsOffsetOptions|null|undefined} offsetOptions
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.offsetOptions = null;

            /**
             * Creates a new RabbitStreamsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs instance
             */
            RabbitStreamsReadArgs.create = function create(properties) {
                return new RabbitStreamsReadArgs(properties);
            };

            /**
             * Encodes the specified RabbitStreamsReadArgs message. Does not implicitly {@link protos.args.RabbitStreamsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs} message RabbitStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.declareStream != null && Object.hasOwnProperty.call(message, "declareStream"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.declareStream);
                if (message.declareStreamSize != null && Object.hasOwnProperty.call(message, "declareStreamSize"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.declareStreamSize);
                if (message.offsetOptions != null && Object.hasOwnProperty.call(message, "offsetOptions"))
                    $root.protos.args.RabbitStreamsOffsetOptions.encode(message.offsetOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsReadArgs message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs} message RabbitStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.declareStream = reader.bool();
                        break;
                    case 3:
                        message.declareStreamSize = reader.string();
                        break;
                    case 4:
                        message.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsReadArgs message.
             * @function verify
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    if (typeof message.declareStream !== "boolean")
                        return "declareStream: boolean expected";
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    if (!$util.isString(message.declareStreamSize))
                        return "declareStreamSize: string expected";
                if (message.offsetOptions != null && message.hasOwnProperty("offsetOptions")) {
                    var error = $root.protos.args.RabbitStreamsOffsetOptions.verify(message.offsetOptions);
                    if (error)
                        return "offsetOptions." + error;
                }
                return null;
            };

            /**
             * Creates a RabbitStreamsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             */
            RabbitStreamsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsReadArgs)
                    return object;
                var message = new $root.protos.args.RabbitStreamsReadArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.declareStream != null)
                    message.declareStream = Boolean(object.declareStream);
                if (object.declareStreamSize != null)
                    message.declareStreamSize = String(object.declareStreamSize);
                if (object.offsetOptions != null) {
                    if (typeof object.offsetOptions !== "object")
                        throw TypeError(".protos.args.RabbitStreamsReadArgs.offsetOptions: object expected");
                    message.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.fromObject(object.offsetOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.RabbitStreamsReadArgs} message RabbitStreamsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.declareStream = false;
                    object.declareStreamSize = "";
                    object.offsetOptions = null;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    object.declareStream = message.declareStream;
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    object.declareStreamSize = message.declareStreamSize;
                if (message.offsetOptions != null && message.hasOwnProperty("offsetOptions"))
                    object.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.toObject(message.offsetOptions, options);
                return object;
            };

            /**
             * Converts this RabbitStreamsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsReadArgs;
        })();

        args.RabbitStreamsWriteArgs = (function() {

            /**
             * Properties of a RabbitStreamsWriteArgs.
             * @memberof protos.args
             * @interface IRabbitStreamsWriteArgs
             * @property {string|null} [stream] RabbitStreamsWriteArgs stream
             * @property {boolean|null} [declareStream] RabbitStreamsWriteArgs declareStream
             * @property {string|null} [declareStreamSize] RabbitStreamsWriteArgs declareStreamSize
             */

            /**
             * Constructs a new RabbitStreamsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsWriteArgs.
             * @implements IRabbitStreamsWriteArgs
             * @constructor
             * @param {protos.args.IRabbitStreamsWriteArgs=} [properties] Properties to set
             */
            function RabbitStreamsWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsWriteArgs stream.
             * @member {string} stream
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.stream = "";

            /**
             * RabbitStreamsWriteArgs declareStream.
             * @member {boolean} declareStream
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.declareStream = false;

            /**
             * RabbitStreamsWriteArgs declareStreamSize.
             * @member {string} declareStreamSize
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.declareStreamSize = "";

            /**
             * Creates a new RabbitStreamsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs instance
             */
            RabbitStreamsWriteArgs.create = function create(properties) {
                return new RabbitStreamsWriteArgs(properties);
            };

            /**
             * Encodes the specified RabbitStreamsWriteArgs message. Does not implicitly {@link protos.args.RabbitStreamsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs} message RabbitStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.declareStream != null && Object.hasOwnProperty.call(message, "declareStream"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.declareStream);
                if (message.declareStreamSize != null && Object.hasOwnProperty.call(message, "declareStreamSize"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.declareStreamSize);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsWriteArgs message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs} message RabbitStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.declareStream = reader.bool();
                        break;
                    case 3:
                        message.declareStreamSize = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsWriteArgs message.
             * @function verify
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    if (typeof message.declareStream !== "boolean")
                        return "declareStream: boolean expected";
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    if (!$util.isString(message.declareStreamSize))
                        return "declareStreamSize: string expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             */
            RabbitStreamsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsWriteArgs)
                    return object;
                var message = new $root.protos.args.RabbitStreamsWriteArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.declareStream != null)
                    message.declareStream = Boolean(object.declareStream);
                if (object.declareStreamSize != null)
                    message.declareStreamSize = String(object.declareStreamSize);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.RabbitStreamsWriteArgs} message RabbitStreamsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.declareStream = false;
                    object.declareStreamSize = "";
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    object.declareStream = message.declareStream;
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    object.declareStreamSize = message.declareStreamSize;
                return object;
            };

            /**
             * Converts this RabbitStreamsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsWriteArgs;
        })();

        args.RedisPubSubConn = (function() {

            /**
             * Properties of a RedisPubSubConn.
             * @memberof protos.args
             * @interface IRedisPubSubConn
             * @property {string|null} [address] RedisPubSubConn address
             * @property {string|null} [username] RedisPubSubConn username
             * @property {string|null} [password] RedisPubSubConn password
             */

            /**
             * Constructs a new RedisPubSubConn.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubConn.
             * @implements IRedisPubSubConn
             * @constructor
             * @param {protos.args.IRedisPubSubConn=} [properties] Properties to set
             */
            function RedisPubSubConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubConn address.
             * @member {string} address
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.address = "";

            /**
             * RedisPubSubConn username.
             * @member {string} username
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.username = "";

            /**
             * RedisPubSubConn password.
             * @member {string} password
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.password = "";

            /**
             * Creates a new RedisPubSubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn instance
             */
            RedisPubSubConn.create = function create(properties) {
                return new RedisPubSubConn(properties);
            };

            /**
             * Encodes the specified RedisPubSubConn message. Does not implicitly {@link protos.args.RedisPubSubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn} message RedisPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubConn message, length delimited. Does not implicitly {@link protos.args.RedisPubSubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn} message RedisPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.password = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubConn message.
             * @function verify
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                return null;
            };

            /**
             * Creates a RedisPubSubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             */
            RedisPubSubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubConn)
                    return object;
                var message = new $root.protos.args.RedisPubSubConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.RedisPubSubConn} message RedisPubSubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.username = "";
                    object.password = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                return object;
            };

            /**
             * Converts this RedisPubSubConn to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubConn;
        })();

        args.RedisPubSubReadArgs = (function() {

            /**
             * Properties of a RedisPubSubReadArgs.
             * @memberof protos.args
             * @interface IRedisPubSubReadArgs
             * @property {number|null} [database] RedisPubSubReadArgs database
             * @property {Array.<string>|null} [channel] RedisPubSubReadArgs channel
             */

            /**
             * Constructs a new RedisPubSubReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubReadArgs.
             * @implements IRedisPubSubReadArgs
             * @constructor
             * @param {protos.args.IRedisPubSubReadArgs=} [properties] Properties to set
             */
            function RedisPubSubReadArgs(properties) {
                this.channel = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubReadArgs database.
             * @member {number} database
             * @memberof protos.args.RedisPubSubReadArgs
             * @instance
             */
            RedisPubSubReadArgs.prototype.database = 0;

            /**
             * RedisPubSubReadArgs channel.
             * @member {Array.<string>} channel
             * @memberof protos.args.RedisPubSubReadArgs
             * @instance
             */
            RedisPubSubReadArgs.prototype.channel = $util.emptyArray;

            /**
             * Creates a new RedisPubSubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs instance
             */
            RedisPubSubReadArgs.create = function create(properties) {
                return new RedisPubSubReadArgs(properties);
            };

            /**
             * Encodes the specified RedisPubSubReadArgs message. Does not implicitly {@link protos.args.RedisPubSubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs} message RedisPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.database);
                if (message.channel != null && message.channel.length)
                    for (var i = 0; i < message.channel.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel[i]);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubReadArgs message, length delimited. Does not implicitly {@link protos.args.RedisPubSubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs} message RedisPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.uint32();
                        break;
                    case 2:
                        if (!(message.channel && message.channel.length))
                            message.channel = [];
                        message.channel.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubReadArgs message.
             * @function verify
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isInteger(message.database))
                        return "database: integer expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    if (!Array.isArray(message.channel))
                        return "channel: array expected";
                    for (var i = 0; i < message.channel.length; ++i)
                        if (!$util.isString(message.channel[i]))
                            return "channel: string[] expected";
                }
                return null;
            };

            /**
             * Creates a RedisPubSubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             */
            RedisPubSubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubReadArgs)
                    return object;
                var message = new $root.protos.args.RedisPubSubReadArgs();
                if (object.database != null)
                    message.database = object.database >>> 0;
                if (object.channel) {
                    if (!Array.isArray(object.channel))
                        throw TypeError(".protos.args.RedisPubSubReadArgs.channel: array expected");
                    message.channel = [];
                    for (var i = 0; i < object.channel.length; ++i)
                        message.channel[i] = String(object.channel[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.RedisPubSubReadArgs} message RedisPubSubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.channel = [];
                if (options.defaults)
                    object.database = 0;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.channel && message.channel.length) {
                    object.channel = [];
                    for (var j = 0; j < message.channel.length; ++j)
                        object.channel[j] = message.channel[j];
                }
                return object;
            };

            /**
             * Converts this RedisPubSubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubReadArgs;
        })();

        args.RedisPubSubWriteArgs = (function() {

            /**
             * Properties of a RedisPubSubWriteArgs.
             * @memberof protos.args
             * @interface IRedisPubSubWriteArgs
             * @property {number|null} [database] RedisPubSubWriteArgs database
             * @property {Array.<string>|null} [channel] RedisPubSubWriteArgs channel
             */

            /**
             * Constructs a new RedisPubSubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubWriteArgs.
             * @implements IRedisPubSubWriteArgs
             * @constructor
             * @param {protos.args.IRedisPubSubWriteArgs=} [properties] Properties to set
             */
            function RedisPubSubWriteArgs(properties) {
                this.channel = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubWriteArgs database.
             * @member {number} database
             * @memberof protos.args.RedisPubSubWriteArgs
             * @instance
             */
            RedisPubSubWriteArgs.prototype.database = 0;

            /**
             * RedisPubSubWriteArgs channel.
             * @member {Array.<string>} channel
             * @memberof protos.args.RedisPubSubWriteArgs
             * @instance
             */
            RedisPubSubWriteArgs.prototype.channel = $util.emptyArray;

            /**
             * Creates a new RedisPubSubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs instance
             */
            RedisPubSubWriteArgs.create = function create(properties) {
                return new RedisPubSubWriteArgs(properties);
            };

            /**
             * Encodes the specified RedisPubSubWriteArgs message. Does not implicitly {@link protos.args.RedisPubSubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs} message RedisPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.database);
                if (message.channel != null && message.channel.length)
                    for (var i = 0; i < message.channel.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel[i]);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubWriteArgs message, length delimited. Does not implicitly {@link protos.args.RedisPubSubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs} message RedisPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.uint32();
                        break;
                    case 2:
                        if (!(message.channel && message.channel.length))
                            message.channel = [];
                        message.channel.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubWriteArgs message.
             * @function verify
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isInteger(message.database))
                        return "database: integer expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    if (!Array.isArray(message.channel))
                        return "channel: array expected";
                    for (var i = 0; i < message.channel.length; ++i)
                        if (!$util.isString(message.channel[i]))
                            return "channel: string[] expected";
                }
                return null;
            };

            /**
             * Creates a RedisPubSubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             */
            RedisPubSubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubWriteArgs)
                    return object;
                var message = new $root.protos.args.RedisPubSubWriteArgs();
                if (object.database != null)
                    message.database = object.database >>> 0;
                if (object.channel) {
                    if (!Array.isArray(object.channel))
                        throw TypeError(".protos.args.RedisPubSubWriteArgs.channel: array expected");
                    message.channel = [];
                    for (var i = 0; i < object.channel.length; ++i)
                        message.channel[i] = String(object.channel[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.RedisPubSubWriteArgs} message RedisPubSubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.channel = [];
                if (options.defaults)
                    object.database = 0;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.channel && message.channel.length) {
                    object.channel = [];
                    for (var j = 0; j < message.channel.length; ++j)
                        object.channel[j] = message.channel[j];
                }
                return object;
            };

            /**
             * Converts this RedisPubSubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubWriteArgs;
        })();

        /**
         * OffsetStart enum.
         * @name protos.args.OffsetStart
         * @enum {number}
         * @property {number} Latest=0 Latest value
         * @property {number} Oldest=1 Oldest value
         */
        args.OffsetStart = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Latest"] = 0;
            values[valuesById[1] = "Oldest"] = 1;
            return values;
        })();

        args.RedisStreamsConn = (function() {

            /**
             * Properties of a RedisStreamsConn.
             * @memberof protos.args
             * @interface IRedisStreamsConn
             * @property {string|null} [address] RedisStreamsConn address
             * @property {string|null} [username] RedisStreamsConn username
             * @property {string|null} [password] RedisStreamsConn password
             */

            /**
             * Constructs a new RedisStreamsConn.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsConn.
             * @implements IRedisStreamsConn
             * @constructor
             * @param {protos.args.IRedisStreamsConn=} [properties] Properties to set
             */
            function RedisStreamsConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsConn address.
             * @member {string} address
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.address = "";

            /**
             * RedisStreamsConn username.
             * @member {string} username
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.username = "";

            /**
             * RedisStreamsConn password.
             * @member {string} password
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.password = "";

            /**
             * Creates a new RedisStreamsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn instance
             */
            RedisStreamsConn.create = function create(properties) {
                return new RedisStreamsConn(properties);
            };

            /**
             * Encodes the specified RedisStreamsConn message. Does not implicitly {@link protos.args.RedisStreamsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn} message RedisStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsConn message, length delimited. Does not implicitly {@link protos.args.RedisStreamsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn} message RedisStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.password = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsConn message.
             * @function verify
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                return null;
            };

            /**
             * Creates a RedisStreamsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             */
            RedisStreamsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsConn)
                    return object;
                var message = new $root.protos.args.RedisStreamsConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.RedisStreamsConn} message RedisStreamsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.username = "";
                    object.password = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                return object;
            };

            /**
             * Converts this RedisStreamsConn to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsConn;
        })();

        args.CreateConsumerConfig = (function() {

            /**
             * Properties of a CreateConsumerConfig.
             * @memberof protos.args
             * @interface ICreateConsumerConfig
             * @property {boolean|null} [createStreams] CreateConsumerConfig createStreams
             * @property {boolean|null} [recreateConsumerGroup] CreateConsumerConfig recreateConsumerGroup
             * @property {protos.args.OffsetStart|null} [offsetStart] CreateConsumerConfig offsetStart
             */

            /**
             * Constructs a new CreateConsumerConfig.
             * @memberof protos.args
             * @classdesc Represents a CreateConsumerConfig.
             * @implements ICreateConsumerConfig
             * @constructor
             * @param {protos.args.ICreateConsumerConfig=} [properties] Properties to set
             */
            function CreateConsumerConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateConsumerConfig createStreams.
             * @member {boolean} createStreams
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.createStreams = false;

            /**
             * CreateConsumerConfig recreateConsumerGroup.
             * @member {boolean} recreateConsumerGroup
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.recreateConsumerGroup = false;

            /**
             * CreateConsumerConfig offsetStart.
             * @member {protos.args.OffsetStart} offsetStart
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.offsetStart = 0;

            /**
             * Creates a new CreateConsumerConfig instance using the specified properties.
             * @function create
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig=} [properties] Properties to set
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig instance
             */
            CreateConsumerConfig.create = function create(properties) {
                return new CreateConsumerConfig(properties);
            };

            /**
             * Encodes the specified CreateConsumerConfig message. Does not implicitly {@link protos.args.CreateConsumerConfig.verify|verify} messages.
             * @function encode
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig} message CreateConsumerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateConsumerConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.createStreams != null && Object.hasOwnProperty.call(message, "createStreams"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.createStreams);
                if (message.recreateConsumerGroup != null && Object.hasOwnProperty.call(message, "recreateConsumerGroup"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recreateConsumerGroup);
                if (message.offsetStart != null && Object.hasOwnProperty.call(message, "offsetStart"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.offsetStart);
                return writer;
            };

            /**
             * Encodes the specified CreateConsumerConfig message, length delimited. Does not implicitly {@link protos.args.CreateConsumerConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig} message CreateConsumerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateConsumerConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateConsumerConfig message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateConsumerConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.CreateConsumerConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.createStreams = reader.bool();
                        break;
                    case 2:
                        message.recreateConsumerGroup = reader.bool();
                        break;
                    case 3:
                        message.offsetStart = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateConsumerConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateConsumerConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateConsumerConfig message.
             * @function verify
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateConsumerConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.createStreams != null && message.hasOwnProperty("createStreams"))
                    if (typeof message.createStreams !== "boolean")
                        return "createStreams: boolean expected";
                if (message.recreateConsumerGroup != null && message.hasOwnProperty("recreateConsumerGroup"))
                    if (typeof message.recreateConsumerGroup !== "boolean")
                        return "recreateConsumerGroup: boolean expected";
                if (message.offsetStart != null && message.hasOwnProperty("offsetStart"))
                    switch (message.offsetStart) {
                    default:
                        return "offsetStart: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a CreateConsumerConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             */
            CreateConsumerConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.CreateConsumerConfig)
                    return object;
                var message = new $root.protos.args.CreateConsumerConfig();
                if (object.createStreams != null)
                    message.createStreams = Boolean(object.createStreams);
                if (object.recreateConsumerGroup != null)
                    message.recreateConsumerGroup = Boolean(object.recreateConsumerGroup);
                switch (object.offsetStart) {
                case "Latest":
                case 0:
                    message.offsetStart = 0;
                    break;
                case "Oldest":
                case 1:
                    message.offsetStart = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateConsumerConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.CreateConsumerConfig} message CreateConsumerConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateConsumerConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.createStreams = false;
                    object.recreateConsumerGroup = false;
                    object.offsetStart = options.enums === String ? "Latest" : 0;
                }
                if (message.createStreams != null && message.hasOwnProperty("createStreams"))
                    object.createStreams = message.createStreams;
                if (message.recreateConsumerGroup != null && message.hasOwnProperty("recreateConsumerGroup"))
                    object.recreateConsumerGroup = message.recreateConsumerGroup;
                if (message.offsetStart != null && message.hasOwnProperty("offsetStart"))
                    object.offsetStart = options.enums === String ? $root.protos.args.OffsetStart[message.offsetStart] : message.offsetStart;
                return object;
            };

            /**
             * Converts this CreateConsumerConfig to JSON.
             * @function toJSON
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateConsumerConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateConsumerConfig;
        })();

        args.RedisStreamsReadArgs = (function() {

            /**
             * Properties of a RedisStreamsReadArgs.
             * @memberof protos.args
             * @interface IRedisStreamsReadArgs
             * @property {number|null} [database] RedisStreamsReadArgs database
             * @property {Array.<string>|null} [stream] RedisStreamsReadArgs stream
             * @property {string|null} [consumerGroup] RedisStreamsReadArgs consumerGroup
             * @property {string|null} [consumerName] RedisStreamsReadArgs consumerName
             * @property {number|null} [count] RedisStreamsReadArgs count
             * @property {protos.args.ICreateConsumerConfig|null} [createConsumerConfig] RedisStreamsReadArgs createConsumerConfig
             */

            /**
             * Constructs a new RedisStreamsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsReadArgs.
             * @implements IRedisStreamsReadArgs
             * @constructor
             * @param {protos.args.IRedisStreamsReadArgs=} [properties] Properties to set
             */
            function RedisStreamsReadArgs(properties) {
                this.stream = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsReadArgs database.
             * @member {number} database
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.database = 0;

            /**
             * RedisStreamsReadArgs stream.
             * @member {Array.<string>} stream
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.stream = $util.emptyArray;

            /**
             * RedisStreamsReadArgs consumerGroup.
             * @member {string} consumerGroup
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.consumerGroup = "";

            /**
             * RedisStreamsReadArgs consumerName.
             * @member {string} consumerName
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.consumerName = "";

            /**
             * RedisStreamsReadArgs count.
             * @member {number} count
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.count = 0;

            /**
             * RedisStreamsReadArgs createConsumerConfig.
             * @member {protos.args.ICreateConsumerConfig|null|undefined} createConsumerConfig
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.createConsumerConfig = null;

            /**
             * Creates a new RedisStreamsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs instance
             */
            RedisStreamsReadArgs.create = function create(properties) {
                return new RedisStreamsReadArgs(properties);
            };

            /**
             * Encodes the specified RedisStreamsReadArgs message. Does not implicitly {@link protos.args.RedisStreamsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs} message RedisStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.database);
                if (message.stream != null && message.stream.length)
                    for (var i = 0; i < message.stream.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.stream[i]);
                if (message.consumerGroup != null && Object.hasOwnProperty.call(message, "consumerGroup"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.consumerGroup);
                if (message.consumerName != null && Object.hasOwnProperty.call(message, "consumerName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.consumerName);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.count);
                if (message.createConsumerConfig != null && Object.hasOwnProperty.call(message, "createConsumerConfig"))
                    $root.protos.args.CreateConsumerConfig.encode(message.createConsumerConfig, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsReadArgs message, length delimited. Does not implicitly {@link protos.args.RedisStreamsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs} message RedisStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.uint32();
                        break;
                    case 2:
                        if (!(message.stream && message.stream.length))
                            message.stream = [];
                        message.stream.push(reader.string());
                        break;
                    case 3:
                        message.consumerGroup = reader.string();
                        break;
                    case 4:
                        message.consumerName = reader.string();
                        break;
                    case 5:
                        message.count = reader.uint32();
                        break;
                    case 6:
                        message.createConsumerConfig = $root.protos.args.CreateConsumerConfig.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsReadArgs message.
             * @function verify
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isInteger(message.database))
                        return "database: integer expected";
                if (message.stream != null && message.hasOwnProperty("stream")) {
                    if (!Array.isArray(message.stream))
                        return "stream: array expected";
                    for (var i = 0; i < message.stream.length; ++i)
                        if (!$util.isString(message.stream[i]))
                            return "stream: string[] expected";
                }
                if (message.consumerGroup != null && message.hasOwnProperty("consumerGroup"))
                    if (!$util.isString(message.consumerGroup))
                        return "consumerGroup: string expected";
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    if (!$util.isString(message.consumerName))
                        return "consumerName: string expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                if (message.createConsumerConfig != null && message.hasOwnProperty("createConsumerConfig")) {
                    var error = $root.protos.args.CreateConsumerConfig.verify(message.createConsumerConfig);
                    if (error)
                        return "createConsumerConfig." + error;
                }
                return null;
            };

            /**
             * Creates a RedisStreamsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             */
            RedisStreamsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsReadArgs)
                    return object;
                var message = new $root.protos.args.RedisStreamsReadArgs();
                if (object.database != null)
                    message.database = object.database >>> 0;
                if (object.stream) {
                    if (!Array.isArray(object.stream))
                        throw TypeError(".protos.args.RedisStreamsReadArgs.stream: array expected");
                    message.stream = [];
                    for (var i = 0; i < object.stream.length; ++i)
                        message.stream[i] = String(object.stream[i]);
                }
                if (object.consumerGroup != null)
                    message.consumerGroup = String(object.consumerGroup);
                if (object.consumerName != null)
                    message.consumerName = String(object.consumerName);
                if (object.count != null)
                    message.count = object.count >>> 0;
                if (object.createConsumerConfig != null) {
                    if (typeof object.createConsumerConfig !== "object")
                        throw TypeError(".protos.args.RedisStreamsReadArgs.createConsumerConfig: object expected");
                    message.createConsumerConfig = $root.protos.args.CreateConsumerConfig.fromObject(object.createConsumerConfig);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.RedisStreamsReadArgs} message RedisStreamsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.stream = [];
                if (options.defaults) {
                    object.database = 0;
                    object.consumerGroup = "";
                    object.consumerName = "";
                    object.count = 0;
                    object.createConsumerConfig = null;
                }
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.stream && message.stream.length) {
                    object.stream = [];
                    for (var j = 0; j < message.stream.length; ++j)
                        object.stream[j] = message.stream[j];
                }
                if (message.consumerGroup != null && message.hasOwnProperty("consumerGroup"))
                    object.consumerGroup = message.consumerGroup;
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    object.consumerName = message.consumerName;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                if (message.createConsumerConfig != null && message.hasOwnProperty("createConsumerConfig"))
                    object.createConsumerConfig = $root.protos.args.CreateConsumerConfig.toObject(message.createConsumerConfig, options);
                return object;
            };

            /**
             * Converts this RedisStreamsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsReadArgs;
        })();

        args.RedisStreamsWriteArgs = (function() {

            /**
             * Properties of a RedisStreamsWriteArgs.
             * @memberof protos.args
             * @interface IRedisStreamsWriteArgs
             * @property {string|null} [writeId] RedisStreamsWriteArgs writeId
             * @property {Array.<string>|null} [streams] RedisStreamsWriteArgs streams
             * @property {string|null} [key] RedisStreamsWriteArgs key
             */

            /**
             * Constructs a new RedisStreamsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsWriteArgs.
             * @implements IRedisStreamsWriteArgs
             * @constructor
             * @param {protos.args.IRedisStreamsWriteArgs=} [properties] Properties to set
             */
            function RedisStreamsWriteArgs(properties) {
                this.streams = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsWriteArgs writeId.
             * @member {string} writeId
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.writeId = "";

            /**
             * RedisStreamsWriteArgs streams.
             * @member {Array.<string>} streams
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.streams = $util.emptyArray;

            /**
             * RedisStreamsWriteArgs key.
             * @member {string} key
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.key = "";

            /**
             * Creates a new RedisStreamsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs instance
             */
            RedisStreamsWriteArgs.create = function create(properties) {
                return new RedisStreamsWriteArgs(properties);
            };

            /**
             * Encodes the specified RedisStreamsWriteArgs message. Does not implicitly {@link protos.args.RedisStreamsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs} message RedisStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.writeId != null && Object.hasOwnProperty.call(message, "writeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.writeId);
                if (message.streams != null && message.streams.length)
                    for (var i = 0; i < message.streams.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.streams[i]);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.key);
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsWriteArgs message, length delimited. Does not implicitly {@link protos.args.RedisStreamsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs} message RedisStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.writeId = reader.string();
                        break;
                    case 2:
                        if (!(message.streams && message.streams.length))
                            message.streams = [];
                        message.streams.push(reader.string());
                        break;
                    case 3:
                        message.key = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsWriteArgs message.
             * @function verify
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.writeId != null && message.hasOwnProperty("writeId"))
                    if (!$util.isString(message.writeId))
                        return "writeId: string expected";
                if (message.streams != null && message.hasOwnProperty("streams")) {
                    if (!Array.isArray(message.streams))
                        return "streams: array expected";
                    for (var i = 0; i < message.streams.length; ++i)
                        if (!$util.isString(message.streams[i]))
                            return "streams: string[] expected";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                return null;
            };

            /**
             * Creates a RedisStreamsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             */
            RedisStreamsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsWriteArgs)
                    return object;
                var message = new $root.protos.args.RedisStreamsWriteArgs();
                if (object.writeId != null)
                    message.writeId = String(object.writeId);
                if (object.streams) {
                    if (!Array.isArray(object.streams))
                        throw TypeError(".protos.args.RedisStreamsWriteArgs.streams: array expected");
                    message.streams = [];
                    for (var i = 0; i < object.streams.length; ++i)
                        message.streams[i] = String(object.streams[i]);
                }
                if (object.key != null)
                    message.key = String(object.key);
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.RedisStreamsWriteArgs} message RedisStreamsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.streams = [];
                if (options.defaults) {
                    object.writeId = "";
                    object.key = "";
                }
                if (message.writeId != null && message.hasOwnProperty("writeId"))
                    object.writeId = message.writeId;
                if (message.streams && message.streams.length) {
                    object.streams = [];
                    for (var j = 0; j < message.streams.length; ++j)
                        object.streams[j] = message.streams[j];
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                return object;
            };

            /**
             * Converts this RedisStreamsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsWriteArgs;
        })();

        args.AzureServiceBusConn = (function() {

            /**
             * Properties of an AzureServiceBusConn.
             * @memberof protos.args
             * @interface IAzureServiceBusConn
             * @property {string|null} [connectionString] AzureServiceBusConn connectionString
             */

            /**
             * Constructs a new AzureServiceBusConn.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusConn.
             * @implements IAzureServiceBusConn
             * @constructor
             * @param {protos.args.IAzureServiceBusConn=} [properties] Properties to set
             */
            function AzureServiceBusConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusConn connectionString.
             * @member {string} connectionString
             * @memberof protos.args.AzureServiceBusConn
             * @instance
             */
            AzureServiceBusConn.prototype.connectionString = "";

            /**
             * Creates a new AzureServiceBusConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn instance
             */
            AzureServiceBusConn.create = function create(properties) {
                return new AzureServiceBusConn(properties);
            };

            /**
             * Encodes the specified AzureServiceBusConn message. Does not implicitly {@link protos.args.AzureServiceBusConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn} message AzureServiceBusConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionString != null && Object.hasOwnProperty.call(message, "connectionString"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionString);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusConn message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn} message AzureServiceBusConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusConn message.
             * @function verify
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    if (!$util.isString(message.connectionString))
                        return "connectionString: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             */
            AzureServiceBusConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusConn)
                    return object;
                var message = new $root.protos.args.AzureServiceBusConn();
                if (object.connectionString != null)
                    message.connectionString = String(object.connectionString);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.AzureServiceBusConn} message AzureServiceBusConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.connectionString = "";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    object.connectionString = message.connectionString;
                return object;
            };

            /**
             * Converts this AzureServiceBusConn to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusConn;
        })();

        args.AzureServiceBusReadArgs = (function() {

            /**
             * Properties of an AzureServiceBusReadArgs.
             * @memberof protos.args
             * @interface IAzureServiceBusReadArgs
             * @property {string|null} [queue] AzureServiceBusReadArgs queue
             * @property {string|null} [topic] AzureServiceBusReadArgs topic
             * @property {string|null} [subscriptionName] AzureServiceBusReadArgs subscriptionName
             */

            /**
             * Constructs a new AzureServiceBusReadArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusReadArgs.
             * @implements IAzureServiceBusReadArgs
             * @constructor
             * @param {protos.args.IAzureServiceBusReadArgs=} [properties] Properties to set
             */
            function AzureServiceBusReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusReadArgs queue.
             * @member {string} queue
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.queue = "";

            /**
             * AzureServiceBusReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.topic = "";

            /**
             * AzureServiceBusReadArgs subscriptionName.
             * @member {string} subscriptionName
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.subscriptionName = "";

            /**
             * Creates a new AzureServiceBusReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs instance
             */
            AzureServiceBusReadArgs.create = function create(properties) {
                return new AzureServiceBusReadArgs(properties);
            };

            /**
             * Encodes the specified AzureServiceBusReadArgs message. Does not implicitly {@link protos.args.AzureServiceBusReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs} message AzureServiceBusReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queue);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                if (message.subscriptionName != null && Object.hasOwnProperty.call(message, "subscriptionName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subscriptionName);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusReadArgs message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs} message AzureServiceBusReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queue = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    case 3:
                        message.subscriptionName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusReadArgs message.
             * @function verify
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    if (!$util.isString(message.subscriptionName))
                        return "subscriptionName: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             */
            AzureServiceBusReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusReadArgs)
                    return object;
                var message = new $root.protos.args.AzureServiceBusReadArgs();
                if (object.queue != null)
                    message.queue = String(object.queue);
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.subscriptionName != null)
                    message.subscriptionName = String(object.subscriptionName);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.AzureServiceBusReadArgs} message AzureServiceBusReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queue = "";
                    object.topic = "";
                    object.subscriptionName = "";
                }
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    object.subscriptionName = message.subscriptionName;
                return object;
            };

            /**
             * Converts this AzureServiceBusReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusReadArgs;
        })();

        args.AzureServiceBusWriteArgs = (function() {

            /**
             * Properties of an AzureServiceBusWriteArgs.
             * @memberof protos.args
             * @interface IAzureServiceBusWriteArgs
             * @property {string|null} [queue] AzureServiceBusWriteArgs queue
             * @property {string|null} [topic] AzureServiceBusWriteArgs topic
             */

            /**
             * Constructs a new AzureServiceBusWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusWriteArgs.
             * @implements IAzureServiceBusWriteArgs
             * @constructor
             * @param {protos.args.IAzureServiceBusWriteArgs=} [properties] Properties to set
             */
            function AzureServiceBusWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusWriteArgs queue.
             * @member {string} queue
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             */
            AzureServiceBusWriteArgs.prototype.queue = "";

            /**
             * AzureServiceBusWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             */
            AzureServiceBusWriteArgs.prototype.topic = "";

            /**
             * Creates a new AzureServiceBusWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs instance
             */
            AzureServiceBusWriteArgs.create = function create(properties) {
                return new AzureServiceBusWriteArgs(properties);
            };

            /**
             * Encodes the specified AzureServiceBusWriteArgs message. Does not implicitly {@link protos.args.AzureServiceBusWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs} message AzureServiceBusWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queue);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusWriteArgs message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs} message AzureServiceBusWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queue = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusWriteArgs message.
             * @function verify
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             */
            AzureServiceBusWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusWriteArgs)
                    return object;
                var message = new $root.protos.args.AzureServiceBusWriteArgs();
                if (object.queue != null)
                    message.queue = String(object.queue);
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.AzureServiceBusWriteArgs} message AzureServiceBusWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queue = "";
                    object.topic = "";
                }
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this AzureServiceBusWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusWriteArgs;
        })();

        args.AzureEventHubConn = (function() {

            /**
             * Properties of an AzureEventHubConn.
             * @memberof protos.args
             * @interface IAzureEventHubConn
             * @property {string|null} [connectionString] AzureEventHubConn connectionString
             */

            /**
             * Constructs a new AzureEventHubConn.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubConn.
             * @implements IAzureEventHubConn
             * @constructor
             * @param {protos.args.IAzureEventHubConn=} [properties] Properties to set
             */
            function AzureEventHubConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHubConn connectionString.
             * @member {string} connectionString
             * @memberof protos.args.AzureEventHubConn
             * @instance
             */
            AzureEventHubConn.prototype.connectionString = "";

            /**
             * Creates a new AzureEventHubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn instance
             */
            AzureEventHubConn.create = function create(properties) {
                return new AzureEventHubConn(properties);
            };

            /**
             * Encodes the specified AzureEventHubConn message. Does not implicitly {@link protos.args.AzureEventHubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn} message AzureEventHubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionString != null && Object.hasOwnProperty.call(message, "connectionString"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionString);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubConn message, length delimited. Does not implicitly {@link protos.args.AzureEventHubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn} message AzureEventHubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubConn message.
             * @function verify
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    if (!$util.isString(message.connectionString))
                        return "connectionString: string expected";
                return null;
            };

            /**
             * Creates an AzureEventHubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             */
            AzureEventHubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubConn)
                    return object;
                var message = new $root.protos.args.AzureEventHubConn();
                if (object.connectionString != null)
                    message.connectionString = String(object.connectionString);
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.AzureEventHubConn} message AzureEventHubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.connectionString = "";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    object.connectionString = message.connectionString;
                return object;
            };

            /**
             * Converts this AzureEventHubConn to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubConn;
        })();

        args.AzureEventHubReadArgs = (function() {

            /**
             * Properties of an AzureEventHubReadArgs.
             * @memberof protos.args
             * @interface IAzureEventHubReadArgs
             */

            /**
             * Constructs a new AzureEventHubReadArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubReadArgs.
             * @implements IAzureEventHubReadArgs
             * @constructor
             * @param {protos.args.IAzureEventHubReadArgs=} [properties] Properties to set
             */
            function AzureEventHubReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AzureEventHubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs instance
             */
            AzureEventHubReadArgs.create = function create(properties) {
                return new AzureEventHubReadArgs(properties);
            };

            /**
             * Encodes the specified AzureEventHubReadArgs message. Does not implicitly {@link protos.args.AzureEventHubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs} message AzureEventHubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubReadArgs message, length delimited. Does not implicitly {@link protos.args.AzureEventHubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs} message AzureEventHubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubReadArgs message.
             * @function verify
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AzureEventHubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             */
            AzureEventHubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubReadArgs)
                    return object;
                return new $root.protos.args.AzureEventHubReadArgs();
            };

            /**
             * Creates a plain object from an AzureEventHubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.AzureEventHubReadArgs} message AzureEventHubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubReadArgs.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AzureEventHubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubReadArgs;
        })();

        args.AzureEventHubWriteArgs = (function() {

            /**
             * Properties of an AzureEventHubWriteArgs.
             * @memberof protos.args
             * @interface IAzureEventHubWriteArgs
             * @property {string|null} [messageId] AzureEventHubWriteArgs messageId
             * @property {string|null} [partitionKey] AzureEventHubWriteArgs partitionKey
             */

            /**
             * Constructs a new AzureEventHubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubWriteArgs.
             * @implements IAzureEventHubWriteArgs
             * @constructor
             * @param {protos.args.IAzureEventHubWriteArgs=} [properties] Properties to set
             */
            function AzureEventHubWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHubWriteArgs messageId.
             * @member {string} messageId
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             */
            AzureEventHubWriteArgs.prototype.messageId = "";

            /**
             * AzureEventHubWriteArgs partitionKey.
             * @member {string} partitionKey
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             */
            AzureEventHubWriteArgs.prototype.partitionKey = "";

            /**
             * Creates a new AzureEventHubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs instance
             */
            AzureEventHubWriteArgs.create = function create(properties) {
                return new AzureEventHubWriteArgs(properties);
            };

            /**
             * Encodes the specified AzureEventHubWriteArgs message. Does not implicitly {@link protos.args.AzureEventHubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs} message AzureEventHubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.partitionKey);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubWriteArgs message, length delimited. Does not implicitly {@link protos.args.AzureEventHubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs} message AzureEventHubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageId = reader.string();
                        break;
                    case 2:
                        message.partitionKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubWriteArgs message.
             * @function verify
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                return null;
            };

            /**
             * Creates an AzureEventHubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             */
            AzureEventHubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubWriteArgs)
                    return object;
                var message = new $root.protos.args.AzureEventHubWriteArgs();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.AzureEventHubWriteArgs} message AzureEventHubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.messageId = "";
                    object.partitionKey = "";
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                return object;
            };

            /**
             * Converts this AzureEventHubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubWriteArgs;
        })();

        return args;
    })();

    protos.CreateReadRequest = (function() {

        /**
         * Properties of a CreateReadRequest.
         * @memberof protos
         * @interface ICreateReadRequest
         * @property {protos.common.IAuth|null} [auth] CreateReadRequest auth
         * @property {protos.opts.IReadOptions|null} [read] CreateReadRequest read
         */

        /**
         * Constructs a new CreateReadRequest.
         * @memberof protos
         * @classdesc Represents a CreateReadRequest.
         * @implements ICreateReadRequest
         * @constructor
         * @param {protos.ICreateReadRequest=} [properties] Properties to set
         */
        function CreateReadRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateReadRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateReadRequest
         * @instance
         */
        CreateReadRequest.prototype.auth = null;

        /**
         * CreateReadRequest read.
         * @member {protos.opts.IReadOptions|null|undefined} read
         * @memberof protos.CreateReadRequest
         * @instance
         */
        CreateReadRequest.prototype.read = null;

        /**
         * Creates a new CreateReadRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateReadRequest
         * @static
         * @param {protos.ICreateReadRequest=} [properties] Properties to set
         * @returns {protos.CreateReadRequest} CreateReadRequest instance
         */
        CreateReadRequest.create = function create(properties) {
            return new CreateReadRequest(properties);
        };

        /**
         * Encodes the specified CreateReadRequest message. Does not implicitly {@link protos.CreateReadRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateReadRequest
         * @static
         * @param {protos.ICreateReadRequest} message CreateReadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateReadRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.read != null && Object.hasOwnProperty.call(message, "read"))
                $root.protos.opts.ReadOptions.encode(message.read, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateReadRequest message, length delimited. Does not implicitly {@link protos.CreateReadRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateReadRequest
         * @static
         * @param {protos.ICreateReadRequest} message CreateReadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateReadRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateReadRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateReadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateReadRequest} CreateReadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateReadRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateReadRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.read = $root.protos.opts.ReadOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateReadRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateReadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateReadRequest} CreateReadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateReadRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateReadRequest message.
         * @function verify
         * @memberof protos.CreateReadRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateReadRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.read != null && message.hasOwnProperty("read")) {
                var error = $root.protos.opts.ReadOptions.verify(message.read);
                if (error)
                    return "read." + error;
            }
            return null;
        };

        /**
         * Creates a CreateReadRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateReadRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateReadRequest} CreateReadRequest
         */
        CreateReadRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateReadRequest)
                return object;
            var message = new $root.protos.CreateReadRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateReadRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.read != null) {
                if (typeof object.read !== "object")
                    throw TypeError(".protos.CreateReadRequest.read: object expected");
                message.read = $root.protos.opts.ReadOptions.fromObject(object.read);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateReadRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateReadRequest
         * @static
         * @param {protos.CreateReadRequest} message CreateReadRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateReadRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.read = null;
                object.auth = null;
            }
            if (message.read != null && message.hasOwnProperty("read"))
                object.read = $root.protos.opts.ReadOptions.toObject(message.read, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateReadRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateReadRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateReadRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateReadRequest;
    })();

    protos.CreateReadResponse = (function() {

        /**
         * Properties of a CreateReadResponse.
         * @memberof protos
         * @interface ICreateReadResponse
         * @property {protos.common.IStatus|null} [status] CreateReadResponse status
         * @property {string|null} [readId] CreateReadResponse readId
         */

        /**
         * Constructs a new CreateReadResponse.
         * @memberof protos
         * @classdesc Represents a CreateReadResponse.
         * @implements ICreateReadResponse
         * @constructor
         * @param {protos.ICreateReadResponse=} [properties] Properties to set
         */
        function CreateReadResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateReadResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.CreateReadResponse
         * @instance
         */
        CreateReadResponse.prototype.status = null;

        /**
         * CreateReadResponse readId.
         * @member {string} readId
         * @memberof protos.CreateReadResponse
         * @instance
         */
        CreateReadResponse.prototype.readId = "";

        /**
         * Creates a new CreateReadResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateReadResponse
         * @static
         * @param {protos.ICreateReadResponse=} [properties] Properties to set
         * @returns {protos.CreateReadResponse} CreateReadResponse instance
         */
        CreateReadResponse.create = function create(properties) {
            return new CreateReadResponse(properties);
        };

        /**
         * Encodes the specified CreateReadResponse message. Does not implicitly {@link protos.CreateReadResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateReadResponse
         * @static
         * @param {protos.ICreateReadResponse} message CreateReadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateReadResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.readId != null && Object.hasOwnProperty.call(message, "readId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.readId);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateReadResponse message, length delimited. Does not implicitly {@link protos.CreateReadResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateReadResponse
         * @static
         * @param {protos.ICreateReadResponse} message CreateReadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateReadResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateReadResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateReadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateReadResponse} CreateReadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateReadResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateReadResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.readId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateReadResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateReadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateReadResponse} CreateReadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateReadResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateReadResponse message.
         * @function verify
         * @memberof protos.CreateReadResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateReadResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.readId != null && message.hasOwnProperty("readId"))
                if (!$util.isString(message.readId))
                    return "readId: string expected";
            return null;
        };

        /**
         * Creates a CreateReadResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateReadResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateReadResponse} CreateReadResponse
         */
        CreateReadResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateReadResponse)
                return object;
            var message = new $root.protos.CreateReadResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.CreateReadResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.readId != null)
                message.readId = String(object.readId);
            return message;
        };

        /**
         * Creates a plain object from a CreateReadResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateReadResponse
         * @static
         * @param {protos.CreateReadResponse} message CreateReadResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateReadResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.readId = "";
                object.status = null;
            }
            if (message.readId != null && message.hasOwnProperty("readId"))
                object.readId = message.readId;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this CreateReadResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateReadResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateReadResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateReadResponse;
    })();

    protos.StopReadRequest = (function() {

        /**
         * Properties of a StopReadRequest.
         * @memberof protos
         * @interface IStopReadRequest
         * @property {protos.common.IAuth|null} [auth] StopReadRequest auth
         * @property {string|null} [readId] StopReadRequest readId
         */

        /**
         * Constructs a new StopReadRequest.
         * @memberof protos
         * @classdesc Represents a StopReadRequest.
         * @implements IStopReadRequest
         * @constructor
         * @param {protos.IStopReadRequest=} [properties] Properties to set
         */
        function StopReadRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopReadRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.StopReadRequest
         * @instance
         */
        StopReadRequest.prototype.auth = null;

        /**
         * StopReadRequest readId.
         * @member {string} readId
         * @memberof protos.StopReadRequest
         * @instance
         */
        StopReadRequest.prototype.readId = "";

        /**
         * Creates a new StopReadRequest instance using the specified properties.
         * @function create
         * @memberof protos.StopReadRequest
         * @static
         * @param {protos.IStopReadRequest=} [properties] Properties to set
         * @returns {protos.StopReadRequest} StopReadRequest instance
         */
        StopReadRequest.create = function create(properties) {
            return new StopReadRequest(properties);
        };

        /**
         * Encodes the specified StopReadRequest message. Does not implicitly {@link protos.StopReadRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.StopReadRequest
         * @static
         * @param {protos.IStopReadRequest} message StopReadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReadRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.readId != null && Object.hasOwnProperty.call(message, "readId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.readId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopReadRequest message, length delimited. Does not implicitly {@link protos.StopReadRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopReadRequest
         * @static
         * @param {protos.IStopReadRequest} message StopReadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReadRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopReadRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopReadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopReadRequest} StopReadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReadRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopReadRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.readId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopReadRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopReadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopReadRequest} StopReadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReadRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopReadRequest message.
         * @function verify
         * @memberof protos.StopReadRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopReadRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.readId != null && message.hasOwnProperty("readId"))
                if (!$util.isString(message.readId))
                    return "readId: string expected";
            return null;
        };

        /**
         * Creates a StopReadRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopReadRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopReadRequest} StopReadRequest
         */
        StopReadRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopReadRequest)
                return object;
            var message = new $root.protos.StopReadRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.StopReadRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.readId != null)
                message.readId = String(object.readId);
            return message;
        };

        /**
         * Creates a plain object from a StopReadRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopReadRequest
         * @static
         * @param {protos.StopReadRequest} message StopReadRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopReadRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.readId = "";
                object.auth = null;
            }
            if (message.readId != null && message.hasOwnProperty("readId"))
                object.readId = message.readId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this StopReadRequest to JSON.
         * @function toJSON
         * @memberof protos.StopReadRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopReadRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopReadRequest;
    })();

    protos.StopReadResponse = (function() {

        /**
         * Properties of a StopReadResponse.
         * @memberof protos
         * @interface IStopReadResponse
         * @property {protos.common.IStatus|null} [status] StopReadResponse status
         */

        /**
         * Constructs a new StopReadResponse.
         * @memberof protos
         * @classdesc Represents a StopReadResponse.
         * @implements IStopReadResponse
         * @constructor
         * @param {protos.IStopReadResponse=} [properties] Properties to set
         */
        function StopReadResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopReadResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.StopReadResponse
         * @instance
         */
        StopReadResponse.prototype.status = null;

        /**
         * Creates a new StopReadResponse instance using the specified properties.
         * @function create
         * @memberof protos.StopReadResponse
         * @static
         * @param {protos.IStopReadResponse=} [properties] Properties to set
         * @returns {protos.StopReadResponse} StopReadResponse instance
         */
        StopReadResponse.create = function create(properties) {
            return new StopReadResponse(properties);
        };

        /**
         * Encodes the specified StopReadResponse message. Does not implicitly {@link protos.StopReadResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.StopReadResponse
         * @static
         * @param {protos.IStopReadResponse} message StopReadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReadResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopReadResponse message, length delimited. Does not implicitly {@link protos.StopReadResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopReadResponse
         * @static
         * @param {protos.IStopReadResponse} message StopReadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReadResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopReadResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopReadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopReadResponse} StopReadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReadResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopReadResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopReadResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopReadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopReadResponse} StopReadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReadResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopReadResponse message.
         * @function verify
         * @memberof protos.StopReadResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopReadResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a StopReadResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopReadResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopReadResponse} StopReadResponse
         */
        StopReadResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopReadResponse)
                return object;
            var message = new $root.protos.StopReadResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.StopReadResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a StopReadResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopReadResponse
         * @static
         * @param {protos.StopReadResponse} message StopReadResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopReadResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this StopReadResponse to JSON.
         * @function toJSON
         * @memberof protos.StopReadResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopReadResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopReadResponse;
    })();

    protos.ResumeReadRequest = (function() {

        /**
         * Properties of a ResumeReadRequest.
         * @memberof protos
         * @interface IResumeReadRequest
         * @property {protos.common.IAuth|null} [auth] ResumeReadRequest auth
         * @property {string|null} [readId] ResumeReadRequest readId
         */

        /**
         * Constructs a new ResumeReadRequest.
         * @memberof protos
         * @classdesc Represents a ResumeReadRequest.
         * @implements IResumeReadRequest
         * @constructor
         * @param {protos.IResumeReadRequest=} [properties] Properties to set
         */
        function ResumeReadRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeReadRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.ResumeReadRequest
         * @instance
         */
        ResumeReadRequest.prototype.auth = null;

        /**
         * ResumeReadRequest readId.
         * @member {string} readId
         * @memberof protos.ResumeReadRequest
         * @instance
         */
        ResumeReadRequest.prototype.readId = "";

        /**
         * Creates a new ResumeReadRequest instance using the specified properties.
         * @function create
         * @memberof protos.ResumeReadRequest
         * @static
         * @param {protos.IResumeReadRequest=} [properties] Properties to set
         * @returns {protos.ResumeReadRequest} ResumeReadRequest instance
         */
        ResumeReadRequest.create = function create(properties) {
            return new ResumeReadRequest(properties);
        };

        /**
         * Encodes the specified ResumeReadRequest message. Does not implicitly {@link protos.ResumeReadRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeReadRequest
         * @static
         * @param {protos.IResumeReadRequest} message ResumeReadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeReadRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.readId != null && Object.hasOwnProperty.call(message, "readId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.readId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeReadRequest message, length delimited. Does not implicitly {@link protos.ResumeReadRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeReadRequest
         * @static
         * @param {protos.IResumeReadRequest} message ResumeReadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeReadRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeReadRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeReadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeReadRequest} ResumeReadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeReadRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeReadRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.readId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeReadRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeReadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeReadRequest} ResumeReadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeReadRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeReadRequest message.
         * @function verify
         * @memberof protos.ResumeReadRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeReadRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.readId != null && message.hasOwnProperty("readId"))
                if (!$util.isString(message.readId))
                    return "readId: string expected";
            return null;
        };

        /**
         * Creates a ResumeReadRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeReadRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeReadRequest} ResumeReadRequest
         */
        ResumeReadRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeReadRequest)
                return object;
            var message = new $root.protos.ResumeReadRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.ResumeReadRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.readId != null)
                message.readId = String(object.readId);
            return message;
        };

        /**
         * Creates a plain object from a ResumeReadRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeReadRequest
         * @static
         * @param {protos.ResumeReadRequest} message ResumeReadRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeReadRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.readId = "";
                object.auth = null;
            }
            if (message.readId != null && message.hasOwnProperty("readId"))
                object.readId = message.readId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ResumeReadRequest to JSON.
         * @function toJSON
         * @memberof protos.ResumeReadRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeReadRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeReadRequest;
    })();

    protos.ResumeReadResponse = (function() {

        /**
         * Properties of a ResumeReadResponse.
         * @memberof protos
         * @interface IResumeReadResponse
         * @property {protos.common.IStatus|null} [status] ResumeReadResponse status
         */

        /**
         * Constructs a new ResumeReadResponse.
         * @memberof protos
         * @classdesc Represents a ResumeReadResponse.
         * @implements IResumeReadResponse
         * @constructor
         * @param {protos.IResumeReadResponse=} [properties] Properties to set
         */
        function ResumeReadResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeReadResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.ResumeReadResponse
         * @instance
         */
        ResumeReadResponse.prototype.status = null;

        /**
         * Creates a new ResumeReadResponse instance using the specified properties.
         * @function create
         * @memberof protos.ResumeReadResponse
         * @static
         * @param {protos.IResumeReadResponse=} [properties] Properties to set
         * @returns {protos.ResumeReadResponse} ResumeReadResponse instance
         */
        ResumeReadResponse.create = function create(properties) {
            return new ResumeReadResponse(properties);
        };

        /**
         * Encodes the specified ResumeReadResponse message. Does not implicitly {@link protos.ResumeReadResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeReadResponse
         * @static
         * @param {protos.IResumeReadResponse} message ResumeReadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeReadResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeReadResponse message, length delimited. Does not implicitly {@link protos.ResumeReadResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeReadResponse
         * @static
         * @param {protos.IResumeReadResponse} message ResumeReadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeReadResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeReadResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeReadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeReadResponse} ResumeReadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeReadResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeReadResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeReadResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeReadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeReadResponse} ResumeReadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeReadResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeReadResponse message.
         * @function verify
         * @memberof protos.ResumeReadResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeReadResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a ResumeReadResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeReadResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeReadResponse} ResumeReadResponse
         */
        ResumeReadResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeReadResponse)
                return object;
            var message = new $root.protos.ResumeReadResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.ResumeReadResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResumeReadResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeReadResponse
         * @static
         * @param {protos.ResumeReadResponse} message ResumeReadResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeReadResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ResumeReadResponse to JSON.
         * @function toJSON
         * @memberof protos.ResumeReadResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeReadResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeReadResponse;
    })();

    protos.DeleteReadRequest = (function() {

        /**
         * Properties of a DeleteReadRequest.
         * @memberof protos
         * @interface IDeleteReadRequest
         * @property {protos.common.IAuth|null} [auth] DeleteReadRequest auth
         * @property {string|null} [readId] DeleteReadRequest readId
         */

        /**
         * Constructs a new DeleteReadRequest.
         * @memberof protos
         * @classdesc Represents a DeleteReadRequest.
         * @implements IDeleteReadRequest
         * @constructor
         * @param {protos.IDeleteReadRequest=} [properties] Properties to set
         */
        function DeleteReadRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteReadRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteReadRequest
         * @instance
         */
        DeleteReadRequest.prototype.auth = null;

        /**
         * DeleteReadRequest readId.
         * @member {string} readId
         * @memberof protos.DeleteReadRequest
         * @instance
         */
        DeleteReadRequest.prototype.readId = "";

        /**
         * Creates a new DeleteReadRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteReadRequest
         * @static
         * @param {protos.IDeleteReadRequest=} [properties] Properties to set
         * @returns {protos.DeleteReadRequest} DeleteReadRequest instance
         */
        DeleteReadRequest.create = function create(properties) {
            return new DeleteReadRequest(properties);
        };

        /**
         * Encodes the specified DeleteReadRequest message. Does not implicitly {@link protos.DeleteReadRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteReadRequest
         * @static
         * @param {protos.IDeleteReadRequest} message DeleteReadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteReadRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.readId != null && Object.hasOwnProperty.call(message, "readId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.readId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteReadRequest message, length delimited. Does not implicitly {@link protos.DeleteReadRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteReadRequest
         * @static
         * @param {protos.IDeleteReadRequest} message DeleteReadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteReadRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteReadRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteReadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteReadRequest} DeleteReadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteReadRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteReadRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.readId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteReadRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteReadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteReadRequest} DeleteReadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteReadRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteReadRequest message.
         * @function verify
         * @memberof protos.DeleteReadRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteReadRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.readId != null && message.hasOwnProperty("readId"))
                if (!$util.isString(message.readId))
                    return "readId: string expected";
            return null;
        };

        /**
         * Creates a DeleteReadRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteReadRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteReadRequest} DeleteReadRequest
         */
        DeleteReadRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteReadRequest)
                return object;
            var message = new $root.protos.DeleteReadRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteReadRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.readId != null)
                message.readId = String(object.readId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteReadRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteReadRequest
         * @static
         * @param {protos.DeleteReadRequest} message DeleteReadRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteReadRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.readId = "";
                object.auth = null;
            }
            if (message.readId != null && message.hasOwnProperty("readId"))
                object.readId = message.readId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteReadRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteReadRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteReadRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteReadRequest;
    })();

    protos.DeleteReadResponse = (function() {

        /**
         * Properties of a DeleteReadResponse.
         * @memberof protos
         * @interface IDeleteReadResponse
         * @property {protos.common.IStatus|null} [status] DeleteReadResponse status
         */

        /**
         * Constructs a new DeleteReadResponse.
         * @memberof protos
         * @classdesc Represents a DeleteReadResponse.
         * @implements IDeleteReadResponse
         * @constructor
         * @param {protos.IDeleteReadResponse=} [properties] Properties to set
         */
        function DeleteReadResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteReadResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteReadResponse
         * @instance
         */
        DeleteReadResponse.prototype.status = null;

        /**
         * Creates a new DeleteReadResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteReadResponse
         * @static
         * @param {protos.IDeleteReadResponse=} [properties] Properties to set
         * @returns {protos.DeleteReadResponse} DeleteReadResponse instance
         */
        DeleteReadResponse.create = function create(properties) {
            return new DeleteReadResponse(properties);
        };

        /**
         * Encodes the specified DeleteReadResponse message. Does not implicitly {@link protos.DeleteReadResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteReadResponse
         * @static
         * @param {protos.IDeleteReadResponse} message DeleteReadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteReadResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteReadResponse message, length delimited. Does not implicitly {@link protos.DeleteReadResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteReadResponse
         * @static
         * @param {protos.IDeleteReadResponse} message DeleteReadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteReadResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteReadResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteReadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteReadResponse} DeleteReadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteReadResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteReadResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteReadResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteReadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteReadResponse} DeleteReadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteReadResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteReadResponse message.
         * @function verify
         * @memberof protos.DeleteReadResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteReadResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteReadResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteReadResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteReadResponse} DeleteReadResponse
         */
        DeleteReadResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteReadResponse)
                return object;
            var message = new $root.protos.DeleteReadResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteReadResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteReadResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteReadResponse
         * @static
         * @param {protos.DeleteReadResponse} message DeleteReadResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteReadResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteReadResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteReadResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteReadResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteReadResponse;
    })();

    protos.StartReadRequest = (function() {

        /**
         * Properties of a StartReadRequest.
         * @memberof protos
         * @interface IStartReadRequest
         * @property {protos.common.IAuth|null} [auth] StartReadRequest auth
         * @property {string|null} [readId] StartReadRequest readId
         */

        /**
         * Constructs a new StartReadRequest.
         * @memberof protos
         * @classdesc Represents a StartReadRequest.
         * @implements IStartReadRequest
         * @constructor
         * @param {protos.IStartReadRequest=} [properties] Properties to set
         */
        function StartReadRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartReadRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.StartReadRequest
         * @instance
         */
        StartReadRequest.prototype.auth = null;

        /**
         * StartReadRequest readId.
         * @member {string} readId
         * @memberof protos.StartReadRequest
         * @instance
         */
        StartReadRequest.prototype.readId = "";

        /**
         * Creates a new StartReadRequest instance using the specified properties.
         * @function create
         * @memberof protos.StartReadRequest
         * @static
         * @param {protos.IStartReadRequest=} [properties] Properties to set
         * @returns {protos.StartReadRequest} StartReadRequest instance
         */
        StartReadRequest.create = function create(properties) {
            return new StartReadRequest(properties);
        };

        /**
         * Encodes the specified StartReadRequest message. Does not implicitly {@link protos.StartReadRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.StartReadRequest
         * @static
         * @param {protos.IStartReadRequest} message StartReadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReadRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.readId != null && Object.hasOwnProperty.call(message, "readId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.readId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StartReadRequest message, length delimited. Does not implicitly {@link protos.StartReadRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StartReadRequest
         * @static
         * @param {protos.IStartReadRequest} message StartReadRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReadRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartReadRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StartReadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StartReadRequest} StartReadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReadRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StartReadRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.readId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartReadRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StartReadRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StartReadRequest} StartReadRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReadRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartReadRequest message.
         * @function verify
         * @memberof protos.StartReadRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartReadRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.readId != null && message.hasOwnProperty("readId"))
                if (!$util.isString(message.readId))
                    return "readId: string expected";
            return null;
        };

        /**
         * Creates a StartReadRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StartReadRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StartReadRequest} StartReadRequest
         */
        StartReadRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StartReadRequest)
                return object;
            var message = new $root.protos.StartReadRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.StartReadRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.readId != null)
                message.readId = String(object.readId);
            return message;
        };

        /**
         * Creates a plain object from a StartReadRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StartReadRequest
         * @static
         * @param {protos.StartReadRequest} message StartReadRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartReadRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.readId = "";
                object.auth = null;
            }
            if (message.readId != null && message.hasOwnProperty("readId"))
                object.readId = message.readId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this StartReadRequest to JSON.
         * @function toJSON
         * @memberof protos.StartReadRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartReadRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartReadRequest;
    })();

    protos.StartReadResponse = (function() {

        /**
         * Properties of a StartReadResponse.
         * @memberof protos
         * @interface IStartReadResponse
         * @property {Array.<protos.records.IReadRecord>|null} [records] StartReadResponse records
         * @property {protos.common.IStatus|null} [status] StartReadResponse status
         */

        /**
         * Constructs a new StartReadResponse.
         * @memberof protos
         * @classdesc Represents a StartReadResponse.
         * @implements IStartReadResponse
         * @constructor
         * @param {protos.IStartReadResponse=} [properties] Properties to set
         */
        function StartReadResponse(properties) {
            this.records = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartReadResponse records.
         * @member {Array.<protos.records.IReadRecord>} records
         * @memberof protos.StartReadResponse
         * @instance
         */
        StartReadResponse.prototype.records = $util.emptyArray;

        /**
         * StartReadResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.StartReadResponse
         * @instance
         */
        StartReadResponse.prototype.status = null;

        /**
         * Creates a new StartReadResponse instance using the specified properties.
         * @function create
         * @memberof protos.StartReadResponse
         * @static
         * @param {protos.IStartReadResponse=} [properties] Properties to set
         * @returns {protos.StartReadResponse} StartReadResponse instance
         */
        StartReadResponse.create = function create(properties) {
            return new StartReadResponse(properties);
        };

        /**
         * Encodes the specified StartReadResponse message. Does not implicitly {@link protos.StartReadResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.StartReadResponse
         * @static
         * @param {protos.IStartReadResponse} message StartReadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReadResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.records != null && message.records.length)
                for (var i = 0; i < message.records.length; ++i)
                    $root.protos.records.ReadRecord.encode(message.records[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StartReadResponse message, length delimited. Does not implicitly {@link protos.StartReadResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StartReadResponse
         * @static
         * @param {protos.IStartReadResponse} message StartReadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReadResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartReadResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StartReadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StartReadResponse} StartReadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReadResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StartReadResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.records && message.records.length))
                        message.records = [];
                    message.records.push($root.protos.records.ReadRecord.decode(reader, reader.uint32()));
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartReadResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StartReadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StartReadResponse} StartReadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReadResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartReadResponse message.
         * @function verify
         * @memberof protos.StartReadResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartReadResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.records != null && message.hasOwnProperty("records")) {
                if (!Array.isArray(message.records))
                    return "records: array expected";
                for (var i = 0; i < message.records.length; ++i) {
                    var error = $root.protos.records.ReadRecord.verify(message.records[i]);
                    if (error)
                        return "records." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a StartReadResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StartReadResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StartReadResponse} StartReadResponse
         */
        StartReadResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StartReadResponse)
                return object;
            var message = new $root.protos.StartReadResponse();
            if (object.records) {
                if (!Array.isArray(object.records))
                    throw TypeError(".protos.StartReadResponse.records: array expected");
                message.records = [];
                for (var i = 0; i < object.records.length; ++i) {
                    if (typeof object.records[i] !== "object")
                        throw TypeError(".protos.StartReadResponse.records: object expected");
                    message.records[i] = $root.protos.records.ReadRecord.fromObject(object.records[i]);
                }
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.StartReadResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a StartReadResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StartReadResponse
         * @static
         * @param {protos.StartReadResponse} message StartReadResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartReadResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.records = [];
            if (options.defaults)
                object.status = null;
            if (message.records && message.records.length) {
                object.records = [];
                for (var j = 0; j < message.records.length; ++j)
                    object.records[j] = $root.protos.records.ReadRecord.toObject(message.records[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this StartReadResponse to JSON.
         * @function toJSON
         * @memberof protos.StartReadResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartReadResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartReadResponse;
    })();

    protos.GetAllReadsRequest = (function() {

        /**
         * Properties of a GetAllReadsRequest.
         * @memberof protos
         * @interface IGetAllReadsRequest
         * @property {protos.common.IAuth|null} [auth] GetAllReadsRequest auth
         */

        /**
         * Constructs a new GetAllReadsRequest.
         * @memberof protos
         * @classdesc Represents a GetAllReadsRequest.
         * @implements IGetAllReadsRequest
         * @constructor
         * @param {protos.IGetAllReadsRequest=} [properties] Properties to set
         */
        function GetAllReadsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllReadsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllReadsRequest
         * @instance
         */
        GetAllReadsRequest.prototype.auth = null;

        /**
         * Creates a new GetAllReadsRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllReadsRequest
         * @static
         * @param {protos.IGetAllReadsRequest=} [properties] Properties to set
         * @returns {protos.GetAllReadsRequest} GetAllReadsRequest instance
         */
        GetAllReadsRequest.create = function create(properties) {
            return new GetAllReadsRequest(properties);
        };

        /**
         * Encodes the specified GetAllReadsRequest message. Does not implicitly {@link protos.GetAllReadsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllReadsRequest
         * @static
         * @param {protos.IGetAllReadsRequest} message GetAllReadsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllReadsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllReadsRequest message, length delimited. Does not implicitly {@link protos.GetAllReadsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllReadsRequest
         * @static
         * @param {protos.IGetAllReadsRequest} message GetAllReadsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllReadsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllReadsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllReadsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllReadsRequest} GetAllReadsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllReadsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllReadsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllReadsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllReadsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllReadsRequest} GetAllReadsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllReadsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllReadsRequest message.
         * @function verify
         * @memberof protos.GetAllReadsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllReadsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllReadsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllReadsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllReadsRequest} GetAllReadsRequest
         */
        GetAllReadsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllReadsRequest)
                return object;
            var message = new $root.protos.GetAllReadsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllReadsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllReadsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllReadsRequest
         * @static
         * @param {protos.GetAllReadsRequest} message GetAllReadsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllReadsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllReadsRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllReadsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllReadsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllReadsRequest;
    })();

    protos.GetAllReadsResponse = (function() {

        /**
         * Properties of a GetAllReadsResponse.
         * @memberof protos
         * @interface IGetAllReadsResponse
         * @property {Array.<protos.opts.IReadOptions>|null} [read] GetAllReadsResponse read
         * @property {protos.common.IStatus|null} [status] GetAllReadsResponse status
         */

        /**
         * Constructs a new GetAllReadsResponse.
         * @memberof protos
         * @classdesc Represents a GetAllReadsResponse.
         * @implements IGetAllReadsResponse
         * @constructor
         * @param {protos.IGetAllReadsResponse=} [properties] Properties to set
         */
        function GetAllReadsResponse(properties) {
            this.read = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllReadsResponse read.
         * @member {Array.<protos.opts.IReadOptions>} read
         * @memberof protos.GetAllReadsResponse
         * @instance
         */
        GetAllReadsResponse.prototype.read = $util.emptyArray;

        /**
         * GetAllReadsResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetAllReadsResponse
         * @instance
         */
        GetAllReadsResponse.prototype.status = null;

        /**
         * Creates a new GetAllReadsResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllReadsResponse
         * @static
         * @param {protos.IGetAllReadsResponse=} [properties] Properties to set
         * @returns {protos.GetAllReadsResponse} GetAllReadsResponse instance
         */
        GetAllReadsResponse.create = function create(properties) {
            return new GetAllReadsResponse(properties);
        };

        /**
         * Encodes the specified GetAllReadsResponse message. Does not implicitly {@link protos.GetAllReadsResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllReadsResponse
         * @static
         * @param {protos.IGetAllReadsResponse} message GetAllReadsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllReadsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.read != null && message.read.length)
                for (var i = 0; i < message.read.length; ++i)
                    $root.protos.opts.ReadOptions.encode(message.read[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllReadsResponse message, length delimited. Does not implicitly {@link protos.GetAllReadsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllReadsResponse
         * @static
         * @param {protos.IGetAllReadsResponse} message GetAllReadsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllReadsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllReadsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllReadsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllReadsResponse} GetAllReadsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllReadsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllReadsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.read && message.read.length))
                        message.read = [];
                    message.read.push($root.protos.opts.ReadOptions.decode(reader, reader.uint32()));
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllReadsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllReadsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllReadsResponse} GetAllReadsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllReadsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllReadsResponse message.
         * @function verify
         * @memberof protos.GetAllReadsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllReadsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.read != null && message.hasOwnProperty("read")) {
                if (!Array.isArray(message.read))
                    return "read: array expected";
                for (var i = 0; i < message.read.length; ++i) {
                    var error = $root.protos.opts.ReadOptions.verify(message.read[i]);
                    if (error)
                        return "read." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllReadsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllReadsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllReadsResponse} GetAllReadsResponse
         */
        GetAllReadsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllReadsResponse)
                return object;
            var message = new $root.protos.GetAllReadsResponse();
            if (object.read) {
                if (!Array.isArray(object.read))
                    throw TypeError(".protos.GetAllReadsResponse.read: array expected");
                message.read = [];
                for (var i = 0; i < object.read.length; ++i) {
                    if (typeof object.read[i] !== "object")
                        throw TypeError(".protos.GetAllReadsResponse.read: object expected");
                    message.read[i] = $root.protos.opts.ReadOptions.fromObject(object.read[i]);
                }
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetAllReadsResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllReadsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllReadsResponse
         * @static
         * @param {protos.GetAllReadsResponse} message GetAllReadsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllReadsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.read = [];
            if (options.defaults)
                object.status = null;
            if (message.read && message.read.length) {
                object.read = [];
                for (var j = 0; j < message.read.length; ++j)
                    object.read[j] = $root.protos.opts.ReadOptions.toObject(message.read[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetAllReadsResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllReadsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllReadsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllReadsResponse;
    })();

    protos.records = (function() {

        /**
         * Namespace records.
         * @memberof protos
         * @namespace
         */
        var records = {};

        records.ReadRecord = (function() {

            /**
             * Properties of a ReadRecord.
             * @memberof protos.records
             * @interface IReadRecord
             * @property {string|null} [messageId] ReadRecord messageId
             * @property {number|Long|null} [num] ReadRecord num
             * @property {Object.<string,string>|null} [metadata] ReadRecord metadata
             * @property {number|Long|null} [receivedAtUnixTsUtc] ReadRecord receivedAtUnixTsUtc
             * @property {Uint8Array|null} [payload] ReadRecord payload
             * @property {protos.records.IKafka|null} [kafka] ReadRecord kafka
             * @property {protos.records.IRabbit|null} [rabbit] ReadRecord rabbit
             * @property {protos.records.IActiveMQ|null} [activemq] ReadRecord activemq
             * @property {protos.records.IAWSSQS|null} [awssqs] ReadRecord awssqs
             * @property {protos.records.IAzureEventHub|null} [azureEventHub] ReadRecord azureEventHub
             * @property {protos.records.IAzureServiceBus|null} [azureServiceBus] ReadRecord azureServiceBus
             * @property {protos.records.IGCPPubSub|null} [gcpPubsub] ReadRecord gcpPubsub
             * @property {protos.records.IKubeMQ|null} [kubemq] ReadRecord kubemq
             * @property {protos.records.IMongo|null} [mongo] ReadRecord mongo
             * @property {protos.records.IMQTT|null} [mqtt] ReadRecord mqtt
             * @property {protos.records.INats|null} [nats] ReadRecord nats
             * @property {protos.records.INatsStreaming|null} [natsStreaming] ReadRecord natsStreaming
             * @property {protos.records.INSQ|null} [nsq] ReadRecord nsq
             * @property {protos.records.IPostgres|null} [postgres] ReadRecord postgres
             * @property {protos.records.IPulsar|null} [pulsar] ReadRecord pulsar
             * @property {protos.records.IRabbitStreams|null} [rabbitStreams] ReadRecord rabbitStreams
             * @property {protos.records.IRedisPubsub|null} [redisPubsub] ReadRecord redisPubsub
             * @property {protos.records.IRedisStreams|null} [redisStreams] ReadRecord redisStreams
             * @property {Uint8Array|null} [_raw] ReadRecord _raw
             * @property {string|null} [_plumberId] ReadRecord _plumberId
             */

            /**
             * Constructs a new ReadRecord.
             * @memberof protos.records
             * @classdesc Represents a ReadRecord.
             * @implements IReadRecord
             * @constructor
             * @param {protos.records.IReadRecord=} [properties] Properties to set
             */
            function ReadRecord(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadRecord messageId.
             * @member {string} messageId
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.messageId = "";

            /**
             * ReadRecord num.
             * @member {number|Long} num
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ReadRecord metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.metadata = $util.emptyObject;

            /**
             * ReadRecord receivedAtUnixTsUtc.
             * @member {number|Long} receivedAtUnixTsUtc
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.receivedAtUnixTsUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ReadRecord payload.
             * @member {Uint8Array} payload
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.payload = $util.newBuffer([]);

            /**
             * ReadRecord kafka.
             * @member {protos.records.IKafka|null|undefined} kafka
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.kafka = null;

            /**
             * ReadRecord rabbit.
             * @member {protos.records.IRabbit|null|undefined} rabbit
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.rabbit = null;

            /**
             * ReadRecord activemq.
             * @member {protos.records.IActiveMQ|null|undefined} activemq
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.activemq = null;

            /**
             * ReadRecord awssqs.
             * @member {protos.records.IAWSSQS|null|undefined} awssqs
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.awssqs = null;

            /**
             * ReadRecord azureEventHub.
             * @member {protos.records.IAzureEventHub|null|undefined} azureEventHub
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.azureEventHub = null;

            /**
             * ReadRecord azureServiceBus.
             * @member {protos.records.IAzureServiceBus|null|undefined} azureServiceBus
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.azureServiceBus = null;

            /**
             * ReadRecord gcpPubsub.
             * @member {protos.records.IGCPPubSub|null|undefined} gcpPubsub
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.gcpPubsub = null;

            /**
             * ReadRecord kubemq.
             * @member {protos.records.IKubeMQ|null|undefined} kubemq
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.kubemq = null;

            /**
             * ReadRecord mongo.
             * @member {protos.records.IMongo|null|undefined} mongo
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.mongo = null;

            /**
             * ReadRecord mqtt.
             * @member {protos.records.IMQTT|null|undefined} mqtt
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.mqtt = null;

            /**
             * ReadRecord nats.
             * @member {protos.records.INats|null|undefined} nats
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.nats = null;

            /**
             * ReadRecord natsStreaming.
             * @member {protos.records.INatsStreaming|null|undefined} natsStreaming
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.natsStreaming = null;

            /**
             * ReadRecord nsq.
             * @member {protos.records.INSQ|null|undefined} nsq
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.nsq = null;

            /**
             * ReadRecord postgres.
             * @member {protos.records.IPostgres|null|undefined} postgres
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.postgres = null;

            /**
             * ReadRecord pulsar.
             * @member {protos.records.IPulsar|null|undefined} pulsar
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.pulsar = null;

            /**
             * ReadRecord rabbitStreams.
             * @member {protos.records.IRabbitStreams|null|undefined} rabbitStreams
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.rabbitStreams = null;

            /**
             * ReadRecord redisPubsub.
             * @member {protos.records.IRedisPubsub|null|undefined} redisPubsub
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.redisPubsub = null;

            /**
             * ReadRecord redisStreams.
             * @member {protos.records.IRedisStreams|null|undefined} redisStreams
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.redisStreams = null;

            /**
             * ReadRecord _raw.
             * @member {Uint8Array} _raw
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype._raw = $util.newBuffer([]);

            /**
             * ReadRecord _plumberId.
             * @member {string} _plumberId
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype._plumberId = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ReadRecord Record.
             * @member {"kafka"|"rabbit"|"activemq"|"awssqs"|"azureEventHub"|"azureServiceBus"|"gcpPubsub"|"kubemq"|"mongo"|"mqtt"|"nats"|"natsStreaming"|"nsq"|"postgres"|"pulsar"|"rabbitStreams"|"redisPubsub"|"redisStreams"|undefined} Record
             * @memberof protos.records.ReadRecord
             * @instance
             */
            Object.defineProperty(ReadRecord.prototype, "Record", {
                get: $util.oneOfGetter($oneOfFields = ["kafka", "rabbit", "activemq", "awssqs", "azureEventHub", "azureServiceBus", "gcpPubsub", "kubemq", "mongo", "mqtt", "nats", "natsStreaming", "nsq", "postgres", "pulsar", "rabbitStreams", "redisPubsub", "redisStreams"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ReadRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord=} [properties] Properties to set
             * @returns {protos.records.ReadRecord} ReadRecord instance
             */
            ReadRecord.create = function create(properties) {
                return new ReadRecord(properties);
            };

            /**
             * Encodes the specified ReadRecord message. Does not implicitly {@link protos.records.ReadRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord} message ReadRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.num);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.receivedAtUnixTsUtc != null && Object.hasOwnProperty.call(message, "receivedAtUnixTsUtc"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.receivedAtUnixTsUtc);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 99, wireType 2 =*/794).bytes(message.payload);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.records.Kafka.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.records.Rabbit.encode(message.rabbit, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.records.ActiveMQ.encode(message.activemq, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.records.AWSSQS.encode(message.awssqs, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.records.AzureEventHub.encode(message.azureEventHub, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.records.AzureServiceBus.encode(message.azureServiceBus, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.records.GCPPubSub.encode(message.gcpPubsub, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.kubemq != null && Object.hasOwnProperty.call(message, "kubemq"))
                    $root.protos.records.KubeMQ.encode(message.kubemq, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.records.Mongo.encode(message.mongo, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.records.MQTT.encode(message.mqtt, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.records.Nats.encode(message.nats, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.records.NatsStreaming.encode(message.natsStreaming, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.records.NSQ.encode(message.nsq, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.records.Postgres.encode(message.postgres, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.records.Pulsar.encode(message.pulsar, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.records.RabbitStreams.encode(message.rabbitStreams, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.records.RedisPubsub.encode(message.redisPubsub, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.records.RedisStreams.encode(message.redisStreams, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message._raw != null && Object.hasOwnProperty.call(message, "_raw"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).bytes(message._raw);
                if (message._plumberId != null && Object.hasOwnProperty.call(message, "_plumberId"))
                    writer.uint32(/* id 1001, wireType 2 =*/8010).string(message._plumberId);
                return writer;
            };

            /**
             * Encodes the specified ReadRecord message, length delimited. Does not implicitly {@link protos.records.ReadRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord} message ReadRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ReadRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ReadRecord} ReadRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ReadRecord(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageId = reader.string();
                        break;
                    case 3:
                        message.num = reader.int64();
                        break;
                    case 4:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 6:
                        message.receivedAtUnixTsUtc = reader.int64();
                        break;
                    case 99:
                        message.payload = reader.bytes();
                        break;
                    case 100:
                        message.kafka = $root.protos.records.Kafka.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.rabbit = $root.protos.records.Rabbit.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.activemq = $root.protos.records.ActiveMQ.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awssqs = $root.protos.records.AWSSQS.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.azureEventHub = $root.protos.records.AzureEventHub.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.azureServiceBus = $root.protos.records.AzureServiceBus.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.gcpPubsub = $root.protos.records.GCPPubSub.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.kubemq = $root.protos.records.KubeMQ.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.mongo = $root.protos.records.Mongo.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.mqtt = $root.protos.records.MQTT.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.nats = $root.protos.records.Nats.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.natsStreaming = $root.protos.records.NatsStreaming.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.nsq = $root.protos.records.NSQ.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.postgres = $root.protos.records.Postgres.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.pulsar = $root.protos.records.Pulsar.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.rabbitStreams = $root.protos.records.RabbitStreams.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisPubsub = $root.protos.records.RedisPubsub.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.redisStreams = $root.protos.records.RedisStreams.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._raw = reader.bytes();
                        break;
                    case 1001:
                        message._plumberId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ReadRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ReadRecord} ReadRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadRecord message.
             * @function verify
             * @memberof protos.records.ReadRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.num != null && message.hasOwnProperty("num"))
                    if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))
                        return "num: integer|Long expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.receivedAtUnixTsUtc != null && message.hasOwnProperty("receivedAtUnixTsUtc"))
                    if (!$util.isInteger(message.receivedAtUnixTsUtc) && !(message.receivedAtUnixTsUtc && $util.isInteger(message.receivedAtUnixTsUtc.low) && $util.isInteger(message.receivedAtUnixTsUtc.high)))
                        return "receivedAtUnixTsUtc: integer|Long expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Kafka.verify(message.kafka);
                        if (error)
                            return "kafka." + error;
                    }
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Rabbit.verify(message.rabbit);
                        if (error)
                            return "rabbit." + error;
                    }
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.ActiveMQ.verify(message.activemq);
                        if (error)
                            return "activemq." + error;
                    }
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AWSSQS.verify(message.awssqs);
                        if (error)
                            return "awssqs." + error;
                    }
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AzureEventHub.verify(message.azureEventHub);
                        if (error)
                            return "azureEventHub." + error;
                    }
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AzureServiceBus.verify(message.azureServiceBus);
                        if (error)
                            return "azureServiceBus." + error;
                    }
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.GCPPubSub.verify(message.gcpPubsub);
                        if (error)
                            return "gcpPubsub." + error;
                    }
                }
                if (message.kubemq != null && message.hasOwnProperty("kubemq")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.KubeMQ.verify(message.kubemq);
                        if (error)
                            return "kubemq." + error;
                    }
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Mongo.verify(message.mongo);
                        if (error)
                            return "mongo." + error;
                    }
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.MQTT.verify(message.mqtt);
                        if (error)
                            return "mqtt." + error;
                    }
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Nats.verify(message.nats);
                        if (error)
                            return "nats." + error;
                    }
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.NatsStreaming.verify(message.natsStreaming);
                        if (error)
                            return "natsStreaming." + error;
                    }
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.NSQ.verify(message.nsq);
                        if (error)
                            return "nsq." + error;
                    }
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Postgres.verify(message.postgres);
                        if (error)
                            return "postgres." + error;
                    }
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Pulsar.verify(message.pulsar);
                        if (error)
                            return "pulsar." + error;
                    }
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.RabbitStreams.verify(message.rabbitStreams);
                        if (error)
                            return "rabbitStreams." + error;
                    }
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.RedisPubsub.verify(message.redisPubsub);
                        if (error)
                            return "redisPubsub." + error;
                    }
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.RedisStreams.verify(message.redisStreams);
                        if (error)
                            return "redisStreams." + error;
                    }
                }
                if (message._raw != null && message.hasOwnProperty("_raw"))
                    if (!(message._raw && typeof message._raw.length === "number" || $util.isString(message._raw)))
                        return "_raw: buffer expected";
                if (message._plumberId != null && message.hasOwnProperty("_plumberId"))
                    if (!$util.isString(message._plumberId))
                        return "_plumberId: string expected";
                return null;
            };

            /**
             * Creates a ReadRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ReadRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ReadRecord} ReadRecord
             */
            ReadRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ReadRecord)
                    return object;
                var message = new $root.protos.records.ReadRecord();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.num != null)
                    if ($util.Long)
                        (message.num = $util.Long.fromValue(object.num)).unsigned = false;
                    else if (typeof object.num === "string")
                        message.num = parseInt(object.num, 10);
                    else if (typeof object.num === "number")
                        message.num = object.num;
                    else if (typeof object.num === "object")
                        message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.ReadRecord.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.receivedAtUnixTsUtc != null)
                    if ($util.Long)
                        (message.receivedAtUnixTsUtc = $util.Long.fromValue(object.receivedAtUnixTsUtc)).unsigned = false;
                    else if (typeof object.receivedAtUnixTsUtc === "string")
                        message.receivedAtUnixTsUtc = parseInt(object.receivedAtUnixTsUtc, 10);
                    else if (typeof object.receivedAtUnixTsUtc === "number")
                        message.receivedAtUnixTsUtc = object.receivedAtUnixTsUtc;
                    else if (typeof object.receivedAtUnixTsUtc === "object")
                        message.receivedAtUnixTsUtc = new $util.LongBits(object.receivedAtUnixTsUtc.low >>> 0, object.receivedAtUnixTsUtc.high >>> 0).toNumber();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.records.ReadRecord.kafka: object expected");
                    message.kafka = $root.protos.records.Kafka.fromObject(object.kafka);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.records.ReadRecord.rabbit: object expected");
                    message.rabbit = $root.protos.records.Rabbit.fromObject(object.rabbit);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.records.ReadRecord.activemq: object expected");
                    message.activemq = $root.protos.records.ActiveMQ.fromObject(object.activemq);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.records.ReadRecord.awssqs: object expected");
                    message.awssqs = $root.protos.records.AWSSQS.fromObject(object.awssqs);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.records.ReadRecord.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.records.AzureEventHub.fromObject(object.azureEventHub);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.records.ReadRecord.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.records.AzureServiceBus.fromObject(object.azureServiceBus);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.records.ReadRecord.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.records.GCPPubSub.fromObject(object.gcpPubsub);
                }
                if (object.kubemq != null) {
                    if (typeof object.kubemq !== "object")
                        throw TypeError(".protos.records.ReadRecord.kubemq: object expected");
                    message.kubemq = $root.protos.records.KubeMQ.fromObject(object.kubemq);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.records.ReadRecord.mongo: object expected");
                    message.mongo = $root.protos.records.Mongo.fromObject(object.mongo);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.records.ReadRecord.mqtt: object expected");
                    message.mqtt = $root.protos.records.MQTT.fromObject(object.mqtt);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.records.ReadRecord.nats: object expected");
                    message.nats = $root.protos.records.Nats.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.records.ReadRecord.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.records.NatsStreaming.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.records.ReadRecord.nsq: object expected");
                    message.nsq = $root.protos.records.NSQ.fromObject(object.nsq);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.records.ReadRecord.postgres: object expected");
                    message.postgres = $root.protos.records.Postgres.fromObject(object.postgres);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.records.ReadRecord.pulsar: object expected");
                    message.pulsar = $root.protos.records.Pulsar.fromObject(object.pulsar);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.records.ReadRecord.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.records.RabbitStreams.fromObject(object.rabbitStreams);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.records.ReadRecord.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.records.RedisPubsub.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.records.ReadRecord.redisStreams: object expected");
                    message.redisStreams = $root.protos.records.RedisStreams.fromObject(object.redisStreams);
                }
                if (object._raw != null)
                    if (typeof object._raw === "string")
                        $util.base64.decode(object._raw, message._raw = $util.newBuffer($util.base64.length(object._raw)), 0);
                    else if (object._raw.length)
                        message._raw = object._raw;
                if (object._plumberId != null)
                    message._plumberId = String(object._plumberId);
                return message;
            };

            /**
             * Creates a plain object from a ReadRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.ReadRecord} message ReadRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    object.messageId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.num = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.receivedAtUnixTsUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.receivedAtUnixTsUtc = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object._raw = "";
                    else {
                        object._raw = [];
                        if (options.bytes !== Array)
                            object._raw = $util.newBuffer(object._raw);
                    }
                    object._plumberId = "";
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.num != null && message.hasOwnProperty("num"))
                    if (typeof message.num === "number")
                        object.num = options.longs === String ? String(message.num) : message.num;
                    else
                        object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.receivedAtUnixTsUtc != null && message.hasOwnProperty("receivedAtUnixTsUtc"))
                    if (typeof message.receivedAtUnixTsUtc === "number")
                        object.receivedAtUnixTsUtc = options.longs === String ? String(message.receivedAtUnixTsUtc) : message.receivedAtUnixTsUtc;
                    else
                        object.receivedAtUnixTsUtc = options.longs === String ? $util.Long.prototype.toString.call(message.receivedAtUnixTsUtc) : options.longs === Number ? new $util.LongBits(message.receivedAtUnixTsUtc.low >>> 0, message.receivedAtUnixTsUtc.high >>> 0).toNumber() : message.receivedAtUnixTsUtc;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    object.kafka = $root.protos.records.Kafka.toObject(message.kafka, options);
                    if (options.oneofs)
                        object.Record = "kafka";
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    object.rabbit = $root.protos.records.Rabbit.toObject(message.rabbit, options);
                    if (options.oneofs)
                        object.Record = "rabbit";
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    object.activemq = $root.protos.records.ActiveMQ.toObject(message.activemq, options);
                    if (options.oneofs)
                        object.Record = "activemq";
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    object.awssqs = $root.protos.records.AWSSQS.toObject(message.awssqs, options);
                    if (options.oneofs)
                        object.Record = "awssqs";
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    object.azureEventHub = $root.protos.records.AzureEventHub.toObject(message.azureEventHub, options);
                    if (options.oneofs)
                        object.Record = "azureEventHub";
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    object.azureServiceBus = $root.protos.records.AzureServiceBus.toObject(message.azureServiceBus, options);
                    if (options.oneofs)
                        object.Record = "azureServiceBus";
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    object.gcpPubsub = $root.protos.records.GCPPubSub.toObject(message.gcpPubsub, options);
                    if (options.oneofs)
                        object.Record = "gcpPubsub";
                }
                if (message.kubemq != null && message.hasOwnProperty("kubemq")) {
                    object.kubemq = $root.protos.records.KubeMQ.toObject(message.kubemq, options);
                    if (options.oneofs)
                        object.Record = "kubemq";
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    object.mongo = $root.protos.records.Mongo.toObject(message.mongo, options);
                    if (options.oneofs)
                        object.Record = "mongo";
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    object.mqtt = $root.protos.records.MQTT.toObject(message.mqtt, options);
                    if (options.oneofs)
                        object.Record = "mqtt";
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    object.nats = $root.protos.records.Nats.toObject(message.nats, options);
                    if (options.oneofs)
                        object.Record = "nats";
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    object.natsStreaming = $root.protos.records.NatsStreaming.toObject(message.natsStreaming, options);
                    if (options.oneofs)
                        object.Record = "natsStreaming";
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    object.nsq = $root.protos.records.NSQ.toObject(message.nsq, options);
                    if (options.oneofs)
                        object.Record = "nsq";
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    object.postgres = $root.protos.records.Postgres.toObject(message.postgres, options);
                    if (options.oneofs)
                        object.Record = "postgres";
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    object.pulsar = $root.protos.records.Pulsar.toObject(message.pulsar, options);
                    if (options.oneofs)
                        object.Record = "pulsar";
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    object.rabbitStreams = $root.protos.records.RabbitStreams.toObject(message.rabbitStreams, options);
                    if (options.oneofs)
                        object.Record = "rabbitStreams";
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    object.redisPubsub = $root.protos.records.RedisPubsub.toObject(message.redisPubsub, options);
                    if (options.oneofs)
                        object.Record = "redisPubsub";
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    object.redisStreams = $root.protos.records.RedisStreams.toObject(message.redisStreams, options);
                    if (options.oneofs)
                        object.Record = "redisStreams";
                }
                if (message._raw != null && message.hasOwnProperty("_raw"))
                    object._raw = options.bytes === String ? $util.base64.encode(message._raw, 0, message._raw.length) : options.bytes === Array ? Array.prototype.slice.call(message._raw) : message._raw;
                if (message._plumberId != null && message.hasOwnProperty("_plumberId"))
                    object._plumberId = message._plumberId;
                return object;
            };

            /**
             * Converts this ReadRecord to JSON.
             * @function toJSON
             * @memberof protos.records.ReadRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadRecord;
        })();

        records.WriteRecord = (function() {

            /**
             * Properties of a WriteRecord.
             * @memberof protos.records
             * @interface IWriteRecord
             * @property {string|null} [input] WriteRecord input
             * @property {Object.<string,string>|null} [inputMetadata] WriteRecord inputMetadata
             */

            /**
             * Constructs a new WriteRecord.
             * @memberof protos.records
             * @classdesc Represents a WriteRecord.
             * @implements IWriteRecord
             * @constructor
             * @param {protos.records.IWriteRecord=} [properties] Properties to set
             */
            function WriteRecord(properties) {
                this.inputMetadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteRecord input.
             * @member {string} input
             * @memberof protos.records.WriteRecord
             * @instance
             */
            WriteRecord.prototype.input = "";

            /**
             * WriteRecord inputMetadata.
             * @member {Object.<string,string>} inputMetadata
             * @memberof protos.records.WriteRecord
             * @instance
             */
            WriteRecord.prototype.inputMetadata = $util.emptyObject;

            /**
             * Creates a new WriteRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord=} [properties] Properties to set
             * @returns {protos.records.WriteRecord} WriteRecord instance
             */
            WriteRecord.create = function create(properties) {
                return new WriteRecord(properties);
            };

            /**
             * Encodes the specified WriteRecord message. Does not implicitly {@link protos.records.WriteRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord} message WriteRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.input);
                if (message.inputMetadata != null && Object.hasOwnProperty.call(message, "inputMetadata"))
                    for (var keys = Object.keys(message.inputMetadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.inputMetadata[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteRecord message, length delimited. Does not implicitly {@link protos.records.WriteRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord} message WriteRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.WriteRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.WriteRecord} WriteRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.WriteRecord(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.input = reader.string();
                        break;
                    case 2:
                        if (message.inputMetadata === $util.emptyObject)
                            message.inputMetadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.inputMetadata[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.WriteRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.WriteRecord} WriteRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteRecord message.
             * @function verify
             * @memberof protos.records.WriteRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.input != null && message.hasOwnProperty("input"))
                    if (!$util.isString(message.input))
                        return "input: string expected";
                if (message.inputMetadata != null && message.hasOwnProperty("inputMetadata")) {
                    if (!$util.isObject(message.inputMetadata))
                        return "inputMetadata: object expected";
                    var key = Object.keys(message.inputMetadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.inputMetadata[key[i]]))
                            return "inputMetadata: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a WriteRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.WriteRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.WriteRecord} WriteRecord
             */
            WriteRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.WriteRecord)
                    return object;
                var message = new $root.protos.records.WriteRecord();
                if (object.input != null)
                    message.input = String(object.input);
                if (object.inputMetadata) {
                    if (typeof object.inputMetadata !== "object")
                        throw TypeError(".protos.records.WriteRecord.inputMetadata: object expected");
                    message.inputMetadata = {};
                    for (var keys = Object.keys(object.inputMetadata), i = 0; i < keys.length; ++i)
                        message.inputMetadata[keys[i]] = String(object.inputMetadata[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.WriteRecord} message WriteRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.inputMetadata = {};
                if (options.defaults)
                    object.input = "";
                if (message.input != null && message.hasOwnProperty("input"))
                    object.input = message.input;
                var keys2;
                if (message.inputMetadata && (keys2 = Object.keys(message.inputMetadata)).length) {
                    object.inputMetadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.inputMetadata[keys2[j]] = message.inputMetadata[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this WriteRecord to JSON.
             * @function toJSON
             * @memberof protos.records.WriteRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteRecord;
        })();

        records.ErrorRecord = (function() {

            /**
             * Properties of an ErrorRecord.
             * @memberof protos.records
             * @interface IErrorRecord
             * @property {number|Long|null} [occurredAtUnixTsUtc] ErrorRecord occurredAtUnixTsUtc
             * @property {string|null} [error] ErrorRecord error
             * @property {Object.<string,Uint8Array>|null} [metadata] ErrorRecord metadata
             */

            /**
             * Constructs a new ErrorRecord.
             * @memberof protos.records
             * @classdesc Represents an ErrorRecord.
             * @implements IErrorRecord
             * @constructor
             * @param {protos.records.IErrorRecord=} [properties] Properties to set
             */
            function ErrorRecord(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorRecord occurredAtUnixTsUtc.
             * @member {number|Long} occurredAtUnixTsUtc
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.occurredAtUnixTsUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ErrorRecord error.
             * @member {string} error
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.error = "";

            /**
             * ErrorRecord metadata.
             * @member {Object.<string,Uint8Array>} metadata
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.metadata = $util.emptyObject;

            /**
             * Creates a new ErrorRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord=} [properties] Properties to set
             * @returns {protos.records.ErrorRecord} ErrorRecord instance
             */
            ErrorRecord.create = function create(properties) {
                return new ErrorRecord(properties);
            };

            /**
             * Encodes the specified ErrorRecord message. Does not implicitly {@link protos.records.ErrorRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord} message ErrorRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.occurredAtUnixTsUtc != null && Object.hasOwnProperty.call(message, "occurredAtUnixTsUtc"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.occurredAtUnixTsUtc);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ErrorRecord message, length delimited. Does not implicitly {@link protos.records.ErrorRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord} message ErrorRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ErrorRecord} ErrorRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ErrorRecord(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.occurredAtUnixTsUtc = reader.int64();
                        break;
                    case 2:
                        message.error = reader.string();
                        break;
                    case 3:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = [];
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ErrorRecord} ErrorRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorRecord message.
             * @function verify
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.occurredAtUnixTsUtc != null && message.hasOwnProperty("occurredAtUnixTsUtc"))
                    if (!$util.isInteger(message.occurredAtUnixTsUtc) && !(message.occurredAtUnixTsUtc && $util.isInteger(message.occurredAtUnixTsUtc.low) && $util.isInteger(message.occurredAtUnixTsUtc.high)))
                        return "occurredAtUnixTsUtc: integer|Long expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!(message.metadata[key[i]] && typeof message.metadata[key[i]].length === "number" || $util.isString(message.metadata[key[i]])))
                            return "metadata: buffer{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an ErrorRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ErrorRecord} ErrorRecord
             */
            ErrorRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ErrorRecord)
                    return object;
                var message = new $root.protos.records.ErrorRecord();
                if (object.occurredAtUnixTsUtc != null)
                    if ($util.Long)
                        (message.occurredAtUnixTsUtc = $util.Long.fromValue(object.occurredAtUnixTsUtc)).unsigned = false;
                    else if (typeof object.occurredAtUnixTsUtc === "string")
                        message.occurredAtUnixTsUtc = parseInt(object.occurredAtUnixTsUtc, 10);
                    else if (typeof object.occurredAtUnixTsUtc === "number")
                        message.occurredAtUnixTsUtc = object.occurredAtUnixTsUtc;
                    else if (typeof object.occurredAtUnixTsUtc === "object")
                        message.occurredAtUnixTsUtc = new $util.LongBits(object.occurredAtUnixTsUtc.low >>> 0, object.occurredAtUnixTsUtc.high >>> 0).toNumber();
                if (object.error != null)
                    message.error = String(object.error);
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.ErrorRecord.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        if (typeof object.metadata[keys[i]] === "string")
                            $util.base64.decode(object.metadata[keys[i]], message.metadata[keys[i]] = $util.newBuffer($util.base64.length(object.metadata[keys[i]])), 0);
                        else if (object.metadata[keys[i]].length)
                            message.metadata[keys[i]] = object.metadata[keys[i]];
                }
                return message;
            };

            /**
             * Creates a plain object from an ErrorRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.ErrorRecord} message ErrorRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.occurredAtUnixTsUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.occurredAtUnixTsUtc = options.longs === String ? "0" : 0;
                    object.error = "";
                }
                if (message.occurredAtUnixTsUtc != null && message.hasOwnProperty("occurredAtUnixTsUtc"))
                    if (typeof message.occurredAtUnixTsUtc === "number")
                        object.occurredAtUnixTsUtc = options.longs === String ? String(message.occurredAtUnixTsUtc) : message.occurredAtUnixTsUtc;
                    else
                        object.occurredAtUnixTsUtc = options.longs === String ? $util.Long.prototype.toString.call(message.occurredAtUnixTsUtc) : options.longs === Number ? new $util.LongBits(message.occurredAtUnixTsUtc.low >>> 0, message.occurredAtUnixTsUtc.high >>> 0).toNumber() : message.occurredAtUnixTsUtc;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = options.bytes === String ? $util.base64.encode(message.metadata[keys2[j]], 0, message.metadata[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata[keys2[j]]) : message.metadata[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this ErrorRecord to JSON.
             * @function toJSON
             * @memberof protos.records.ErrorRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ErrorRecord;
        })();

        records.KafkaHeader = (function() {

            /**
             * Properties of a KafkaHeader.
             * @memberof protos.records
             * @interface IKafkaHeader
             * @property {string|null} [key] KafkaHeader key
             * @property {string|null} [value] KafkaHeader value
             */

            /**
             * Constructs a new KafkaHeader.
             * @memberof protos.records
             * @classdesc Represents a KafkaHeader.
             * @implements IKafkaHeader
             * @constructor
             * @param {protos.records.IKafkaHeader=} [properties] Properties to set
             */
            function KafkaHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaHeader key.
             * @member {string} key
             * @memberof protos.records.KafkaHeader
             * @instance
             */
            KafkaHeader.prototype.key = "";

            /**
             * KafkaHeader value.
             * @member {string} value
             * @memberof protos.records.KafkaHeader
             * @instance
             */
            KafkaHeader.prototype.value = "";

            /**
             * Creates a new KafkaHeader instance using the specified properties.
             * @function create
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader=} [properties] Properties to set
             * @returns {protos.records.KafkaHeader} KafkaHeader instance
             */
            KafkaHeader.create = function create(properties) {
                return new KafkaHeader(properties);
            };

            /**
             * Encodes the specified KafkaHeader message. Does not implicitly {@link protos.records.KafkaHeader.verify|verify} messages.
             * @function encode
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader} message KafkaHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified KafkaHeader message, length delimited. Does not implicitly {@link protos.records.KafkaHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader} message KafkaHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaHeader message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.KafkaHeader} KafkaHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.KafkaHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.KafkaHeader} KafkaHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaHeader message.
             * @function verify
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a KafkaHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.KafkaHeader} KafkaHeader
             */
            KafkaHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.KafkaHeader)
                    return object;
                var message = new $root.protos.records.KafkaHeader();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a KafkaHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.KafkaHeader} message KafkaHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this KafkaHeader to JSON.
             * @function toJSON
             * @memberof protos.records.KafkaHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaHeader;
        })();

        records.Kafka = (function() {

            /**
             * Properties of a Kafka.
             * @memberof protos.records
             * @interface IKafka
             * @property {string|null} [topic] Kafka topic
             * @property {Uint8Array|null} [key] Kafka key
             * @property {Uint8Array|null} [value] Kafka value
             * @property {number|Long|null} [timestamp] Kafka timestamp
             * @property {number|Long|null} [offset] Kafka offset
             * @property {number|null} [partition] Kafka partition
             * @property {Array.<protos.records.IKafkaHeader>|null} [headers] Kafka headers
             */

            /**
             * Constructs a new Kafka.
             * @memberof protos.records
             * @classdesc Represents a Kafka.
             * @implements IKafka
             * @constructor
             * @param {protos.records.IKafka=} [properties] Properties to set
             */
            function Kafka(properties) {
                this.headers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Kafka topic.
             * @member {string} topic
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.topic = "";

            /**
             * Kafka key.
             * @member {Uint8Array} key
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.key = $util.newBuffer([]);

            /**
             * Kafka value.
             * @member {Uint8Array} value
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.value = $util.newBuffer([]);

            /**
             * Kafka timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Kafka offset.
             * @member {number|Long} offset
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Kafka partition.
             * @member {number} partition
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.partition = 0;

            /**
             * Kafka headers.
             * @member {Array.<protos.records.IKafkaHeader>} headers
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.headers = $util.emptyArray;

            /**
             * Creates a new Kafka instance using the specified properties.
             * @function create
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka=} [properties] Properties to set
             * @returns {protos.records.Kafka} Kafka instance
             */
            Kafka.create = function create(properties) {
                return new Kafka(properties);
            };

            /**
             * Encodes the specified Kafka message. Does not implicitly {@link protos.records.Kafka.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka} message Kafka message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Kafka.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.offset);
                if (message.partition != null && Object.hasOwnProperty.call(message, "partition"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.partition);
                if (message.headers != null && message.headers.length)
                    for (var i = 0; i < message.headers.length; ++i)
                        $root.protos.records.KafkaHeader.encode(message.headers[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Kafka message, length delimited. Does not implicitly {@link protos.records.Kafka.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka} message Kafka message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Kafka.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Kafka message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Kafka
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Kafka} Kafka
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Kafka.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Kafka();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.key = reader.bytes();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    case 4:
                        message.timestamp = reader.int64();
                        break;
                    case 5:
                        message.offset = reader.int64();
                        break;
                    case 6:
                        message.partition = reader.int32();
                        break;
                    case 7:
                        if (!(message.headers && message.headers.length))
                            message.headers = [];
                        message.headers.push($root.protos.records.KafkaHeader.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Kafka message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Kafka
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Kafka} Kafka
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Kafka.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Kafka message.
             * @function verify
             * @memberof protos.records.Kafka
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Kafka.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                        return "offset: integer|Long expected";
                if (message.partition != null && message.hasOwnProperty("partition"))
                    if (!$util.isInteger(message.partition))
                        return "partition: integer expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!Array.isArray(message.headers))
                        return "headers: array expected";
                    for (var i = 0; i < message.headers.length; ++i) {
                        var error = $root.protos.records.KafkaHeader.verify(message.headers[i]);
                        if (error)
                            return "headers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Kafka message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Kafka
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Kafka} Kafka
             */
            Kafka.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Kafka)
                    return object;
                var message = new $root.protos.records.Kafka();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.offset != null)
                    if ($util.Long)
                        (message.offset = $util.Long.fromValue(object.offset)).unsigned = false;
                    else if (typeof object.offset === "string")
                        message.offset = parseInt(object.offset, 10);
                    else if (typeof object.offset === "number")
                        message.offset = object.offset;
                    else if (typeof object.offset === "object")
                        message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber();
                if (object.partition != null)
                    message.partition = object.partition | 0;
                if (object.headers) {
                    if (!Array.isArray(object.headers))
                        throw TypeError(".protos.records.Kafka.headers: array expected");
                    message.headers = [];
                    for (var i = 0; i < object.headers.length; ++i) {
                        if (typeof object.headers[i] !== "object")
                            throw TypeError(".protos.records.Kafka.headers: object expected");
                        message.headers[i] = $root.protos.records.KafkaHeader.fromObject(object.headers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Kafka message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.Kafka} message Kafka
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Kafka.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.headers = [];
                if (options.defaults) {
                    object.topic = "";
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.offset = options.longs === String ? "0" : 0;
                    object.partition = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (typeof message.offset === "number")
                        object.offset = options.longs === String ? String(message.offset) : message.offset;
                    else
                        object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber() : message.offset;
                if (message.partition != null && message.hasOwnProperty("partition"))
                    object.partition = message.partition;
                if (message.headers && message.headers.length) {
                    object.headers = [];
                    for (var j = 0; j < message.headers.length; ++j)
                        object.headers[j] = $root.protos.records.KafkaHeader.toObject(message.headers[j], options);
                }
                return object;
            };

            /**
             * Converts this Kafka to JSON.
             * @function toJSON
             * @memberof protos.records.Kafka
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Kafka.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Kafka;
        })();

        records.RabbitHeader = (function() {

            /**
             * Properties of a RabbitHeader.
             * @memberof protos.records
             * @interface IRabbitHeader
             * @property {string|null} [key] RabbitHeader key
             * @property {string|null} [value] RabbitHeader value
             */

            /**
             * Constructs a new RabbitHeader.
             * @memberof protos.records
             * @classdesc Represents a RabbitHeader.
             * @implements IRabbitHeader
             * @constructor
             * @param {protos.records.IRabbitHeader=} [properties] Properties to set
             */
            function RabbitHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitHeader key.
             * @member {string} key
             * @memberof protos.records.RabbitHeader
             * @instance
             */
            RabbitHeader.prototype.key = "";

            /**
             * RabbitHeader value.
             * @member {string} value
             * @memberof protos.records.RabbitHeader
             * @instance
             */
            RabbitHeader.prototype.value = "";

            /**
             * Creates a new RabbitHeader instance using the specified properties.
             * @function create
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.IRabbitHeader=} [properties] Properties to set
             * @returns {protos.records.RabbitHeader} RabbitHeader instance
             */
            RabbitHeader.create = function create(properties) {
                return new RabbitHeader(properties);
            };

            /**
             * Encodes the specified RabbitHeader message. Does not implicitly {@link protos.records.RabbitHeader.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.IRabbitHeader} message RabbitHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified RabbitHeader message, length delimited. Does not implicitly {@link protos.records.RabbitHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.IRabbitHeader} message RabbitHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitHeader message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RabbitHeader} RabbitHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RabbitHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RabbitHeader} RabbitHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitHeader message.
             * @function verify
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a RabbitHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RabbitHeader} RabbitHeader
             */
            RabbitHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RabbitHeader)
                    return object;
                var message = new $root.protos.records.RabbitHeader();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a RabbitHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.RabbitHeader} message RabbitHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this RabbitHeader to JSON.
             * @function toJSON
             * @memberof protos.records.RabbitHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitHeader;
        })();

        records.Rabbit = (function() {

            /**
             * Properties of a Rabbit.
             * @memberof protos.records
             * @interface IRabbit
             * @property {Uint8Array|null} [body] Rabbit body
             * @property {number|Long|null} [timestamp] Rabbit timestamp
             * @property {string|null} [type] Rabbit type
             * @property {string|null} [exchange] Rabbit exchange
             * @property {string|null} [routingKey] Rabbit routingKey
             * @property {string|null} [contentType] Rabbit contentType
             * @property {string|null} [contentEncoding] Rabbit contentEncoding
             * @property {number|null} [priority] Rabbit priority
             * @property {string|null} [expiration] Rabbit expiration
             * @property {string|null} [messageId] Rabbit messageId
             * @property {string|null} [userId] Rabbit userId
             * @property {string|null} [appId] Rabbit appId
             * @property {string|null} [replyTo] Rabbit replyTo
             * @property {string|null} [correlationId] Rabbit correlationId
             * @property {Array.<protos.records.IRabbitHeader>|null} [headers] Rabbit headers
             */

            /**
             * Constructs a new Rabbit.
             * @memberof protos.records
             * @classdesc Represents a Rabbit.
             * @implements IRabbit
             * @constructor
             * @param {protos.records.IRabbit=} [properties] Properties to set
             */
            function Rabbit(properties) {
                this.headers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Rabbit body.
             * @member {Uint8Array} body
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.body = $util.newBuffer([]);

            /**
             * Rabbit timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Rabbit type.
             * @member {string} type
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.type = "";

            /**
             * Rabbit exchange.
             * @member {string} exchange
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.exchange = "";

            /**
             * Rabbit routingKey.
             * @member {string} routingKey
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.routingKey = "";

            /**
             * Rabbit contentType.
             * @member {string} contentType
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.contentType = "";

            /**
             * Rabbit contentEncoding.
             * @member {string} contentEncoding
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.contentEncoding = "";

            /**
             * Rabbit priority.
             * @member {number} priority
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.priority = 0;

            /**
             * Rabbit expiration.
             * @member {string} expiration
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.expiration = "";

            /**
             * Rabbit messageId.
             * @member {string} messageId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.messageId = "";

            /**
             * Rabbit userId.
             * @member {string} userId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.userId = "";

            /**
             * Rabbit appId.
             * @member {string} appId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.appId = "";

            /**
             * Rabbit replyTo.
             * @member {string} replyTo
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.replyTo = "";

            /**
             * Rabbit correlationId.
             * @member {string} correlationId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.correlationId = "";

            /**
             * Rabbit headers.
             * @member {Array.<protos.records.IRabbitHeader>} headers
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.headers = $util.emptyArray;

            /**
             * Creates a new Rabbit instance using the specified properties.
             * @function create
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.IRabbit=} [properties] Properties to set
             * @returns {protos.records.Rabbit} Rabbit instance
             */
            Rabbit.create = function create(properties) {
                return new Rabbit(properties);
            };

            /**
             * Encodes the specified Rabbit message. Does not implicitly {@link protos.records.Rabbit.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.IRabbit} message Rabbit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rabbit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.body);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
                if (message.exchange != null && Object.hasOwnProperty.call(message, "exchange"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.exchange);
                if (message.routingKey != null && Object.hasOwnProperty.call(message, "routingKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.routingKey);
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.contentType);
                if (message.contentEncoding != null && Object.hasOwnProperty.call(message, "contentEncoding"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.contentEncoding);
                if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.priority);
                if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.expiration);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.messageId);
                if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.userId);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.appId);
                if (message.replyTo != null && Object.hasOwnProperty.call(message, "replyTo"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.replyTo);
                if (message.correlationId != null && Object.hasOwnProperty.call(message, "correlationId"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.correlationId);
                if (message.headers != null && message.headers.length)
                    for (var i = 0; i < message.headers.length; ++i)
                        $root.protos.records.RabbitHeader.encode(message.headers[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Rabbit message, length delimited. Does not implicitly {@link protos.records.Rabbit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.IRabbit} message Rabbit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rabbit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Rabbit message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Rabbit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Rabbit} Rabbit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rabbit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Rabbit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.body = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.type = reader.string();
                        break;
                    case 4:
                        message.exchange = reader.string();
                        break;
                    case 5:
                        message.routingKey = reader.string();
                        break;
                    case 6:
                        message.contentType = reader.string();
                        break;
                    case 7:
                        message.contentEncoding = reader.string();
                        break;
                    case 8:
                        message.priority = reader.int32();
                        break;
                    case 9:
                        message.expiration = reader.string();
                        break;
                    case 10:
                        message.messageId = reader.string();
                        break;
                    case 11:
                        message.userId = reader.string();
                        break;
                    case 12:
                        message.appId = reader.string();
                        break;
                    case 13:
                        message.replyTo = reader.string();
                        break;
                    case 14:
                        message.correlationId = reader.string();
                        break;
                    case 15:
                        if (!(message.headers && message.headers.length))
                            message.headers = [];
                        message.headers.push($root.protos.records.RabbitHeader.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Rabbit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Rabbit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Rabbit} Rabbit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rabbit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Rabbit message.
             * @function verify
             * @memberof protos.records.Rabbit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Rabbit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                        return "body: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.exchange != null && message.hasOwnProperty("exchange"))
                    if (!$util.isString(message.exchange))
                        return "exchange: string expected";
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    if (!$util.isString(message.routingKey))
                        return "routingKey: string expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.contentEncoding != null && message.hasOwnProperty("contentEncoding"))
                    if (!$util.isString(message.contentEncoding))
                        return "contentEncoding: string expected";
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (!$util.isString(message.expiration))
                        return "expiration: string expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.userId != null && message.hasOwnProperty("userId"))
                    if (!$util.isString(message.userId))
                        return "userId: string expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!$util.isString(message.appId))
                        return "appId: string expected";
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    if (!$util.isString(message.replyTo))
                        return "replyTo: string expected";
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    if (!$util.isString(message.correlationId))
                        return "correlationId: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!Array.isArray(message.headers))
                        return "headers: array expected";
                    for (var i = 0; i < message.headers.length; ++i) {
                        var error = $root.protos.records.RabbitHeader.verify(message.headers[i]);
                        if (error)
                            return "headers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Rabbit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Rabbit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Rabbit} Rabbit
             */
            Rabbit.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Rabbit)
                    return object;
                var message = new $root.protos.records.Rabbit();
                if (object.body != null)
                    if (typeof object.body === "string")
                        $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                    else if (object.body.length)
                        message.body = object.body;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.type != null)
                    message.type = String(object.type);
                if (object.exchange != null)
                    message.exchange = String(object.exchange);
                if (object.routingKey != null)
                    message.routingKey = String(object.routingKey);
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.contentEncoding != null)
                    message.contentEncoding = String(object.contentEncoding);
                if (object.priority != null)
                    message.priority = object.priority | 0;
                if (object.expiration != null)
                    message.expiration = String(object.expiration);
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.userId != null)
                    message.userId = String(object.userId);
                if (object.appId != null)
                    message.appId = String(object.appId);
                if (object.replyTo != null)
                    message.replyTo = String(object.replyTo);
                if (object.correlationId != null)
                    message.correlationId = String(object.correlationId);
                if (object.headers) {
                    if (!Array.isArray(object.headers))
                        throw TypeError(".protos.records.Rabbit.headers: array expected");
                    message.headers = [];
                    for (var i = 0; i < object.headers.length; ++i) {
                        if (typeof object.headers[i] !== "object")
                            throw TypeError(".protos.records.Rabbit.headers: object expected");
                        message.headers[i] = $root.protos.records.RabbitHeader.fromObject(object.headers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Rabbit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.Rabbit} message Rabbit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Rabbit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.headers = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.body = "";
                    else {
                        object.body = [];
                        if (options.bytes !== Array)
                            object.body = $util.newBuffer(object.body);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.type = "";
                    object.exchange = "";
                    object.routingKey = "";
                    object.contentType = "";
                    object.contentEncoding = "";
                    object.priority = 0;
                    object.expiration = "";
                    object.messageId = "";
                    object.userId = "";
                    object.appId = "";
                    object.replyTo = "";
                    object.correlationId = "";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.exchange != null && message.hasOwnProperty("exchange"))
                    object.exchange = message.exchange;
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    object.routingKey = message.routingKey;
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.contentEncoding != null && message.hasOwnProperty("contentEncoding"))
                    object.contentEncoding = message.contentEncoding;
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    object.expiration = message.expiration;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.userId != null && message.hasOwnProperty("userId"))
                    object.userId = message.userId;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = message.appId;
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    object.replyTo = message.replyTo;
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    object.correlationId = message.correlationId;
                if (message.headers && message.headers.length) {
                    object.headers = [];
                    for (var j = 0; j < message.headers.length; ++j)
                        object.headers[j] = $root.protos.records.RabbitHeader.toObject(message.headers[j], options);
                }
                return object;
            };

            /**
             * Converts this Rabbit to JSON.
             * @function toJSON
             * @memberof protos.records.Rabbit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Rabbit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Rabbit;
        })();

        records.ActiveMQ = (function() {

            /**
             * Properties of an ActiveMQ.
             * @memberof protos.records
             * @interface IActiveMQ
             * @property {string|null} [destination] ActiveMQ destination
             * @property {string|null} [contentType] ActiveMQ contentType
             * @property {string|null} [subscriptionId] ActiveMQ subscriptionId
             * @property {number|Long|null} [timestamp] ActiveMQ timestamp
             * @property {Uint8Array|null} [value] ActiveMQ value
             */

            /**
             * Constructs a new ActiveMQ.
             * @memberof protos.records
             * @classdesc Represents an ActiveMQ.
             * @implements IActiveMQ
             * @constructor
             * @param {protos.records.IActiveMQ=} [properties] Properties to set
             */
            function ActiveMQ(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQ destination.
             * @member {string} destination
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.destination = "";

            /**
             * ActiveMQ contentType.
             * @member {string} contentType
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.contentType = "";

            /**
             * ActiveMQ subscriptionId.
             * @member {string} subscriptionId
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.subscriptionId = "";

            /**
             * ActiveMQ timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ActiveMQ value.
             * @member {Uint8Array} value
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new ActiveMQ instance using the specified properties.
             * @function create
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.IActiveMQ=} [properties] Properties to set
             * @returns {protos.records.ActiveMQ} ActiveMQ instance
             */
            ActiveMQ.create = function create(properties) {
                return new ActiveMQ(properties);
            };

            /**
             * Encodes the specified ActiveMQ message. Does not implicitly {@link protos.records.ActiveMQ.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.IActiveMQ} message ActiveMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQ.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.contentType);
                if (message.subscriptionId != null && Object.hasOwnProperty.call(message, "subscriptionId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subscriptionId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQ message, length delimited. Does not implicitly {@link protos.records.ActiveMQ.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.IActiveMQ} message ActiveMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQ.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQ message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ActiveMQ} ActiveMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQ.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ActiveMQ();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.destination = reader.string();
                        break;
                    case 2:
                        message.contentType = reader.string();
                        break;
                    case 3:
                        message.subscriptionId = reader.string();
                        break;
                    case 4:
                        message.timestamp = reader.int64();
                        break;
                    case 5:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQ message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ActiveMQ} ActiveMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQ.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQ message.
             * @function verify
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQ.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destination != null && message.hasOwnProperty("destination"))
                    if (!$util.isString(message.destination))
                        return "destination: string expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    if (!$util.isString(message.subscriptionId))
                        return "subscriptionId: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an ActiveMQ message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ActiveMQ} ActiveMQ
             */
            ActiveMQ.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ActiveMQ)
                    return object;
                var message = new $root.protos.records.ActiveMQ();
                if (object.destination != null)
                    message.destination = String(object.destination);
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.subscriptionId != null)
                    message.subscriptionId = String(object.subscriptionId);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQ message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.ActiveMQ} message ActiveMQ
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQ.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.destination = "";
                    object.contentType = "";
                    object.subscriptionId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = message.destination;
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    object.subscriptionId = message.subscriptionId;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this ActiveMQ to JSON.
             * @function toJSON
             * @memberof protos.records.ActiveMQ
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQ.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQ;
        })();

        records.AWSSQS = (function() {

            /**
             * Properties of a AWSSQS.
             * @memberof protos.records
             * @interface IAWSSQS
             * @property {string|null} [id] AWSSQS id
             * @property {number|Long|null} [timestamp] AWSSQS timestamp
             * @property {string|null} [recipientHandle] AWSSQS recipientHandle
             * @property {Object.<string,string>|null} [attributes] AWSSQS attributes
             * @property {Uint8Array|null} [value] AWSSQS value
             */

            /**
             * Constructs a new AWSSQS.
             * @memberof protos.records
             * @classdesc Represents a AWSSQS.
             * @implements IAWSSQS
             * @constructor
             * @param {protos.records.IAWSSQS=} [properties] Properties to set
             */
            function AWSSQS(properties) {
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQS id.
             * @member {string} id
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.id = "";

            /**
             * AWSSQS timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSSQS recipientHandle.
             * @member {string} recipientHandle
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.recipientHandle = "";

            /**
             * AWSSQS attributes.
             * @member {Object.<string,string>} attributes
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.attributes = $util.emptyObject;

            /**
             * AWSSQS value.
             * @member {Uint8Array} value
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new AWSSQS instance using the specified properties.
             * @function create
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.IAWSSQS=} [properties] Properties to set
             * @returns {protos.records.AWSSQS} AWSSQS instance
             */
            AWSSQS.create = function create(properties) {
                return new AWSSQS(properties);
            };

            /**
             * Encodes the specified AWSSQS message. Does not implicitly {@link protos.records.AWSSQS.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.IAWSSQS} message AWSSQS message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQS.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.recipientHandle != null && Object.hasOwnProperty.call(message, "recipientHandle"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipientHandle);
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified AWSSQS message, length delimited. Does not implicitly {@link protos.records.AWSSQS.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.IAWSSQS} message AWSSQS message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQS.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQS message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AWSSQS
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AWSSQS} AWSSQS
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQS.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AWSSQS(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.recipientHandle = reader.string();
                        break;
                    case 4:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 5:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQS message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AWSSQS
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AWSSQS} AWSSQS
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQS.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQS message.
             * @function verify
             * @memberof protos.records.AWSSQS
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQS.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.recipientHandle != null && message.hasOwnProperty("recipientHandle"))
                    if (!$util.isString(message.recipientHandle))
                        return "recipientHandle: string expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a AWSSQS message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AWSSQS
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AWSSQS} AWSSQS
             */
            AWSSQS.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AWSSQS)
                    return object;
                var message = new $root.protos.records.AWSSQS();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.recipientHandle != null)
                    message.recipientHandle = String(object.recipientHandle);
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".protos.records.AWSSQS.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a AWSSQS message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.AWSSQS} message AWSSQS
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQS.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.id = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.recipientHandle = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.recipientHandle != null && message.hasOwnProperty("recipientHandle"))
                    object.recipientHandle = message.recipientHandle;
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this AWSSQS to JSON.
             * @function toJSON
             * @memberof protos.records.AWSSQS
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQS.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQS;
        })();

        records.AzureEventHub = (function() {

            /**
             * Properties of an AzureEventHub.
             * @memberof protos.records
             * @interface IAzureEventHub
             * @property {string|null} [id] AzureEventHub id
             * @property {Object.<string,string>|null} [systemProperties] AzureEventHub systemProperties
             * @property {number|Long|null} [timestamp] AzureEventHub timestamp
             * @property {Uint8Array|null} [value] AzureEventHub value
             */

            /**
             * Constructs a new AzureEventHub.
             * @memberof protos.records
             * @classdesc Represents an AzureEventHub.
             * @implements IAzureEventHub
             * @constructor
             * @param {protos.records.IAzureEventHub=} [properties] Properties to set
             */
            function AzureEventHub(properties) {
                this.systemProperties = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHub id.
             * @member {string} id
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.id = "";

            /**
             * AzureEventHub systemProperties.
             * @member {Object.<string,string>} systemProperties
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.systemProperties = $util.emptyObject;

            /**
             * AzureEventHub timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureEventHub value.
             * @member {Uint8Array} value
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new AzureEventHub instance using the specified properties.
             * @function create
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.IAzureEventHub=} [properties] Properties to set
             * @returns {protos.records.AzureEventHub} AzureEventHub instance
             */
            AzureEventHub.create = function create(properties) {
                return new AzureEventHub(properties);
            };

            /**
             * Encodes the specified AzureEventHub message. Does not implicitly {@link protos.records.AzureEventHub.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.IAzureEventHub} message AzureEventHub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHub.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.systemProperties != null && Object.hasOwnProperty.call(message, "systemProperties"))
                    for (var keys = Object.keys(message.systemProperties), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.systemProperties[keys[i]]).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHub message, length delimited. Does not implicitly {@link protos.records.AzureEventHub.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.IAzureEventHub} message AzureEventHub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHub.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHub message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AzureEventHub} AzureEventHub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHub.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AzureEventHub(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        if (message.systemProperties === $util.emptyObject)
                            message.systemProperties = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.systemProperties[key] = value;
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    case 4:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHub message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AzureEventHub} AzureEventHub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHub.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHub message.
             * @function verify
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHub.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.systemProperties != null && message.hasOwnProperty("systemProperties")) {
                    if (!$util.isObject(message.systemProperties))
                        return "systemProperties: object expected";
                    var key = Object.keys(message.systemProperties);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.systemProperties[key[i]]))
                            return "systemProperties: string{k:string} expected";
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an AzureEventHub message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AzureEventHub} AzureEventHub
             */
            AzureEventHub.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AzureEventHub)
                    return object;
                var message = new $root.protos.records.AzureEventHub();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.systemProperties) {
                    if (typeof object.systemProperties !== "object")
                        throw TypeError(".protos.records.AzureEventHub.systemProperties: object expected");
                    message.systemProperties = {};
                    for (var keys = Object.keys(object.systemProperties), i = 0; i < keys.length; ++i)
                        message.systemProperties[keys[i]] = String(object.systemProperties[keys[i]]);
                }
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHub message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.AzureEventHub} message AzureEventHub
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHub.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.systemProperties = {};
                if (options.defaults) {
                    object.id = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                var keys2;
                if (message.systemProperties && (keys2 = Object.keys(message.systemProperties)).length) {
                    object.systemProperties = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.systemProperties[keys2[j]] = message.systemProperties[keys2[j]];
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this AzureEventHub to JSON.
             * @function toJSON
             * @memberof protos.records.AzureEventHub
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHub.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHub;
        })();

        records.AzureServiceBus = (function() {

            /**
             * Properties of an AzureServiceBus.
             * @memberof protos.records
             * @interface IAzureServiceBus
             * @property {string|null} [contentType] AzureServiceBus contentType
             * @property {string|null} [correlationId] AzureServiceBus correlationId
             * @property {Uint8Array|null} [value] AzureServiceBus value
             * @property {number|null} [deliveryCount] AzureServiceBus deliveryCount
             * @property {string|null} [sessionId] AzureServiceBus sessionId
             * @property {number|null} [groupSequence] AzureServiceBus groupSequence
             * @property {string|null} [id] AzureServiceBus id
             * @property {string|null} [label] AzureServiceBus label
             * @property {string|null} [replyTo] AzureServiceBus replyTo
             * @property {string|null} [replyToGroupId] AzureServiceBus replyToGroupId
             * @property {string|null} [to] AzureServiceBus to
             * @property {number|Long|null} [ttl] AzureServiceBus ttl
             * @property {string|null} [lockToken] AzureServiceBus lockToken
             * @property {protos.records.IAzureSystemProperties|null} [systemProperties] AzureServiceBus systemProperties
             * @property {Object.<string,string>|null} [userProperties] AzureServiceBus userProperties
             * @property {number|null} [format] AzureServiceBus format
             */

            /**
             * Constructs a new AzureServiceBus.
             * @memberof protos.records
             * @classdesc Represents an AzureServiceBus.
             * @implements IAzureServiceBus
             * @constructor
             * @param {protos.records.IAzureServiceBus=} [properties] Properties to set
             */
            function AzureServiceBus(properties) {
                this.userProperties = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBus contentType.
             * @member {string} contentType
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.contentType = "";

            /**
             * AzureServiceBus correlationId.
             * @member {string} correlationId
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.correlationId = "";

            /**
             * AzureServiceBus value.
             * @member {Uint8Array} value
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.value = $util.newBuffer([]);

            /**
             * AzureServiceBus deliveryCount.
             * @member {number} deliveryCount
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.deliveryCount = 0;

            /**
             * AzureServiceBus sessionId.
             * @member {string} sessionId
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.sessionId = "";

            /**
             * AzureServiceBus groupSequence.
             * @member {number} groupSequence
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.groupSequence = 0;

            /**
             * AzureServiceBus id.
             * @member {string} id
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.id = "";

            /**
             * AzureServiceBus label.
             * @member {string} label
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.label = "";

            /**
             * AzureServiceBus replyTo.
             * @member {string} replyTo
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.replyTo = "";

            /**
             * AzureServiceBus replyToGroupId.
             * @member {string} replyToGroupId
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.replyToGroupId = "";

            /**
             * AzureServiceBus to.
             * @member {string} to
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.to = "";

            /**
             * AzureServiceBus ttl.
             * @member {number|Long} ttl
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.ttl = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureServiceBus lockToken.
             * @member {string} lockToken
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.lockToken = "";

            /**
             * AzureServiceBus systemProperties.
             * @member {protos.records.IAzureSystemProperties|null|undefined} systemProperties
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.systemProperties = null;

            /**
             * AzureServiceBus userProperties.
             * @member {Object.<string,string>} userProperties
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.userProperties = $util.emptyObject;

            /**
             * AzureServiceBus format.
             * @member {number} format
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.format = 0;

            /**
             * Creates a new AzureServiceBus instance using the specified properties.
             * @function create
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.IAzureServiceBus=} [properties] Properties to set
             * @returns {protos.records.AzureServiceBus} AzureServiceBus instance
             */
            AzureServiceBus.create = function create(properties) {
                return new AzureServiceBus(properties);
            };

            /**
             * Encodes the specified AzureServiceBus message. Does not implicitly {@link protos.records.AzureServiceBus.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.IAzureServiceBus} message AzureServiceBus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentType);
                if (message.correlationId != null && Object.hasOwnProperty.call(message, "correlationId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.correlationId);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.deliveryCount != null && Object.hasOwnProperty.call(message, "deliveryCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.deliveryCount);
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sessionId);
                if (message.groupSequence != null && Object.hasOwnProperty.call(message, "groupSequence"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.groupSequence);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.id);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.label);
                if (message.replyTo != null && Object.hasOwnProperty.call(message, "replyTo"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.replyTo);
                if (message.replyToGroupId != null && Object.hasOwnProperty.call(message, "replyToGroupId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.replyToGroupId);
                if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.to);
                if (message.ttl != null && Object.hasOwnProperty.call(message, "ttl"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int64(message.ttl);
                if (message.lockToken != null && Object.hasOwnProperty.call(message, "lockToken"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.lockToken);
                if (message.systemProperties != null && Object.hasOwnProperty.call(message, "systemProperties"))
                    $root.protos.records.AzureSystemProperties.encode(message.systemProperties, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.userProperties != null && Object.hasOwnProperty.call(message, "userProperties"))
                    for (var keys = Object.keys(message.userProperties), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 15, wireType 2 =*/122).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.userProperties[keys[i]]).ldelim();
                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                    writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.format);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBus message, length delimited. Does not implicitly {@link protos.records.AzureServiceBus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.IAzureServiceBus} message AzureServiceBus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBus message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AzureServiceBus} AzureServiceBus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AzureServiceBus(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.contentType = reader.string();
                        break;
                    case 2:
                        message.correlationId = reader.string();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    case 4:
                        message.deliveryCount = reader.uint32();
                        break;
                    case 5:
                        message.sessionId = reader.string();
                        break;
                    case 6:
                        message.groupSequence = reader.uint32();
                        break;
                    case 7:
                        message.id = reader.string();
                        break;
                    case 8:
                        message.label = reader.string();
                        break;
                    case 9:
                        message.replyTo = reader.string();
                        break;
                    case 10:
                        message.replyToGroupId = reader.string();
                        break;
                    case 11:
                        message.to = reader.string();
                        break;
                    case 12:
                        message.ttl = reader.int64();
                        break;
                    case 13:
                        message.lockToken = reader.string();
                        break;
                    case 14:
                        message.systemProperties = $root.protos.records.AzureSystemProperties.decode(reader, reader.uint32());
                        break;
                    case 15:
                        if (message.userProperties === $util.emptyObject)
                            message.userProperties = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.userProperties[key] = value;
                        break;
                    case 16:
                        message.format = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AzureServiceBus} AzureServiceBus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBus message.
             * @function verify
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    if (!$util.isString(message.correlationId))
                        return "correlationId: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.deliveryCount != null && message.hasOwnProperty("deliveryCount"))
                    if (!$util.isInteger(message.deliveryCount))
                        return "deliveryCount: integer expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.groupSequence != null && message.hasOwnProperty("groupSequence"))
                    if (!$util.isInteger(message.groupSequence))
                        return "groupSequence: integer expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    if (!$util.isString(message.replyTo))
                        return "replyTo: string expected";
                if (message.replyToGroupId != null && message.hasOwnProperty("replyToGroupId"))
                    if (!$util.isString(message.replyToGroupId))
                        return "replyToGroupId: string expected";
                if (message.to != null && message.hasOwnProperty("to"))
                    if (!$util.isString(message.to))
                        return "to: string expected";
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    if (!$util.isInteger(message.ttl) && !(message.ttl && $util.isInteger(message.ttl.low) && $util.isInteger(message.ttl.high)))
                        return "ttl: integer|Long expected";
                if (message.lockToken != null && message.hasOwnProperty("lockToken"))
                    if (!$util.isString(message.lockToken))
                        return "lockToken: string expected";
                if (message.systemProperties != null && message.hasOwnProperty("systemProperties")) {
                    var error = $root.protos.records.AzureSystemProperties.verify(message.systemProperties);
                    if (error)
                        return "systemProperties." + error;
                }
                if (message.userProperties != null && message.hasOwnProperty("userProperties")) {
                    if (!$util.isObject(message.userProperties))
                        return "userProperties: object expected";
                    var key = Object.keys(message.userProperties);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.userProperties[key[i]]))
                            return "userProperties: string{k:string} expected";
                }
                if (message.format != null && message.hasOwnProperty("format"))
                    if (!$util.isInteger(message.format))
                        return "format: integer expected";
                return null;
            };

            /**
             * Creates an AzureServiceBus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AzureServiceBus} AzureServiceBus
             */
            AzureServiceBus.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AzureServiceBus)
                    return object;
                var message = new $root.protos.records.AzureServiceBus();
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.correlationId != null)
                    message.correlationId = String(object.correlationId);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.deliveryCount != null)
                    message.deliveryCount = object.deliveryCount >>> 0;
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.groupSequence != null)
                    message.groupSequence = object.groupSequence >>> 0;
                if (object.id != null)
                    message.id = String(object.id);
                if (object.label != null)
                    message.label = String(object.label);
                if (object.replyTo != null)
                    message.replyTo = String(object.replyTo);
                if (object.replyToGroupId != null)
                    message.replyToGroupId = String(object.replyToGroupId);
                if (object.to != null)
                    message.to = String(object.to);
                if (object.ttl != null)
                    if ($util.Long)
                        (message.ttl = $util.Long.fromValue(object.ttl)).unsigned = false;
                    else if (typeof object.ttl === "string")
                        message.ttl = parseInt(object.ttl, 10);
                    else if (typeof object.ttl === "number")
                        message.ttl = object.ttl;
                    else if (typeof object.ttl === "object")
                        message.ttl = new $util.LongBits(object.ttl.low >>> 0, object.ttl.high >>> 0).toNumber();
                if (object.lockToken != null)
                    message.lockToken = String(object.lockToken);
                if (object.systemProperties != null) {
                    if (typeof object.systemProperties !== "object")
                        throw TypeError(".protos.records.AzureServiceBus.systemProperties: object expected");
                    message.systemProperties = $root.protos.records.AzureSystemProperties.fromObject(object.systemProperties);
                }
                if (object.userProperties) {
                    if (typeof object.userProperties !== "object")
                        throw TypeError(".protos.records.AzureServiceBus.userProperties: object expected");
                    message.userProperties = {};
                    for (var keys = Object.keys(object.userProperties), i = 0; i < keys.length; ++i)
                        message.userProperties[keys[i]] = String(object.userProperties[keys[i]]);
                }
                if (object.format != null)
                    message.format = object.format >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.AzureServiceBus} message AzureServiceBus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.userProperties = {};
                if (options.defaults) {
                    object.contentType = "";
                    object.correlationId = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.deliveryCount = 0;
                    object.sessionId = "";
                    object.groupSequence = 0;
                    object.id = "";
                    object.label = "";
                    object.replyTo = "";
                    object.replyToGroupId = "";
                    object.to = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ttl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ttl = options.longs === String ? "0" : 0;
                    object.lockToken = "";
                    object.systemProperties = null;
                    object.format = 0;
                }
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    object.correlationId = message.correlationId;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.deliveryCount != null && message.hasOwnProperty("deliveryCount"))
                    object.deliveryCount = message.deliveryCount;
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.groupSequence != null && message.hasOwnProperty("groupSequence"))
                    object.groupSequence = message.groupSequence;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    object.replyTo = message.replyTo;
                if (message.replyToGroupId != null && message.hasOwnProperty("replyToGroupId"))
                    object.replyToGroupId = message.replyToGroupId;
                if (message.to != null && message.hasOwnProperty("to"))
                    object.to = message.to;
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    if (typeof message.ttl === "number")
                        object.ttl = options.longs === String ? String(message.ttl) : message.ttl;
                    else
                        object.ttl = options.longs === String ? $util.Long.prototype.toString.call(message.ttl) : options.longs === Number ? new $util.LongBits(message.ttl.low >>> 0, message.ttl.high >>> 0).toNumber() : message.ttl;
                if (message.lockToken != null && message.hasOwnProperty("lockToken"))
                    object.lockToken = message.lockToken;
                if (message.systemProperties != null && message.hasOwnProperty("systemProperties"))
                    object.systemProperties = $root.protos.records.AzureSystemProperties.toObject(message.systemProperties, options);
                var keys2;
                if (message.userProperties && (keys2 = Object.keys(message.userProperties)).length) {
                    object.userProperties = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.userProperties[keys2[j]] = message.userProperties[keys2[j]];
                }
                if (message.format != null && message.hasOwnProperty("format"))
                    object.format = message.format;
                return object;
            };

            /**
             * Converts this AzureServiceBus to JSON.
             * @function toJSON
             * @memberof protos.records.AzureServiceBus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBus;
        })();

        records.AzureSystemProperties = (function() {

            /**
             * Properties of an AzureSystemProperties.
             * @memberof protos.records
             * @interface IAzureSystemProperties
             * @property {number|Long|null} [lockedUntil] AzureSystemProperties lockedUntil
             * @property {number|Long|null} [sequenceNumber] AzureSystemProperties sequenceNumber
             * @property {number|null} [partitionId] AzureSystemProperties partitionId
             * @property {string|null} [partitionKey] AzureSystemProperties partitionKey
             * @property {number|Long|null} [enqueuedTime] AzureSystemProperties enqueuedTime
             * @property {string|null} [deadLetterSource] AzureSystemProperties deadLetterSource
             * @property {number|Long|null} [scheduledEnqueueTime] AzureSystemProperties scheduledEnqueueTime
             * @property {number|Long|null} [enqueuedSequenceNumber] AzureSystemProperties enqueuedSequenceNumber
             * @property {string|null} [viaPartitionKey] AzureSystemProperties viaPartitionKey
             * @property {Object.<string,string>|null} [annotations] AzureSystemProperties annotations
             */

            /**
             * Constructs a new AzureSystemProperties.
             * @memberof protos.records
             * @classdesc Represents an AzureSystemProperties.
             * @implements IAzureSystemProperties
             * @constructor
             * @param {protos.records.IAzureSystemProperties=} [properties] Properties to set
             */
            function AzureSystemProperties(properties) {
                this.annotations = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureSystemProperties lockedUntil.
             * @member {number|Long} lockedUntil
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.lockedUntil = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties sequenceNumber.
             * @member {number|Long} sequenceNumber
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties partitionId.
             * @member {number} partitionId
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.partitionId = 0;

            /**
             * AzureSystemProperties partitionKey.
             * @member {string} partitionKey
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.partitionKey = "";

            /**
             * AzureSystemProperties enqueuedTime.
             * @member {number|Long} enqueuedTime
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.enqueuedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties deadLetterSource.
             * @member {string} deadLetterSource
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.deadLetterSource = "";

            /**
             * AzureSystemProperties scheduledEnqueueTime.
             * @member {number|Long} scheduledEnqueueTime
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.scheduledEnqueueTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties enqueuedSequenceNumber.
             * @member {number|Long} enqueuedSequenceNumber
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.enqueuedSequenceNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties viaPartitionKey.
             * @member {string} viaPartitionKey
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.viaPartitionKey = "";

            /**
             * AzureSystemProperties annotations.
             * @member {Object.<string,string>} annotations
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.annotations = $util.emptyObject;

            /**
             * Creates a new AzureSystemProperties instance using the specified properties.
             * @function create
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.IAzureSystemProperties=} [properties] Properties to set
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties instance
             */
            AzureSystemProperties.create = function create(properties) {
                return new AzureSystemProperties(properties);
            };

            /**
             * Encodes the specified AzureSystemProperties message. Does not implicitly {@link protos.records.AzureSystemProperties.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.IAzureSystemProperties} message AzureSystemProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureSystemProperties.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lockedUntil != null && Object.hasOwnProperty.call(message, "lockedUntil"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lockedUntil);
                if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequenceNumber);
                if (message.partitionId != null && Object.hasOwnProperty.call(message, "partitionId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.partitionId);
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.partitionKey);
                if (message.enqueuedTime != null && Object.hasOwnProperty.call(message, "enqueuedTime"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.enqueuedTime);
                if (message.deadLetterSource != null && Object.hasOwnProperty.call(message, "deadLetterSource"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.deadLetterSource);
                if (message.scheduledEnqueueTime != null && Object.hasOwnProperty.call(message, "scheduledEnqueueTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.scheduledEnqueueTime);
                if (message.enqueuedSequenceNumber != null && Object.hasOwnProperty.call(message, "enqueuedSequenceNumber"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.enqueuedSequenceNumber);
                if (message.viaPartitionKey != null && Object.hasOwnProperty.call(message, "viaPartitionKey"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.viaPartitionKey);
                if (message.annotations != null && Object.hasOwnProperty.call(message, "annotations"))
                    for (var keys = Object.keys(message.annotations), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.annotations[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AzureSystemProperties message, length delimited. Does not implicitly {@link protos.records.AzureSystemProperties.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.IAzureSystemProperties} message AzureSystemProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureSystemProperties.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureSystemProperties message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureSystemProperties.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AzureSystemProperties(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lockedUntil = reader.int64();
                        break;
                    case 2:
                        message.sequenceNumber = reader.int64();
                        break;
                    case 3:
                        message.partitionId = reader.int32();
                        break;
                    case 4:
                        message.partitionKey = reader.string();
                        break;
                    case 5:
                        message.enqueuedTime = reader.int64();
                        break;
                    case 6:
                        message.deadLetterSource = reader.string();
                        break;
                    case 7:
                        message.scheduledEnqueueTime = reader.int64();
                        break;
                    case 8:
                        message.enqueuedSequenceNumber = reader.int64();
                        break;
                    case 9:
                        message.viaPartitionKey = reader.string();
                        break;
                    case 10:
                        if (message.annotations === $util.emptyObject)
                            message.annotations = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.annotations[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureSystemProperties message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureSystemProperties.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureSystemProperties message.
             * @function verify
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureSystemProperties.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lockedUntil != null && message.hasOwnProperty("lockedUntil"))
                    if (!$util.isInteger(message.lockedUntil) && !(message.lockedUntil && $util.isInteger(message.lockedUntil.low) && $util.isInteger(message.lockedUntil.high)))
                        return "lockedUntil: integer|Long expected";
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isInteger(message.sequenceNumber) && !(message.sequenceNumber && $util.isInteger(message.sequenceNumber.low) && $util.isInteger(message.sequenceNumber.high)))
                        return "sequenceNumber: integer|Long expected";
                if (message.partitionId != null && message.hasOwnProperty("partitionId"))
                    if (!$util.isInteger(message.partitionId))
                        return "partitionId: integer expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                if (message.enqueuedTime != null && message.hasOwnProperty("enqueuedTime"))
                    if (!$util.isInteger(message.enqueuedTime) && !(message.enqueuedTime && $util.isInteger(message.enqueuedTime.low) && $util.isInteger(message.enqueuedTime.high)))
                        return "enqueuedTime: integer|Long expected";
                if (message.deadLetterSource != null && message.hasOwnProperty("deadLetterSource"))
                    if (!$util.isString(message.deadLetterSource))
                        return "deadLetterSource: string expected";
                if (message.scheduledEnqueueTime != null && message.hasOwnProperty("scheduledEnqueueTime"))
                    if (!$util.isInteger(message.scheduledEnqueueTime) && !(message.scheduledEnqueueTime && $util.isInteger(message.scheduledEnqueueTime.low) && $util.isInteger(message.scheduledEnqueueTime.high)))
                        return "scheduledEnqueueTime: integer|Long expected";
                if (message.enqueuedSequenceNumber != null && message.hasOwnProperty("enqueuedSequenceNumber"))
                    if (!$util.isInteger(message.enqueuedSequenceNumber) && !(message.enqueuedSequenceNumber && $util.isInteger(message.enqueuedSequenceNumber.low) && $util.isInteger(message.enqueuedSequenceNumber.high)))
                        return "enqueuedSequenceNumber: integer|Long expected";
                if (message.viaPartitionKey != null && message.hasOwnProperty("viaPartitionKey"))
                    if (!$util.isString(message.viaPartitionKey))
                        return "viaPartitionKey: string expected";
                if (message.annotations != null && message.hasOwnProperty("annotations")) {
                    if (!$util.isObject(message.annotations))
                        return "annotations: object expected";
                    var key = Object.keys(message.annotations);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.annotations[key[i]]))
                            return "annotations: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an AzureSystemProperties message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties
             */
            AzureSystemProperties.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AzureSystemProperties)
                    return object;
                var message = new $root.protos.records.AzureSystemProperties();
                if (object.lockedUntil != null)
                    if ($util.Long)
                        (message.lockedUntil = $util.Long.fromValue(object.lockedUntil)).unsigned = false;
                    else if (typeof object.lockedUntil === "string")
                        message.lockedUntil = parseInt(object.lockedUntil, 10);
                    else if (typeof object.lockedUntil === "number")
                        message.lockedUntil = object.lockedUntil;
                    else if (typeof object.lockedUntil === "object")
                        message.lockedUntil = new $util.LongBits(object.lockedUntil.low >>> 0, object.lockedUntil.high >>> 0).toNumber();
                if (object.sequenceNumber != null)
                    if ($util.Long)
                        (message.sequenceNumber = $util.Long.fromValue(object.sequenceNumber)).unsigned = false;
                    else if (typeof object.sequenceNumber === "string")
                        message.sequenceNumber = parseInt(object.sequenceNumber, 10);
                    else if (typeof object.sequenceNumber === "number")
                        message.sequenceNumber = object.sequenceNumber;
                    else if (typeof object.sequenceNumber === "object")
                        message.sequenceNumber = new $util.LongBits(object.sequenceNumber.low >>> 0, object.sequenceNumber.high >>> 0).toNumber();
                if (object.partitionId != null)
                    message.partitionId = object.partitionId | 0;
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                if (object.enqueuedTime != null)
                    if ($util.Long)
                        (message.enqueuedTime = $util.Long.fromValue(object.enqueuedTime)).unsigned = false;
                    else if (typeof object.enqueuedTime === "string")
                        message.enqueuedTime = parseInt(object.enqueuedTime, 10);
                    else if (typeof object.enqueuedTime === "number")
                        message.enqueuedTime = object.enqueuedTime;
                    else if (typeof object.enqueuedTime === "object")
                        message.enqueuedTime = new $util.LongBits(object.enqueuedTime.low >>> 0, object.enqueuedTime.high >>> 0).toNumber();
                if (object.deadLetterSource != null)
                    message.deadLetterSource = String(object.deadLetterSource);
                if (object.scheduledEnqueueTime != null)
                    if ($util.Long)
                        (message.scheduledEnqueueTime = $util.Long.fromValue(object.scheduledEnqueueTime)).unsigned = false;
                    else if (typeof object.scheduledEnqueueTime === "string")
                        message.scheduledEnqueueTime = parseInt(object.scheduledEnqueueTime, 10);
                    else if (typeof object.scheduledEnqueueTime === "number")
                        message.scheduledEnqueueTime = object.scheduledEnqueueTime;
                    else if (typeof object.scheduledEnqueueTime === "object")
                        message.scheduledEnqueueTime = new $util.LongBits(object.scheduledEnqueueTime.low >>> 0, object.scheduledEnqueueTime.high >>> 0).toNumber();
                if (object.enqueuedSequenceNumber != null)
                    if ($util.Long)
                        (message.enqueuedSequenceNumber = $util.Long.fromValue(object.enqueuedSequenceNumber)).unsigned = false;
                    else if (typeof object.enqueuedSequenceNumber === "string")
                        message.enqueuedSequenceNumber = parseInt(object.enqueuedSequenceNumber, 10);
                    else if (typeof object.enqueuedSequenceNumber === "number")
                        message.enqueuedSequenceNumber = object.enqueuedSequenceNumber;
                    else if (typeof object.enqueuedSequenceNumber === "object")
                        message.enqueuedSequenceNumber = new $util.LongBits(object.enqueuedSequenceNumber.low >>> 0, object.enqueuedSequenceNumber.high >>> 0).toNumber();
                if (object.viaPartitionKey != null)
                    message.viaPartitionKey = String(object.viaPartitionKey);
                if (object.annotations) {
                    if (typeof object.annotations !== "object")
                        throw TypeError(".protos.records.AzureSystemProperties.annotations: object expected");
                    message.annotations = {};
                    for (var keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                        message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from an AzureSystemProperties message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.AzureSystemProperties} message AzureSystemProperties
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureSystemProperties.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.annotations = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lockedUntil = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lockedUntil = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequenceNumber = options.longs === String ? "0" : 0;
                    object.partitionId = 0;
                    object.partitionKey = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.enqueuedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.enqueuedTime = options.longs === String ? "0" : 0;
                    object.deadLetterSource = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.scheduledEnqueueTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.scheduledEnqueueTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.enqueuedSequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.enqueuedSequenceNumber = options.longs === String ? "0" : 0;
                    object.viaPartitionKey = "";
                }
                if (message.lockedUntil != null && message.hasOwnProperty("lockedUntil"))
                    if (typeof message.lockedUntil === "number")
                        object.lockedUntil = options.longs === String ? String(message.lockedUntil) : message.lockedUntil;
                    else
                        object.lockedUntil = options.longs === String ? $util.Long.prototype.toString.call(message.lockedUntil) : options.longs === Number ? new $util.LongBits(message.lockedUntil.low >>> 0, message.lockedUntil.high >>> 0).toNumber() : message.lockedUntil;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (typeof message.sequenceNumber === "number")
                        object.sequenceNumber = options.longs === String ? String(message.sequenceNumber) : message.sequenceNumber;
                    else
                        object.sequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.sequenceNumber) : options.longs === Number ? new $util.LongBits(message.sequenceNumber.low >>> 0, message.sequenceNumber.high >>> 0).toNumber() : message.sequenceNumber;
                if (message.partitionId != null && message.hasOwnProperty("partitionId"))
                    object.partitionId = message.partitionId;
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                if (message.enqueuedTime != null && message.hasOwnProperty("enqueuedTime"))
                    if (typeof message.enqueuedTime === "number")
                        object.enqueuedTime = options.longs === String ? String(message.enqueuedTime) : message.enqueuedTime;
                    else
                        object.enqueuedTime = options.longs === String ? $util.Long.prototype.toString.call(message.enqueuedTime) : options.longs === Number ? new $util.LongBits(message.enqueuedTime.low >>> 0, message.enqueuedTime.high >>> 0).toNumber() : message.enqueuedTime;
                if (message.deadLetterSource != null && message.hasOwnProperty("deadLetterSource"))
                    object.deadLetterSource = message.deadLetterSource;
                if (message.scheduledEnqueueTime != null && message.hasOwnProperty("scheduledEnqueueTime"))
                    if (typeof message.scheduledEnqueueTime === "number")
                        object.scheduledEnqueueTime = options.longs === String ? String(message.scheduledEnqueueTime) : message.scheduledEnqueueTime;
                    else
                        object.scheduledEnqueueTime = options.longs === String ? $util.Long.prototype.toString.call(message.scheduledEnqueueTime) : options.longs === Number ? new $util.LongBits(message.scheduledEnqueueTime.low >>> 0, message.scheduledEnqueueTime.high >>> 0).toNumber() : message.scheduledEnqueueTime;
                if (message.enqueuedSequenceNumber != null && message.hasOwnProperty("enqueuedSequenceNumber"))
                    if (typeof message.enqueuedSequenceNumber === "number")
                        object.enqueuedSequenceNumber = options.longs === String ? String(message.enqueuedSequenceNumber) : message.enqueuedSequenceNumber;
                    else
                        object.enqueuedSequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.enqueuedSequenceNumber) : options.longs === Number ? new $util.LongBits(message.enqueuedSequenceNumber.low >>> 0, message.enqueuedSequenceNumber.high >>> 0).toNumber() : message.enqueuedSequenceNumber;
                if (message.viaPartitionKey != null && message.hasOwnProperty("viaPartitionKey"))
                    object.viaPartitionKey = message.viaPartitionKey;
                var keys2;
                if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                    object.annotations = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.annotations[keys2[j]] = message.annotations[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this AzureSystemProperties to JSON.
             * @function toJSON
             * @memberof protos.records.AzureSystemProperties
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureSystemProperties.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureSystemProperties;
        })();

        records.GCPPubSub = (function() {

            /**
             * Properties of a GCPPubSub.
             * @memberof protos.records
             * @interface IGCPPubSub
             * @property {string|null} [id] GCPPubSub id
             * @property {Uint8Array|null} [value] GCPPubSub value
             * @property {Object.<string,string>|null} [attributes] GCPPubSub attributes
             * @property {number|Long|null} [publishTime] GCPPubSub publishTime
             * @property {number|null} [deliveryAttempt] GCPPubSub deliveryAttempt
             * @property {string|null} [orderingKey] GCPPubSub orderingKey
             */

            /**
             * Constructs a new GCPPubSub.
             * @memberof protos.records
             * @classdesc Represents a GCPPubSub.
             * @implements IGCPPubSub
             * @constructor
             * @param {protos.records.IGCPPubSub=} [properties] Properties to set
             */
            function GCPPubSub(properties) {
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSub id.
             * @member {string} id
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.id = "";

            /**
             * GCPPubSub value.
             * @member {Uint8Array} value
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.value = $util.newBuffer([]);

            /**
             * GCPPubSub attributes.
             * @member {Object.<string,string>} attributes
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.attributes = $util.emptyObject;

            /**
             * GCPPubSub publishTime.
             * @member {number|Long} publishTime
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.publishTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GCPPubSub deliveryAttempt.
             * @member {number} deliveryAttempt
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.deliveryAttempt = 0;

            /**
             * GCPPubSub orderingKey.
             * @member {string} orderingKey
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.orderingKey = "";

            /**
             * Creates a new GCPPubSub instance using the specified properties.
             * @function create
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.IGCPPubSub=} [properties] Properties to set
             * @returns {protos.records.GCPPubSub} GCPPubSub instance
             */
            GCPPubSub.create = function create(properties) {
                return new GCPPubSub(properties);
            };

            /**
             * Encodes the specified GCPPubSub message. Does not implicitly {@link protos.records.GCPPubSub.verify|verify} messages.
             * @function encode
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.IGCPPubSub} message GCPPubSub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSub.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.publishTime != null && Object.hasOwnProperty.call(message, "publishTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.publishTime);
                if (message.deliveryAttempt != null && Object.hasOwnProperty.call(message, "deliveryAttempt"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.deliveryAttempt);
                if (message.orderingKey != null && Object.hasOwnProperty.call(message, "orderingKey"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.orderingKey);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSub message, length delimited. Does not implicitly {@link protos.records.GCPPubSub.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.IGCPPubSub} message GCPPubSub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSub.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSub message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.GCPPubSub} GCPPubSub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSub.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.GCPPubSub(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 4:
                        message.publishTime = reader.int64();
                        break;
                    case 5:
                        message.deliveryAttempt = reader.int32();
                        break;
                    case 6:
                        message.orderingKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSub message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.GCPPubSub} GCPPubSub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSub.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSub message.
             * @function verify
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSub.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    if (!$util.isInteger(message.publishTime) && !(message.publishTime && $util.isInteger(message.publishTime.low) && $util.isInteger(message.publishTime.high)))
                        return "publishTime: integer|Long expected";
                if (message.deliveryAttempt != null && message.hasOwnProperty("deliveryAttempt"))
                    if (!$util.isInteger(message.deliveryAttempt))
                        return "deliveryAttempt: integer expected";
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    if (!$util.isString(message.orderingKey))
                        return "orderingKey: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSub message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.GCPPubSub} GCPPubSub
             */
            GCPPubSub.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.GCPPubSub)
                    return object;
                var message = new $root.protos.records.GCPPubSub();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".protos.records.GCPPubSub.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.publishTime != null)
                    if ($util.Long)
                        (message.publishTime = $util.Long.fromValue(object.publishTime)).unsigned = false;
                    else if (typeof object.publishTime === "string")
                        message.publishTime = parseInt(object.publishTime, 10);
                    else if (typeof object.publishTime === "number")
                        message.publishTime = object.publishTime;
                    else if (typeof object.publishTime === "object")
                        message.publishTime = new $util.LongBits(object.publishTime.low >>> 0, object.publishTime.high >>> 0).toNumber();
                if (object.deliveryAttempt != null)
                    message.deliveryAttempt = object.deliveryAttempt | 0;
                if (object.orderingKey != null)
                    message.orderingKey = String(object.orderingKey);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSub message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.GCPPubSub} message GCPPubSub
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSub.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.id = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.publishTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.publishTime = options.longs === String ? "0" : 0;
                    object.deliveryAttempt = 0;
                    object.orderingKey = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    if (typeof message.publishTime === "number")
                        object.publishTime = options.longs === String ? String(message.publishTime) : message.publishTime;
                    else
                        object.publishTime = options.longs === String ? $util.Long.prototype.toString.call(message.publishTime) : options.longs === Number ? new $util.LongBits(message.publishTime.low >>> 0, message.publishTime.high >>> 0).toNumber() : message.publishTime;
                if (message.deliveryAttempt != null && message.hasOwnProperty("deliveryAttempt"))
                    object.deliveryAttempt = message.deliveryAttempt;
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    object.orderingKey = message.orderingKey;
                return object;
            };

            /**
             * Converts this GCPPubSub to JSON.
             * @function toJSON
             * @memberof protos.records.GCPPubSub
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSub.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSub;
        })();

        records.KubeMQ = (function() {

            /**
             * Properties of a KubeMQ.
             * @memberof protos.records
             * @interface IKubeMQ
             * @property {string|null} [id] KubeMQ id
             * @property {string|null} [clientId] KubeMQ clientId
             * @property {string|null} [channel] KubeMQ channel
             * @property {Uint8Array|null} [value] KubeMQ value
             * @property {number|Long|null} [timestamp] KubeMQ timestamp
             * @property {number|Long|null} [sequence] KubeMQ sequence
             */

            /**
             * Constructs a new KubeMQ.
             * @memberof protos.records
             * @classdesc Represents a KubeMQ.
             * @implements IKubeMQ
             * @constructor
             * @param {protos.records.IKubeMQ=} [properties] Properties to set
             */
            function KubeMQ(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQ id.
             * @member {string} id
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.id = "";

            /**
             * KubeMQ clientId.
             * @member {string} clientId
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.clientId = "";

            /**
             * KubeMQ channel.
             * @member {string} channel
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.channel = "";

            /**
             * KubeMQ value.
             * @member {Uint8Array} value
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.value = $util.newBuffer([]);

            /**
             * KubeMQ timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KubeMQ sequence.
             * @member {number|Long} sequence
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new KubeMQ instance using the specified properties.
             * @function create
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.IKubeMQ=} [properties] Properties to set
             * @returns {protos.records.KubeMQ} KubeMQ instance
             */
            KubeMQ.create = function create(properties) {
                return new KubeMQ(properties);
            };

            /**
             * Encodes the specified KubeMQ message. Does not implicitly {@link protos.records.KubeMQ.verify|verify} messages.
             * @function encode
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.IKubeMQ} message KubeMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQ.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientId);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.channel);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
                if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.sequence);
                return writer;
            };

            /**
             * Encodes the specified KubeMQ message, length delimited. Does not implicitly {@link protos.records.KubeMQ.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.IKubeMQ} message KubeMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQ.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQ message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.KubeMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.KubeMQ} KubeMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQ.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.KubeMQ();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.clientId = reader.string();
                        break;
                    case 3:
                        message.channel = reader.string();
                        break;
                    case 4:
                        message.value = reader.bytes();
                        break;
                    case 5:
                        message.timestamp = reader.int64();
                        break;
                    case 6:
                        message.sequence = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQ message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.KubeMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.KubeMQ} KubeMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQ.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQ message.
             * @function verify
             * @memberof protos.records.KubeMQ
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQ.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                return null;
            };

            /**
             * Creates a KubeMQ message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.KubeMQ
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.KubeMQ} KubeMQ
             */
            KubeMQ.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.KubeMQ)
                    return object;
                var message = new $root.protos.records.KubeMQ();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a KubeMQ message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.KubeMQ} message KubeMQ
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQ.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.clientId = "";
                    object.channel = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                return object;
            };

            /**
             * Converts this KubeMQ to JSON.
             * @function toJSON
             * @memberof protos.records.KubeMQ
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQ.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQ;
        })();

        records.Mongo = (function() {

            /**
             * Properties of a Mongo.
             * @memberof protos.records
             * @interface IMongo
             * @property {Uint8Array|null} [value] Mongo value
             * @property {number|Long|null} [timestamp] Mongo timestamp
             */

            /**
             * Constructs a new Mongo.
             * @memberof protos.records
             * @classdesc Represents a Mongo.
             * @implements IMongo
             * @constructor
             * @param {protos.records.IMongo=} [properties] Properties to set
             */
            function Mongo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Mongo value.
             * @member {Uint8Array} value
             * @memberof protos.records.Mongo
             * @instance
             */
            Mongo.prototype.value = $util.newBuffer([]);

            /**
             * Mongo timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Mongo
             * @instance
             */
            Mongo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Mongo instance using the specified properties.
             * @function create
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.IMongo=} [properties] Properties to set
             * @returns {protos.records.Mongo} Mongo instance
             */
            Mongo.create = function create(properties) {
                return new Mongo(properties);
            };

            /**
             * Encodes the specified Mongo message. Does not implicitly {@link protos.records.Mongo.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.IMongo} message Mongo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mongo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified Mongo message, length delimited. Does not implicitly {@link protos.records.Mongo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.IMongo} message Mongo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mongo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Mongo message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Mongo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Mongo} Mongo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mongo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Mongo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Mongo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Mongo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Mongo} Mongo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mongo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Mongo message.
             * @function verify
             * @memberof protos.records.Mongo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Mongo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a Mongo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Mongo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Mongo} Mongo
             */
            Mongo.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Mongo)
                    return object;
                var message = new $root.protos.records.Mongo();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Mongo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.Mongo} message Mongo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Mongo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this Mongo to JSON.
             * @function toJSON
             * @memberof protos.records.Mongo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Mongo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Mongo;
        })();

        records.MQTT = (function() {

            /**
             * Properties of a MQTT.
             * @memberof protos.records
             * @interface IMQTT
             * @property {number|null} [id] MQTT id
             * @property {string|null} [topic] MQTT topic
             * @property {Uint8Array|null} [value] MQTT value
             * @property {boolean|null} [duplicate] MQTT duplicate
             * @property {boolean|null} [retained] MQTT retained
             * @property {number|null} [qos] MQTT qos
             * @property {number|Long|null} [timestamp] MQTT timestamp
             */

            /**
             * Constructs a new MQTT.
             * @memberof protos.records
             * @classdesc Represents a MQTT.
             * @implements IMQTT
             * @constructor
             * @param {protos.records.IMQTT=} [properties] Properties to set
             */
            function MQTT(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTT id.
             * @member {number} id
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.id = 0;

            /**
             * MQTT topic.
             * @member {string} topic
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.topic = "";

            /**
             * MQTT value.
             * @member {Uint8Array} value
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.value = $util.newBuffer([]);

            /**
             * MQTT duplicate.
             * @member {boolean} duplicate
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.duplicate = false;

            /**
             * MQTT retained.
             * @member {boolean} retained
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.retained = false;

            /**
             * MQTT qos.
             * @member {number} qos
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.qos = 0;

            /**
             * MQTT timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new MQTT instance using the specified properties.
             * @function create
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.IMQTT=} [properties] Properties to set
             * @returns {protos.records.MQTT} MQTT instance
             */
            MQTT.create = function create(properties) {
                return new MQTT(properties);
            };

            /**
             * Encodes the specified MQTT message. Does not implicitly {@link protos.records.MQTT.verify|verify} messages.
             * @function encode
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.IMQTT} message MQTT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTT.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.duplicate != null && Object.hasOwnProperty.call(message, "duplicate"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.duplicate);
                if (message.retained != null && Object.hasOwnProperty.call(message, "retained"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.retained);
                if (message.qos != null && Object.hasOwnProperty.call(message, "qos"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.qos);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified MQTT message, length delimited. Does not implicitly {@link protos.records.MQTT.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.IMQTT} message MQTT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTT.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTT message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.MQTT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.MQTT} MQTT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTT.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.MQTT();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    case 4:
                        message.duplicate = reader.bool();
                        break;
                    case 5:
                        message.retained = reader.bool();
                        break;
                    case 6:
                        message.qos = reader.uint32();
                        break;
                    case 7:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTT message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.MQTT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.MQTT} MQTT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTT.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTT message.
             * @function verify
             * @memberof protos.records.MQTT
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTT.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.duplicate != null && message.hasOwnProperty("duplicate"))
                    if (typeof message.duplicate !== "boolean")
                        return "duplicate: boolean expected";
                if (message.retained != null && message.hasOwnProperty("retained"))
                    if (typeof message.retained !== "boolean")
                        return "retained: boolean expected";
                if (message.qos != null && message.hasOwnProperty("qos"))
                    if (!$util.isInteger(message.qos))
                        return "qos: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a MQTT message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.MQTT
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.MQTT} MQTT
             */
            MQTT.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.MQTT)
                    return object;
                var message = new $root.protos.records.MQTT();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.duplicate != null)
                    message.duplicate = Boolean(object.duplicate);
                if (object.retained != null)
                    message.retained = Boolean(object.retained);
                if (object.qos != null)
                    message.qos = object.qos >>> 0;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a MQTT message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.MQTT} message MQTT
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTT.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.topic = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.duplicate = false;
                    object.retained = false;
                    object.qos = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.duplicate != null && message.hasOwnProperty("duplicate"))
                    object.duplicate = message.duplicate;
                if (message.retained != null && message.hasOwnProperty("retained"))
                    object.retained = message.retained;
                if (message.qos != null && message.hasOwnProperty("qos"))
                    object.qos = message.qos;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this MQTT to JSON.
             * @function toJSON
             * @memberof protos.records.MQTT
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTT.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTT;
        })();

        records.Nats = (function() {

            /**
             * Properties of a Nats.
             * @memberof protos.records
             * @interface INats
             * @property {string|null} [subject] Nats subject
             * @property {Uint8Array|null} [value] Nats value
             */

            /**
             * Constructs a new Nats.
             * @memberof protos.records
             * @classdesc Represents a Nats.
             * @implements INats
             * @constructor
             * @param {protos.records.INats=} [properties] Properties to set
             */
            function Nats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Nats subject.
             * @member {string} subject
             * @memberof protos.records.Nats
             * @instance
             */
            Nats.prototype.subject = "";

            /**
             * Nats value.
             * @member {Uint8Array} value
             * @memberof protos.records.Nats
             * @instance
             */
            Nats.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Nats instance using the specified properties.
             * @function create
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.INats=} [properties] Properties to set
             * @returns {protos.records.Nats} Nats instance
             */
            Nats.create = function create(properties) {
                return new Nats(properties);
            };

            /**
             * Encodes the specified Nats message. Does not implicitly {@link protos.records.Nats.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.INats} message Nats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Nats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Nats message, length delimited. Does not implicitly {@link protos.records.Nats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.INats} message Nats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Nats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Nats message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Nats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Nats} Nats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Nats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Nats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Nats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Nats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Nats} Nats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Nats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Nats message.
             * @function verify
             * @memberof protos.records.Nats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Nats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a Nats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Nats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Nats} Nats
             */
            Nats.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Nats)
                    return object;
                var message = new $root.protos.records.Nats();
                if (object.subject != null)
                    message.subject = String(object.subject);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a Nats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.Nats} message Nats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Nats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.subject = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Nats to JSON.
             * @function toJSON
             * @memberof protos.records.Nats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Nats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Nats;
        })();

        records.NatsStreaming = (function() {

            /**
             * Properties of a NatsStreaming.
             * @memberof protos.records
             * @interface INatsStreaming
             * @property {Object.<string,string>|null} [metadata] NatsStreaming metadata
             * @property {Uint8Array|null} [value] NatsStreaming value
             * @property {number|Long|null} [timestamp] NatsStreaming timestamp
             */

            /**
             * Constructs a new NatsStreaming.
             * @memberof protos.records
             * @classdesc Represents a NatsStreaming.
             * @implements INatsStreaming
             * @constructor
             * @param {protos.records.INatsStreaming=} [properties] Properties to set
             */
            function NatsStreaming(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreaming metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.NatsStreaming
             * @instance
             */
            NatsStreaming.prototype.metadata = $util.emptyObject;

            /**
             * NatsStreaming value.
             * @member {Uint8Array} value
             * @memberof protos.records.NatsStreaming
             * @instance
             */
            NatsStreaming.prototype.value = $util.newBuffer([]);

            /**
             * NatsStreaming timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.NatsStreaming
             * @instance
             */
            NatsStreaming.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new NatsStreaming instance using the specified properties.
             * @function create
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.INatsStreaming=} [properties] Properties to set
             * @returns {protos.records.NatsStreaming} NatsStreaming instance
             */
            NatsStreaming.create = function create(properties) {
                return new NatsStreaming(properties);
            };

            /**
             * Encodes the specified NatsStreaming message. Does not implicitly {@link protos.records.NatsStreaming.verify|verify} messages.
             * @function encode
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.INatsStreaming} message NatsStreaming message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreaming.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified NatsStreaming message, length delimited. Does not implicitly {@link protos.records.NatsStreaming.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.INatsStreaming} message NatsStreaming message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreaming.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreaming message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.NatsStreaming} NatsStreaming
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreaming.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.NatsStreaming(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreaming message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.NatsStreaming} NatsStreaming
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreaming.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreaming message.
             * @function verify
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreaming.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a NatsStreaming message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.NatsStreaming} NatsStreaming
             */
            NatsStreaming.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.NatsStreaming)
                    return object;
                var message = new $root.protos.records.NatsStreaming();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.NatsStreaming.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a NatsStreaming message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.NatsStreaming} message NatsStreaming
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreaming.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this NatsStreaming to JSON.
             * @function toJSON
             * @memberof protos.records.NatsStreaming
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreaming.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreaming;
        })();

        records.NSQ = (function() {

            /**
             * Properties of a NSQ.
             * @memberof protos.records
             * @interface INSQ
             * @property {string|null} [id] NSQ id
             * @property {string|null} [topic] NSQ topic
             * @property {string|null} [channel] NSQ channel
             * @property {number|null} [attempts] NSQ attempts
             * @property {string|null} [nsqdAddress] NSQ nsqdAddress
             * @property {Uint8Array|null} [value] NSQ value
             * @property {number|Long|null} [timestamp] NSQ timestamp
             */

            /**
             * Constructs a new NSQ.
             * @memberof protos.records
             * @classdesc Represents a NSQ.
             * @implements INSQ
             * @constructor
             * @param {protos.records.INSQ=} [properties] Properties to set
             */
            function NSQ(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQ id.
             * @member {string} id
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.id = "";

            /**
             * NSQ topic.
             * @member {string} topic
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.topic = "";

            /**
             * NSQ channel.
             * @member {string} channel
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.channel = "";

            /**
             * NSQ attempts.
             * @member {number} attempts
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.attempts = 0;

            /**
             * NSQ nsqdAddress.
             * @member {string} nsqdAddress
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.nsqdAddress = "";

            /**
             * NSQ value.
             * @member {Uint8Array} value
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.value = $util.newBuffer([]);

            /**
             * NSQ timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new NSQ instance using the specified properties.
             * @function create
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.INSQ=} [properties] Properties to set
             * @returns {protos.records.NSQ} NSQ instance
             */
            NSQ.create = function create(properties) {
                return new NSQ(properties);
            };

            /**
             * Encodes the specified NSQ message. Does not implicitly {@link protos.records.NSQ.verify|verify} messages.
             * @function encode
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.INSQ} message NSQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQ.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.channel);
                if (message.attempts != null && Object.hasOwnProperty.call(message, "attempts"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.attempts);
                if (message.nsqdAddress != null && Object.hasOwnProperty.call(message, "nsqdAddress"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.nsqdAddress);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified NSQ message, length delimited. Does not implicitly {@link protos.records.NSQ.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.INSQ} message NSQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQ.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQ message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.NSQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.NSQ} NSQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQ.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.NSQ();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    case 3:
                        message.channel = reader.string();
                        break;
                    case 4:
                        message.attempts = reader.int32();
                        break;
                    case 5:
                        message.nsqdAddress = reader.string();
                        break;
                    case 6:
                        message.value = reader.bytes();
                        break;
                    case 7:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQ message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.NSQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.NSQ} NSQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQ.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQ message.
             * @function verify
             * @memberof protos.records.NSQ
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQ.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.attempts != null && message.hasOwnProperty("attempts"))
                    if (!$util.isInteger(message.attempts))
                        return "attempts: integer expected";
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    if (!$util.isString(message.nsqdAddress))
                        return "nsqdAddress: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a NSQ message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.NSQ
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.NSQ} NSQ
             */
            NSQ.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.NSQ)
                    return object;
                var message = new $root.protos.records.NSQ();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.attempts != null)
                    message.attempts = object.attempts | 0;
                if (object.nsqdAddress != null)
                    message.nsqdAddress = String(object.nsqdAddress);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a NSQ message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.NSQ} message NSQ
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQ.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.topic = "";
                    object.channel = "";
                    object.attempts = 0;
                    object.nsqdAddress = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.attempts != null && message.hasOwnProperty("attempts"))
                    object.attempts = message.attempts;
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    object.nsqdAddress = message.nsqdAddress;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this NSQ to JSON.
             * @function toJSON
             * @memberof protos.records.NSQ
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQ.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQ;
        })();

        records.Postgres = (function() {

            /**
             * Properties of a Postgres.
             * @memberof protos.records
             * @interface IPostgres
             * @property {Object.<string,string>|null} [metadata] Postgres metadata
             * @property {number|Long|null} [timestamp] Postgres timestamp
             * @property {Uint8Array|null} [value] Postgres value
             */

            /**
             * Constructs a new Postgres.
             * @memberof protos.records
             * @classdesc Represents a Postgres.
             * @implements IPostgres
             * @constructor
             * @param {protos.records.IPostgres=} [properties] Properties to set
             */
            function Postgres(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Postgres metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.Postgres
             * @instance
             */
            Postgres.prototype.metadata = $util.emptyObject;

            /**
             * Postgres timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Postgres
             * @instance
             */
            Postgres.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Postgres value.
             * @member {Uint8Array} value
             * @memberof protos.records.Postgres
             * @instance
             */
            Postgres.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Postgres instance using the specified properties.
             * @function create
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.IPostgres=} [properties] Properties to set
             * @returns {protos.records.Postgres} Postgres instance
             */
            Postgres.create = function create(properties) {
                return new Postgres(properties);
            };

            /**
             * Encodes the specified Postgres message. Does not implicitly {@link protos.records.Postgres.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.IPostgres} message Postgres message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Postgres.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Postgres message, length delimited. Does not implicitly {@link protos.records.Postgres.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.IPostgres} message Postgres message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Postgres.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Postgres message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Postgres
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Postgres} Postgres
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Postgres.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Postgres(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Postgres message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Postgres
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Postgres} Postgres
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Postgres.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Postgres message.
             * @function verify
             * @memberof protos.records.Postgres
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Postgres.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a Postgres message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Postgres
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Postgres} Postgres
             */
            Postgres.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Postgres)
                    return object;
                var message = new $root.protos.records.Postgres();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.Postgres.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a Postgres message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.Postgres} message Postgres
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Postgres.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Postgres to JSON.
             * @function toJSON
             * @memberof protos.records.Postgres
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Postgres.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Postgres;
        })();

        records.Pulsar = (function() {

            /**
             * Properties of a Pulsar.
             * @memberof protos.records
             * @interface IPulsar
             * @property {string|null} [id] Pulsar id
             * @property {string|null} [key] Pulsar key
             * @property {string|null} [topic] Pulsar topic
             * @property {Object.<string,string>|null} [properties] Pulsar properties
             * @property {number|null} [redeliveryCount] Pulsar redeliveryCount
             * @property {string|null} [eventTime] Pulsar eventTime
             * @property {boolean|null} [isReplicated] Pulsar isReplicated
             * @property {string|null} [orderingKey] Pulsar orderingKey
             * @property {string|null} [producerName] Pulsar producerName
             * @property {string|null} [publishTime] Pulsar publishTime
             * @property {number|Long|null} [timestamp] Pulsar timestamp
             * @property {Uint8Array|null} [value] Pulsar value
             */

            /**
             * Constructs a new Pulsar.
             * @memberof protos.records
             * @classdesc Represents a Pulsar.
             * @implements IPulsar
             * @constructor
             * @param {protos.records.IPulsar=} [properties] Properties to set
             */
            function Pulsar(properties) {
                this.properties = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Pulsar id.
             * @member {string} id
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.id = "";

            /**
             * Pulsar key.
             * @member {string} key
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.key = "";

            /**
             * Pulsar topic.
             * @member {string} topic
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.topic = "";

            /**
             * Pulsar properties.
             * @member {Object.<string,string>} properties
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.properties = $util.emptyObject;

            /**
             * Pulsar redeliveryCount.
             * @member {number} redeliveryCount
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.redeliveryCount = 0;

            /**
             * Pulsar eventTime.
             * @member {string} eventTime
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.eventTime = "";

            /**
             * Pulsar isReplicated.
             * @member {boolean} isReplicated
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.isReplicated = false;

            /**
             * Pulsar orderingKey.
             * @member {string} orderingKey
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.orderingKey = "";

            /**
             * Pulsar producerName.
             * @member {string} producerName
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.producerName = "";

            /**
             * Pulsar publishTime.
             * @member {string} publishTime
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.publishTime = "";

            /**
             * Pulsar timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Pulsar value.
             * @member {Uint8Array} value
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Pulsar instance using the specified properties.
             * @function create
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.IPulsar=} [properties] Properties to set
             * @returns {protos.records.Pulsar} Pulsar instance
             */
            Pulsar.create = function create(properties) {
                return new Pulsar(properties);
            };

            /**
             * Encodes the specified Pulsar message. Does not implicitly {@link protos.records.Pulsar.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.IPulsar} message Pulsar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pulsar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.topic);
                if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                    for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.properties[keys[i]]).ldelim();
                if (message.redeliveryCount != null && Object.hasOwnProperty.call(message, "redeliveryCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.redeliveryCount);
                if (message.eventTime != null && Object.hasOwnProperty.call(message, "eventTime"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.eventTime);
                if (message.isReplicated != null && Object.hasOwnProperty.call(message, "isReplicated"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isReplicated);
                if (message.orderingKey != null && Object.hasOwnProperty.call(message, "orderingKey"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.orderingKey);
                if (message.producerName != null && Object.hasOwnProperty.call(message, "producerName"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.producerName);
                if (message.publishTime != null && Object.hasOwnProperty.call(message, "publishTime"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.publishTime);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Pulsar message, length delimited. Does not implicitly {@link protos.records.Pulsar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.IPulsar} message Pulsar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pulsar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Pulsar message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Pulsar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Pulsar} Pulsar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pulsar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Pulsar(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.topic = reader.string();
                        break;
                    case 4:
                        if (message.properties === $util.emptyObject)
                            message.properties = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.properties[key] = value;
                        break;
                    case 5:
                        message.redeliveryCount = reader.uint32();
                        break;
                    case 6:
                        message.eventTime = reader.string();
                        break;
                    case 7:
                        message.isReplicated = reader.bool();
                        break;
                    case 8:
                        message.orderingKey = reader.string();
                        break;
                    case 9:
                        message.producerName = reader.string();
                        break;
                    case 10:
                        message.publishTime = reader.string();
                        break;
                    case 11:
                        message.timestamp = reader.int64();
                        break;
                    case 12:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Pulsar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Pulsar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Pulsar} Pulsar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pulsar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Pulsar message.
             * @function verify
             * @memberof protos.records.Pulsar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Pulsar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.properties != null && message.hasOwnProperty("properties")) {
                    if (!$util.isObject(message.properties))
                        return "properties: object expected";
                    var key = Object.keys(message.properties);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.properties[key[i]]))
                            return "properties: string{k:string} expected";
                }
                if (message.redeliveryCount != null && message.hasOwnProperty("redeliveryCount"))
                    if (!$util.isInteger(message.redeliveryCount))
                        return "redeliveryCount: integer expected";
                if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                    if (!$util.isString(message.eventTime))
                        return "eventTime: string expected";
                if (message.isReplicated != null && message.hasOwnProperty("isReplicated"))
                    if (typeof message.isReplicated !== "boolean")
                        return "isReplicated: boolean expected";
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    if (!$util.isString(message.orderingKey))
                        return "orderingKey: string expected";
                if (message.producerName != null && message.hasOwnProperty("producerName"))
                    if (!$util.isString(message.producerName))
                        return "producerName: string expected";
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    if (!$util.isString(message.publishTime))
                        return "publishTime: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a Pulsar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Pulsar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Pulsar} Pulsar
             */
            Pulsar.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Pulsar)
                    return object;
                var message = new $root.protos.records.Pulsar();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.key != null)
                    message.key = String(object.key);
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.properties) {
                    if (typeof object.properties !== "object")
                        throw TypeError(".protos.records.Pulsar.properties: object expected");
                    message.properties = {};
                    for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i)
                        message.properties[keys[i]] = String(object.properties[keys[i]]);
                }
                if (object.redeliveryCount != null)
                    message.redeliveryCount = object.redeliveryCount >>> 0;
                if (object.eventTime != null)
                    message.eventTime = String(object.eventTime);
                if (object.isReplicated != null)
                    message.isReplicated = Boolean(object.isReplicated);
                if (object.orderingKey != null)
                    message.orderingKey = String(object.orderingKey);
                if (object.producerName != null)
                    message.producerName = String(object.producerName);
                if (object.publishTime != null)
                    message.publishTime = String(object.publishTime);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a Pulsar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.Pulsar} message Pulsar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Pulsar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.properties = {};
                if (options.defaults) {
                    object.id = "";
                    object.key = "";
                    object.topic = "";
                    object.redeliveryCount = 0;
                    object.eventTime = "";
                    object.isReplicated = false;
                    object.orderingKey = "";
                    object.producerName = "";
                    object.publishTime = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                var keys2;
                if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                    object.properties = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.properties[keys2[j]] = message.properties[keys2[j]];
                }
                if (message.redeliveryCount != null && message.hasOwnProperty("redeliveryCount"))
                    object.redeliveryCount = message.redeliveryCount;
                if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                    object.eventTime = message.eventTime;
                if (message.isReplicated != null && message.hasOwnProperty("isReplicated"))
                    object.isReplicated = message.isReplicated;
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    object.orderingKey = message.orderingKey;
                if (message.producerName != null && message.hasOwnProperty("producerName"))
                    object.producerName = message.producerName;
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    object.publishTime = message.publishTime;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Pulsar to JSON.
             * @function toJSON
             * @memberof protos.records.Pulsar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Pulsar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Pulsar;
        })();

        records.RabbitStreams = (function() {

            /**
             * Properties of a RabbitStreams.
             * @memberof protos.records
             * @interface IRabbitStreams
             * @property {string|null} [deliveryTag] RabbitStreams deliveryTag
             * @property {number|null} [format] RabbitStreams format
             * @property {protos.records.IRabbitStreamsHeader|null} [header] RabbitStreams header
             * @property {Object.<string,string>|null} [deliveryAnnotations] RabbitStreams deliveryAnnotations
             * @property {Object.<string,string>|null} [footer] RabbitStreams footer
             * @property {boolean|null} [sendSettled] RabbitStreams sendSettled
             * @property {string|null} [streamName] RabbitStreams streamName
             * @property {number|Long|null} [timestamp] RabbitStreams timestamp
             * @property {Uint8Array|null} [value] RabbitStreams value
             */

            /**
             * Constructs a new RabbitStreams.
             * @memberof protos.records
             * @classdesc Represents a RabbitStreams.
             * @implements IRabbitStreams
             * @constructor
             * @param {protos.records.IRabbitStreams=} [properties] Properties to set
             */
            function RabbitStreams(properties) {
                this.deliveryAnnotations = {};
                this.footer = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreams deliveryTag.
             * @member {string} deliveryTag
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.deliveryTag = "";

            /**
             * RabbitStreams format.
             * @member {number} format
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.format = 0;

            /**
             * RabbitStreams header.
             * @member {protos.records.IRabbitStreamsHeader|null|undefined} header
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.header = null;

            /**
             * RabbitStreams deliveryAnnotations.
             * @member {Object.<string,string>} deliveryAnnotations
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.deliveryAnnotations = $util.emptyObject;

            /**
             * RabbitStreams footer.
             * @member {Object.<string,string>} footer
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.footer = $util.emptyObject;

            /**
             * RabbitStreams sendSettled.
             * @member {boolean} sendSettled
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.sendSettled = false;

            /**
             * RabbitStreams streamName.
             * @member {string} streamName
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.streamName = "";

            /**
             * RabbitStreams timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RabbitStreams value.
             * @member {Uint8Array} value
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new RabbitStreams instance using the specified properties.
             * @function create
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.IRabbitStreams=} [properties] Properties to set
             * @returns {protos.records.RabbitStreams} RabbitStreams instance
             */
            RabbitStreams.create = function create(properties) {
                return new RabbitStreams(properties);
            };

            /**
             * Encodes the specified RabbitStreams message. Does not implicitly {@link protos.records.RabbitStreams.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.IRabbitStreams} message RabbitStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deliveryTag != null && Object.hasOwnProperty.call(message, "deliveryTag"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.deliveryTag);
                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.format);
                if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                    $root.protos.records.RabbitStreamsHeader.encode(message.header, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.deliveryAnnotations != null && Object.hasOwnProperty.call(message, "deliveryAnnotations"))
                    for (var keys = Object.keys(message.deliveryAnnotations), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.deliveryAnnotations[keys[i]]).ldelim();
                if (message.footer != null && Object.hasOwnProperty.call(message, "footer"))
                    for (var keys = Object.keys(message.footer), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.footer[keys[i]]).ldelim();
                if (message.sendSettled != null && Object.hasOwnProperty.call(message, "sendSettled"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.sendSettled);
                if (message.streamName != null && Object.hasOwnProperty.call(message, "streamName"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.streamName);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreams message, length delimited. Does not implicitly {@link protos.records.RabbitStreams.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.IRabbitStreams} message RabbitStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreams message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RabbitStreams} RabbitStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RabbitStreams(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deliveryTag = reader.string();
                        break;
                    case 2:
                        message.format = reader.uint32();
                        break;
                    case 3:
                        message.header = $root.protos.records.RabbitStreamsHeader.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (message.deliveryAnnotations === $util.emptyObject)
                            message.deliveryAnnotations = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.deliveryAnnotations[key] = value;
                        break;
                    case 5:
                        if (message.footer === $util.emptyObject)
                            message.footer = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.footer[key] = value;
                        break;
                    case 6:
                        message.sendSettled = reader.bool();
                        break;
                    case 7:
                        message.streamName = reader.string();
                        break;
                    case 8:
                        message.timestamp = reader.int64();
                        break;
                    case 9:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreams message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RabbitStreams} RabbitStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreams message.
             * @function verify
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deliveryTag != null && message.hasOwnProperty("deliveryTag"))
                    if (!$util.isString(message.deliveryTag))
                        return "deliveryTag: string expected";
                if (message.format != null && message.hasOwnProperty("format"))
                    if (!$util.isInteger(message.format))
                        return "format: integer expected";
                if (message.header != null && message.hasOwnProperty("header")) {
                    var error = $root.protos.records.RabbitStreamsHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.deliveryAnnotations != null && message.hasOwnProperty("deliveryAnnotations")) {
                    if (!$util.isObject(message.deliveryAnnotations))
                        return "deliveryAnnotations: object expected";
                    var key = Object.keys(message.deliveryAnnotations);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.deliveryAnnotations[key[i]]))
                            return "deliveryAnnotations: string{k:string} expected";
                }
                if (message.footer != null && message.hasOwnProperty("footer")) {
                    if (!$util.isObject(message.footer))
                        return "footer: object expected";
                    var key = Object.keys(message.footer);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.footer[key[i]]))
                            return "footer: string{k:string} expected";
                }
                if (message.sendSettled != null && message.hasOwnProperty("sendSettled"))
                    if (typeof message.sendSettled !== "boolean")
                        return "sendSettled: boolean expected";
                if (message.streamName != null && message.hasOwnProperty("streamName"))
                    if (!$util.isString(message.streamName))
                        return "streamName: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a RabbitStreams message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RabbitStreams} RabbitStreams
             */
            RabbitStreams.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RabbitStreams)
                    return object;
                var message = new $root.protos.records.RabbitStreams();
                if (object.deliveryTag != null)
                    message.deliveryTag = String(object.deliveryTag);
                if (object.format != null)
                    message.format = object.format >>> 0;
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".protos.records.RabbitStreams.header: object expected");
                    message.header = $root.protos.records.RabbitStreamsHeader.fromObject(object.header);
                }
                if (object.deliveryAnnotations) {
                    if (typeof object.deliveryAnnotations !== "object")
                        throw TypeError(".protos.records.RabbitStreams.deliveryAnnotations: object expected");
                    message.deliveryAnnotations = {};
                    for (var keys = Object.keys(object.deliveryAnnotations), i = 0; i < keys.length; ++i)
                        message.deliveryAnnotations[keys[i]] = String(object.deliveryAnnotations[keys[i]]);
                }
                if (object.footer) {
                    if (typeof object.footer !== "object")
                        throw TypeError(".protos.records.RabbitStreams.footer: object expected");
                    message.footer = {};
                    for (var keys = Object.keys(object.footer), i = 0; i < keys.length; ++i)
                        message.footer[keys[i]] = String(object.footer[keys[i]]);
                }
                if (object.sendSettled != null)
                    message.sendSettled = Boolean(object.sendSettled);
                if (object.streamName != null)
                    message.streamName = String(object.streamName);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreams message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.RabbitStreams} message RabbitStreams
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults) {
                    object.deliveryAnnotations = {};
                    object.footer = {};
                }
                if (options.defaults) {
                    object.deliveryTag = "";
                    object.format = 0;
                    object.header = null;
                    object.sendSettled = false;
                    object.streamName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.deliveryTag != null && message.hasOwnProperty("deliveryTag"))
                    object.deliveryTag = message.deliveryTag;
                if (message.format != null && message.hasOwnProperty("format"))
                    object.format = message.format;
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.protos.records.RabbitStreamsHeader.toObject(message.header, options);
                var keys2;
                if (message.deliveryAnnotations && (keys2 = Object.keys(message.deliveryAnnotations)).length) {
                    object.deliveryAnnotations = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.deliveryAnnotations[keys2[j]] = message.deliveryAnnotations[keys2[j]];
                }
                if (message.footer && (keys2 = Object.keys(message.footer)).length) {
                    object.footer = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.footer[keys2[j]] = message.footer[keys2[j]];
                }
                if (message.sendSettled != null && message.hasOwnProperty("sendSettled"))
                    object.sendSettled = message.sendSettled;
                if (message.streamName != null && message.hasOwnProperty("streamName"))
                    object.streamName = message.streamName;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this RabbitStreams to JSON.
             * @function toJSON
             * @memberof protos.records.RabbitStreams
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreams;
        })();

        records.RabbitStreamsHeader = (function() {

            /**
             * Properties of a RabbitStreamsHeader.
             * @memberof protos.records
             * @interface IRabbitStreamsHeader
             * @property {string|null} [messageId] RabbitStreamsHeader messageId
             * @property {string|null} [userId] RabbitStreamsHeader userId
             * @property {string|null} [to] RabbitStreamsHeader to
             * @property {string|null} [subject] RabbitStreamsHeader subject
             * @property {string|null} [replayTo] RabbitStreamsHeader replayTo
             * @property {string|null} [correlationId] RabbitStreamsHeader correlationId
             * @property {string|null} [contentType] RabbitStreamsHeader contentType
             * @property {string|null} [contentEncoding] RabbitStreamsHeader contentEncoding
             * @property {string|null} [absoluteExpiryTime] RabbitStreamsHeader absoluteExpiryTime
             * @property {string|null} [creationTime] RabbitStreamsHeader creationTime
             * @property {string|null} [groupId] RabbitStreamsHeader groupId
             * @property {number|null} [groupSequence] RabbitStreamsHeader groupSequence
             * @property {string|null} [replayToGroupId] RabbitStreamsHeader replayToGroupId
             */

            /**
             * Constructs a new RabbitStreamsHeader.
             * @memberof protos.records
             * @classdesc Represents a RabbitStreamsHeader.
             * @implements IRabbitStreamsHeader
             * @constructor
             * @param {protos.records.IRabbitStreamsHeader=} [properties] Properties to set
             */
            function RabbitStreamsHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsHeader messageId.
             * @member {string} messageId
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.messageId = "";

            /**
             * RabbitStreamsHeader userId.
             * @member {string} userId
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.userId = "";

            /**
             * RabbitStreamsHeader to.
             * @member {string} to
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.to = "";

            /**
             * RabbitStreamsHeader subject.
             * @member {string} subject
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.subject = "";

            /**
             * RabbitStreamsHeader replayTo.
             * @member {string} replayTo
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.replayTo = "";

            /**
             * RabbitStreamsHeader correlationId.
             * @member {string} correlationId
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.correlationId = "";

            /**
             * RabbitStreamsHeader contentType.
             * @member {string} contentType
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.contentType = "";

            /**
             * RabbitStreamsHeader contentEncoding.
             * @member {string} contentEncoding
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.contentEncoding = "";

            /**
             * RabbitStreamsHeader absoluteExpiryTime.
             * @member {string} absoluteExpiryTime
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.absoluteExpiryTime = "";

            /**
             * RabbitStreamsHeader creationTime.
             * @member {string} creationTime
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.creationTime = "";

            /**
             * RabbitStreamsHeader groupId.
             * @member {string} groupId
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.groupId = "";

            /**
             * RabbitStreamsHeader groupSequence.
             * @member {number} groupSequence
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.groupSequence = 0;

            /**
             * RabbitStreamsHeader replayToGroupId.
             * @member {string} replayToGroupId
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.replayToGroupId = "";

            /**
             * Creates a new RabbitStreamsHeader instance using the specified properties.
             * @function create
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.IRabbitStreamsHeader=} [properties] Properties to set
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader instance
             */
            RabbitStreamsHeader.create = function create(properties) {
                return new RabbitStreamsHeader(properties);
            };

            /**
             * Encodes the specified RabbitStreamsHeader message. Does not implicitly {@link protos.records.RabbitStreamsHeader.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.IRabbitStreamsHeader} message RabbitStreamsHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.userId);
                if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.to);
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.subject);
                if (message.replayTo != null && Object.hasOwnProperty.call(message, "replayTo"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.replayTo);
                if (message.correlationId != null && Object.hasOwnProperty.call(message, "correlationId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.correlationId);
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.contentType);
                if (message.contentEncoding != null && Object.hasOwnProperty.call(message, "contentEncoding"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.contentEncoding);
                if (message.absoluteExpiryTime != null && Object.hasOwnProperty.call(message, "absoluteExpiryTime"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.absoluteExpiryTime);
                if (message.creationTime != null && Object.hasOwnProperty.call(message, "creationTime"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.creationTime);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.groupId);
                if (message.groupSequence != null && Object.hasOwnProperty.call(message, "groupSequence"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.groupSequence);
                if (message.replayToGroupId != null && Object.hasOwnProperty.call(message, "replayToGroupId"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.replayToGroupId);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsHeader message, length delimited. Does not implicitly {@link protos.records.RabbitStreamsHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.IRabbitStreamsHeader} message RabbitStreamsHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsHeader message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RabbitStreamsHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageId = reader.string();
                        break;
                    case 2:
                        message.userId = reader.string();
                        break;
                    case 3:
                        message.to = reader.string();
                        break;
                    case 4:
                        message.subject = reader.string();
                        break;
                    case 5:
                        message.replayTo = reader.string();
                        break;
                    case 6:
                        message.correlationId = reader.string();
                        break;
                    case 7:
                        message.contentType = reader.string();
                        break;
                    case 8:
                        message.contentEncoding = reader.string();
                        break;
                    case 9:
                        message.absoluteExpiryTime = reader.string();
                        break;
                    case 10:
                        message.creationTime = reader.string();
                        break;
                    case 11:
                        message.groupId = reader.string();
                        break;
                    case 12:
                        message.groupSequence = reader.uint32();
                        break;
                    case 13:
                        message.replayToGroupId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsHeader message.
             * @function verify
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.userId != null && message.hasOwnProperty("userId"))
                    if (!$util.isString(message.userId))
                        return "userId: string expected";
                if (message.to != null && message.hasOwnProperty("to"))
                    if (!$util.isString(message.to))
                        return "to: string expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                if (message.replayTo != null && message.hasOwnProperty("replayTo"))
                    if (!$util.isString(message.replayTo))
                        return "replayTo: string expected";
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    if (!$util.isString(message.correlationId))
                        return "correlationId: string expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.contentEncoding != null && message.hasOwnProperty("contentEncoding"))
                    if (!$util.isString(message.contentEncoding))
                        return "contentEncoding: string expected";
                if (message.absoluteExpiryTime != null && message.hasOwnProperty("absoluteExpiryTime"))
                    if (!$util.isString(message.absoluteExpiryTime))
                        return "absoluteExpiryTime: string expected";
                if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                    if (!$util.isString(message.creationTime))
                        return "creationTime: string expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isString(message.groupId))
                        return "groupId: string expected";
                if (message.groupSequence != null && message.hasOwnProperty("groupSequence"))
                    if (!$util.isInteger(message.groupSequence))
                        return "groupSequence: integer expected";
                if (message.replayToGroupId != null && message.hasOwnProperty("replayToGroupId"))
                    if (!$util.isString(message.replayToGroupId))
                        return "replayToGroupId: string expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader
             */
            RabbitStreamsHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RabbitStreamsHeader)
                    return object;
                var message = new $root.protos.records.RabbitStreamsHeader();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.userId != null)
                    message.userId = String(object.userId);
                if (object.to != null)
                    message.to = String(object.to);
                if (object.subject != null)
                    message.subject = String(object.subject);
                if (object.replayTo != null)
                    message.replayTo = String(object.replayTo);
                if (object.correlationId != null)
                    message.correlationId = String(object.correlationId);
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.contentEncoding != null)
                    message.contentEncoding = String(object.contentEncoding);
                if (object.absoluteExpiryTime != null)
                    message.absoluteExpiryTime = String(object.absoluteExpiryTime);
                if (object.creationTime != null)
                    message.creationTime = String(object.creationTime);
                if (object.groupId != null)
                    message.groupId = String(object.groupId);
                if (object.groupSequence != null)
                    message.groupSequence = object.groupSequence >>> 0;
                if (object.replayToGroupId != null)
                    message.replayToGroupId = String(object.replayToGroupId);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.RabbitStreamsHeader} message RabbitStreamsHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.messageId = "";
                    object.userId = "";
                    object.to = "";
                    object.subject = "";
                    object.replayTo = "";
                    object.correlationId = "";
                    object.contentType = "";
                    object.contentEncoding = "";
                    object.absoluteExpiryTime = "";
                    object.creationTime = "";
                    object.groupId = "";
                    object.groupSequence = 0;
                    object.replayToGroupId = "";
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.userId != null && message.hasOwnProperty("userId"))
                    object.userId = message.userId;
                if (message.to != null && message.hasOwnProperty("to"))
                    object.to = message.to;
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                if (message.replayTo != null && message.hasOwnProperty("replayTo"))
                    object.replayTo = message.replayTo;
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    object.correlationId = message.correlationId;
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.contentEncoding != null && message.hasOwnProperty("contentEncoding"))
                    object.contentEncoding = message.contentEncoding;
                if (message.absoluteExpiryTime != null && message.hasOwnProperty("absoluteExpiryTime"))
                    object.absoluteExpiryTime = message.absoluteExpiryTime;
                if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                    object.creationTime = message.creationTime;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    object.groupId = message.groupId;
                if (message.groupSequence != null && message.hasOwnProperty("groupSequence"))
                    object.groupSequence = message.groupSequence;
                if (message.replayToGroupId != null && message.hasOwnProperty("replayToGroupId"))
                    object.replayToGroupId = message.replayToGroupId;
                return object;
            };

            /**
             * Converts this RabbitStreamsHeader to JSON.
             * @function toJSON
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsHeader;
        })();

        records.RedisPubsub = (function() {

            /**
             * Properties of a RedisPubsub.
             * @memberof protos.records
             * @interface IRedisPubsub
             * @property {Object.<string,string>|null} [metadata] RedisPubsub metadata
             * @property {Uint8Array|null} [value] RedisPubsub value
             * @property {number|Long|null} [timestamp] RedisPubsub timestamp
             */

            /**
             * Constructs a new RedisPubsub.
             * @memberof protos.records
             * @classdesc Represents a RedisPubsub.
             * @implements IRedisPubsub
             * @constructor
             * @param {protos.records.IRedisPubsub=} [properties] Properties to set
             */
            function RedisPubsub(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubsub metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.RedisPubsub
             * @instance
             */
            RedisPubsub.prototype.metadata = $util.emptyObject;

            /**
             * RedisPubsub value.
             * @member {Uint8Array} value
             * @memberof protos.records.RedisPubsub
             * @instance
             */
            RedisPubsub.prototype.value = $util.newBuffer([]);

            /**
             * RedisPubsub timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.RedisPubsub
             * @instance
             */
            RedisPubsub.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new RedisPubsub instance using the specified properties.
             * @function create
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.IRedisPubsub=} [properties] Properties to set
             * @returns {protos.records.RedisPubsub} RedisPubsub instance
             */
            RedisPubsub.create = function create(properties) {
                return new RedisPubsub(properties);
            };

            /**
             * Encodes the specified RedisPubsub message. Does not implicitly {@link protos.records.RedisPubsub.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.IRedisPubsub} message RedisPubsub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubsub.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified RedisPubsub message, length delimited. Does not implicitly {@link protos.records.RedisPubsub.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.IRedisPubsub} message RedisPubsub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubsub.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubsub message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RedisPubsub} RedisPubsub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubsub.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RedisPubsub(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubsub message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RedisPubsub} RedisPubsub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubsub.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubsub message.
             * @function verify
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubsub.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a RedisPubsub message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RedisPubsub} RedisPubsub
             */
            RedisPubsub.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RedisPubsub)
                    return object;
                var message = new $root.protos.records.RedisPubsub();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.RedisPubsub.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a RedisPubsub message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.RedisPubsub} message RedisPubsub
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubsub.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this RedisPubsub to JSON.
             * @function toJSON
             * @memberof protos.records.RedisPubsub
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubsub.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubsub;
        })();

        records.RedisStreams = (function() {

            /**
             * Properties of a RedisStreams.
             * @memberof protos.records
             * @interface IRedisStreams
             * @property {string|null} [id] RedisStreams id
             * @property {string|null} [key] RedisStreams key
             * @property {string|null} [value] RedisStreams value
             * @property {string|null} [stream] RedisStreams stream
             * @property {number|Long|null} [timestamp] RedisStreams timestamp
             */

            /**
             * Constructs a new RedisStreams.
             * @memberof protos.records
             * @classdesc Represents a RedisStreams.
             * @implements IRedisStreams
             * @constructor
             * @param {protos.records.IRedisStreams=} [properties] Properties to set
             */
            function RedisStreams(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreams id.
             * @member {string} id
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.id = "";

            /**
             * RedisStreams key.
             * @member {string} key
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.key = "";

            /**
             * RedisStreams value.
             * @member {string} value
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.value = "";

            /**
             * RedisStreams stream.
             * @member {string} stream
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.stream = "";

            /**
             * RedisStreams timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new RedisStreams instance using the specified properties.
             * @function create
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.IRedisStreams=} [properties] Properties to set
             * @returns {protos.records.RedisStreams} RedisStreams instance
             */
            RedisStreams.create = function create(properties) {
                return new RedisStreams(properties);
            };

            /**
             * Encodes the specified RedisStreams message. Does not implicitly {@link protos.records.RedisStreams.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.IRedisStreams} message RedisStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.stream);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified RedisStreams message, length delimited. Does not implicitly {@link protos.records.RedisStreams.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.IRedisStreams} message RedisStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreams message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RedisStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RedisStreams} RedisStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RedisStreams();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.value = reader.string();
                        break;
                    case 4:
                        message.stream = reader.string();
                        break;
                    case 5:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreams message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RedisStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RedisStreams} RedisStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreams message.
             * @function verify
             * @memberof protos.records.RedisStreams
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a RedisStreams message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RedisStreams
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RedisStreams} RedisStreams
             */
            RedisStreams.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RedisStreams)
                    return object;
                var message = new $root.protos.records.RedisStreams();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a RedisStreams message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.RedisStreams} message RedisStreams
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.key = "";
                    object.value = "";
                    object.stream = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this RedisStreams to JSON.
             * @function toJSON
             * @memberof protos.records.RedisStreams
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreams;
        })();

        return records;
    })();

    protos.encoding = (function() {

        /**
         * Namespace encoding.
         * @memberof protos
         * @namespace
         */
        var encoding = {};

        /**
         * EncodeType enum.
         * @name protos.encoding.EncodeType
         * @enum {number}
         * @property {number} ENCODE_TYPE_UNSET=0 ENCODE_TYPE_UNSET value
         * @property {number} ENCODE_TYPE_JSONPB=1 ENCODE_TYPE_JSONPB value
         * @property {number} ENCODE_TYPE_AVRO=2 ENCODE_TYPE_AVRO value
         */
        encoding.EncodeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ENCODE_TYPE_UNSET"] = 0;
            values[valuesById[1] = "ENCODE_TYPE_JSONPB"] = 1;
            values[valuesById[2] = "ENCODE_TYPE_AVRO"] = 2;
            return values;
        })();

        /**
         * DecodeType enum.
         * @name protos.encoding.DecodeType
         * @enum {number}
         * @property {number} DECODE_TYPE_UNSET=0 DECODE_TYPE_UNSET value
         * @property {number} DECODE_TYPE_PROTOBUF=1 DECODE_TYPE_PROTOBUF value
         * @property {number} DECODE_TYPE_AVRO=2 DECODE_TYPE_AVRO value
         * @property {number} DECODE_TYPE_THRIFT=3 DECODE_TYPE_THRIFT value
         * @property {number} DECODE_TYPE_FLATBUFFER=4 DECODE_TYPE_FLATBUFFER value
         */
        encoding.DecodeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DECODE_TYPE_UNSET"] = 0;
            values[valuesById[1] = "DECODE_TYPE_PROTOBUF"] = 1;
            values[valuesById[2] = "DECODE_TYPE_AVRO"] = 2;
            values[valuesById[3] = "DECODE_TYPE_THRIFT"] = 3;
            values[valuesById[4] = "DECODE_TYPE_FLATBUFFER"] = 4;
            return values;
        })();

        encoding.ProtobufSettings = (function() {

            /**
             * Properties of a ProtobufSettings.
             * @memberof protos.encoding
             * @interface IProtobufSettings
             * @property {string|null} [protobufRootMessage] ProtobufSettings protobufRootMessage
             * @property {Array.<string>|null} [protobufDirs] ProtobufSettings protobufDirs
             * @property {string|null} [_protobufRootDir] ProtobufSettings _protobufRootDir
             * @property {Uint8Array|null} [archive] ProtobufSettings archive
             * @property {Uint8Array|null} [_messageDescriptor] ProtobufSettings _messageDescriptor
             */

            /**
             * Constructs a new ProtobufSettings.
             * @memberof protos.encoding
             * @classdesc Represents a ProtobufSettings.
             * @implements IProtobufSettings
             * @constructor
             * @param {protos.encoding.IProtobufSettings=} [properties] Properties to set
             */
            function ProtobufSettings(properties) {
                this.protobufDirs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProtobufSettings protobufRootMessage.
             * @member {string} protobufRootMessage
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufRootMessage = "";

            /**
             * ProtobufSettings protobufDirs.
             * @member {Array.<string>} protobufDirs
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufDirs = $util.emptyArray;

            /**
             * ProtobufSettings _protobufRootDir.
             * @member {string} _protobufRootDir
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype._protobufRootDir = "";

            /**
             * ProtobufSettings archive.
             * @member {Uint8Array} archive
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.archive = $util.newBuffer([]);

            /**
             * ProtobufSettings _messageDescriptor.
             * @member {Uint8Array} _messageDescriptor
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype._messageDescriptor = $util.newBuffer([]);

            /**
             * Creates a new ProtobufSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings=} [properties] Properties to set
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings instance
             */
            ProtobufSettings.create = function create(properties) {
                return new ProtobufSettings(properties);
            };

            /**
             * Encodes the specified ProtobufSettings message. Does not implicitly {@link protos.encoding.ProtobufSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings} message ProtobufSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtobufSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.protobufRootMessage != null && Object.hasOwnProperty.call(message, "protobufRootMessage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.protobufRootMessage);
                if (message.protobufDirs != null && message.protobufDirs.length)
                    for (var i = 0; i < message.protobufDirs.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.protobufDirs[i]);
                if (message._protobufRootDir != null && Object.hasOwnProperty.call(message, "_protobufRootDir"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message._protobufRootDir);
                if (message.archive != null && Object.hasOwnProperty.call(message, "archive"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.archive);
                if (message._messageDescriptor != null && Object.hasOwnProperty.call(message, "_messageDescriptor"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message._messageDescriptor);
                return writer;
            };

            /**
             * Encodes the specified ProtobufSettings message, length delimited. Does not implicitly {@link protos.encoding.ProtobufSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings} message ProtobufSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtobufSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtobufSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtobufSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.ProtobufSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.protobufRootMessage = reader.string();
                        break;
                    case 2:
                        if (!(message.protobufDirs && message.protobufDirs.length))
                            message.protobufDirs = [];
                        message.protobufDirs.push(reader.string());
                        break;
                    case 3:
                        message._protobufRootDir = reader.string();
                        break;
                    case 4:
                        message.archive = reader.bytes();
                        break;
                    case 5:
                        message._messageDescriptor = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtobufSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtobufSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtobufSettings message.
             * @function verify
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtobufSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.protobufRootMessage != null && message.hasOwnProperty("protobufRootMessage"))
                    if (!$util.isString(message.protobufRootMessage))
                        return "protobufRootMessage: string expected";
                if (message.protobufDirs != null && message.hasOwnProperty("protobufDirs")) {
                    if (!Array.isArray(message.protobufDirs))
                        return "protobufDirs: array expected";
                    for (var i = 0; i < message.protobufDirs.length; ++i)
                        if (!$util.isString(message.protobufDirs[i]))
                            return "protobufDirs: string[] expected";
                }
                if (message._protobufRootDir != null && message.hasOwnProperty("_protobufRootDir"))
                    if (!$util.isString(message._protobufRootDir))
                        return "_protobufRootDir: string expected";
                if (message.archive != null && message.hasOwnProperty("archive"))
                    if (!(message.archive && typeof message.archive.length === "number" || $util.isString(message.archive)))
                        return "archive: buffer expected";
                if (message._messageDescriptor != null && message.hasOwnProperty("_messageDescriptor"))
                    if (!(message._messageDescriptor && typeof message._messageDescriptor.length === "number" || $util.isString(message._messageDescriptor)))
                        return "_messageDescriptor: buffer expected";
                return null;
            };

            /**
             * Creates a ProtobufSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             */
            ProtobufSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.ProtobufSettings)
                    return object;
                var message = new $root.protos.encoding.ProtobufSettings();
                if (object.protobufRootMessage != null)
                    message.protobufRootMessage = String(object.protobufRootMessage);
                if (object.protobufDirs) {
                    if (!Array.isArray(object.protobufDirs))
                        throw TypeError(".protos.encoding.ProtobufSettings.protobufDirs: array expected");
                    message.protobufDirs = [];
                    for (var i = 0; i < object.protobufDirs.length; ++i)
                        message.protobufDirs[i] = String(object.protobufDirs[i]);
                }
                if (object._protobufRootDir != null)
                    message._protobufRootDir = String(object._protobufRootDir);
                if (object.archive != null)
                    if (typeof object.archive === "string")
                        $util.base64.decode(object.archive, message.archive = $util.newBuffer($util.base64.length(object.archive)), 0);
                    else if (object.archive.length)
                        message.archive = object.archive;
                if (object._messageDescriptor != null)
                    if (typeof object._messageDescriptor === "string")
                        $util.base64.decode(object._messageDescriptor, message._messageDescriptor = $util.newBuffer($util.base64.length(object._messageDescriptor)), 0);
                    else if (object._messageDescriptor.length)
                        message._messageDescriptor = object._messageDescriptor;
                return message;
            };

            /**
             * Creates a plain object from a ProtobufSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.ProtobufSettings} message ProtobufSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtobufSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.protobufDirs = [];
                if (options.defaults) {
                    object.protobufRootMessage = "";
                    object._protobufRootDir = "";
                    if (options.bytes === String)
                        object.archive = "";
                    else {
                        object.archive = [];
                        if (options.bytes !== Array)
                            object.archive = $util.newBuffer(object.archive);
                    }
                    if (options.bytes === String)
                        object._messageDescriptor = "";
                    else {
                        object._messageDescriptor = [];
                        if (options.bytes !== Array)
                            object._messageDescriptor = $util.newBuffer(object._messageDescriptor);
                    }
                }
                if (message.protobufRootMessage != null && message.hasOwnProperty("protobufRootMessage"))
                    object.protobufRootMessage = message.protobufRootMessage;
                if (message.protobufDirs && message.protobufDirs.length) {
                    object.protobufDirs = [];
                    for (var j = 0; j < message.protobufDirs.length; ++j)
                        object.protobufDirs[j] = message.protobufDirs[j];
                }
                if (message._protobufRootDir != null && message.hasOwnProperty("_protobufRootDir"))
                    object._protobufRootDir = message._protobufRootDir;
                if (message.archive != null && message.hasOwnProperty("archive"))
                    object.archive = options.bytes === String ? $util.base64.encode(message.archive, 0, message.archive.length) : options.bytes === Array ? Array.prototype.slice.call(message.archive) : message.archive;
                if (message._messageDescriptor != null && message.hasOwnProperty("_messageDescriptor"))
                    object._messageDescriptor = options.bytes === String ? $util.base64.encode(message._messageDescriptor, 0, message._messageDescriptor.length) : options.bytes === Array ? Array.prototype.slice.call(message._messageDescriptor) : message._messageDescriptor;
                return object;
            };

            /**
             * Converts this ProtobufSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtobufSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtobufSettings;
        })();

        encoding.AvroSettings = (function() {

            /**
             * Properties of an AvroSettings.
             * @memberof protos.encoding
             * @interface IAvroSettings
             * @property {string|null} [avroSchemaFile] AvroSettings avroSchemaFile
             * @property {Uint8Array|null} [schema] AvroSettings schema
             */

            /**
             * Constructs a new AvroSettings.
             * @memberof protos.encoding
             * @classdesc Represents an AvroSettings.
             * @implements IAvroSettings
             * @constructor
             * @param {protos.encoding.IAvroSettings=} [properties] Properties to set
             */
            function AvroSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AvroSettings avroSchemaFile.
             * @member {string} avroSchemaFile
             * @memberof protos.encoding.AvroSettings
             * @instance
             */
            AvroSettings.prototype.avroSchemaFile = "";

            /**
             * AvroSettings schema.
             * @member {Uint8Array} schema
             * @memberof protos.encoding.AvroSettings
             * @instance
             */
            AvroSettings.prototype.schema = $util.newBuffer([]);

            /**
             * Creates a new AvroSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings=} [properties] Properties to set
             * @returns {protos.encoding.AvroSettings} AvroSettings instance
             */
            AvroSettings.create = function create(properties) {
                return new AvroSettings(properties);
            };

            /**
             * Encodes the specified AvroSettings message. Does not implicitly {@link protos.encoding.AvroSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings} message AvroSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvroSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.avroSchemaFile != null && Object.hasOwnProperty.call(message, "avroSchemaFile"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.avroSchemaFile);
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.schema);
                return writer;
            };

            /**
             * Encodes the specified AvroSettings message, length delimited. Does not implicitly {@link protos.encoding.AvroSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings} message AvroSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvroSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AvroSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.AvroSettings} AvroSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvroSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.AvroSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.avroSchemaFile = reader.string();
                        break;
                    case 2:
                        message.schema = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AvroSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.AvroSettings} AvroSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvroSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AvroSettings message.
             * @function verify
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AvroSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.avroSchemaFile != null && message.hasOwnProperty("avroSchemaFile"))
                    if (!$util.isString(message.avroSchemaFile))
                        return "avroSchemaFile: string expected";
                if (message.schema != null && message.hasOwnProperty("schema"))
                    if (!(message.schema && typeof message.schema.length === "number" || $util.isString(message.schema)))
                        return "schema: buffer expected";
                return null;
            };

            /**
             * Creates an AvroSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.AvroSettings} AvroSettings
             */
            AvroSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.AvroSettings)
                    return object;
                var message = new $root.protos.encoding.AvroSettings();
                if (object.avroSchemaFile != null)
                    message.avroSchemaFile = String(object.avroSchemaFile);
                if (object.schema != null)
                    if (typeof object.schema === "string")
                        $util.base64.decode(object.schema, message.schema = $util.newBuffer($util.base64.length(object.schema)), 0);
                    else if (object.schema.length)
                        message.schema = object.schema;
                return message;
            };

            /**
             * Creates a plain object from an AvroSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.AvroSettings} message AvroSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AvroSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.avroSchemaFile = "";
                    if (options.bytes === String)
                        object.schema = "";
                    else {
                        object.schema = [];
                        if (options.bytes !== Array)
                            object.schema = $util.newBuffer(object.schema);
                    }
                }
                if (message.avroSchemaFile != null && message.hasOwnProperty("avroSchemaFile"))
                    object.avroSchemaFile = message.avroSchemaFile;
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = options.bytes === String ? $util.base64.encode(message.schema, 0, message.schema.length) : options.bytes === Array ? Array.prototype.slice.call(message.schema) : message.schema;
                return object;
            };

            /**
             * Converts this AvroSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.AvroSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AvroSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AvroSettings;
        })();

        encoding.JSONSchemaSettings = (function() {

            /**
             * Properties of a JSONSchemaSettings.
             * @memberof protos.encoding
             * @interface IJSONSchemaSettings
             * @property {Uint8Array|null} [schema] JSONSchemaSettings schema
             */

            /**
             * Constructs a new JSONSchemaSettings.
             * @memberof protos.encoding
             * @classdesc Represents a JSONSchemaSettings.
             * @implements IJSONSchemaSettings
             * @constructor
             * @param {protos.encoding.IJSONSchemaSettings=} [properties] Properties to set
             */
            function JSONSchemaSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JSONSchemaSettings schema.
             * @member {Uint8Array} schema
             * @memberof protos.encoding.JSONSchemaSettings
             * @instance
             */
            JSONSchemaSettings.prototype.schema = $util.newBuffer([]);

            /**
             * Creates a new JSONSchemaSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.IJSONSchemaSettings=} [properties] Properties to set
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings instance
             */
            JSONSchemaSettings.create = function create(properties) {
                return new JSONSchemaSettings(properties);
            };

            /**
             * Encodes the specified JSONSchemaSettings message. Does not implicitly {@link protos.encoding.JSONSchemaSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.IJSONSchemaSettings} message JSONSchemaSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JSONSchemaSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.schema);
                return writer;
            };

            /**
             * Encodes the specified JSONSchemaSettings message, length delimited. Does not implicitly {@link protos.encoding.JSONSchemaSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.IJSONSchemaSettings} message JSONSchemaSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JSONSchemaSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JSONSchemaSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JSONSchemaSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.JSONSchemaSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schema = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JSONSchemaSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JSONSchemaSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JSONSchemaSettings message.
             * @function verify
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JSONSchemaSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schema != null && message.hasOwnProperty("schema"))
                    if (!(message.schema && typeof message.schema.length === "number" || $util.isString(message.schema)))
                        return "schema: buffer expected";
                return null;
            };

            /**
             * Creates a JSONSchemaSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings
             */
            JSONSchemaSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.JSONSchemaSettings)
                    return object;
                var message = new $root.protos.encoding.JSONSchemaSettings();
                if (object.schema != null)
                    if (typeof object.schema === "string")
                        $util.base64.decode(object.schema, message.schema = $util.newBuffer($util.base64.length(object.schema)), 0);
                    else if (object.schema.length)
                        message.schema = object.schema;
                return message;
            };

            /**
             * Creates a plain object from a JSONSchemaSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.JSONSchemaSettings} message JSONSchemaSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JSONSchemaSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.schema = "";
                    else {
                        object.schema = [];
                        if (options.bytes !== Array)
                            object.schema = $util.newBuffer(object.schema);
                    }
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = options.bytes === String ? $util.base64.encode(message.schema, 0, message.schema.length) : options.bytes === Array ? Array.prototype.slice.call(message.schema) : message.schema;
                return object;
            };

            /**
             * Converts this JSONSchemaSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.JSONSchemaSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JSONSchemaSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return JSONSchemaSettings;
        })();

        encoding.EncodeOptions = (function() {

            /**
             * Properties of an EncodeOptions.
             * @memberof protos.encoding
             * @interface IEncodeOptions
             * @property {string|null} [schemaId] EncodeOptions schemaId
             * @property {protos.encoding.EncodeType|null} [encodeType] EncodeOptions encodeType
             * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] EncodeOptions protobufSettings
             * @property {protos.encoding.IAvroSettings|null} [avroSettings] EncodeOptions avroSettings
             */

            /**
             * Constructs a new EncodeOptions.
             * @memberof protos.encoding
             * @classdesc Represents an EncodeOptions.
             * @implements IEncodeOptions
             * @constructor
             * @param {protos.encoding.IEncodeOptions=} [properties] Properties to set
             */
            function EncodeOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EncodeOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.schemaId = "";

            /**
             * EncodeOptions encodeType.
             * @member {protos.encoding.EncodeType} encodeType
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.encodeType = 0;

            /**
             * EncodeOptions protobufSettings.
             * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.protobufSettings = null;

            /**
             * EncodeOptions avroSettings.
             * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.avroSettings = null;

            /**
             * Creates a new EncodeOptions instance using the specified properties.
             * @function create
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions=} [properties] Properties to set
             * @returns {protos.encoding.EncodeOptions} EncodeOptions instance
             */
            EncodeOptions.create = function create(properties) {
                return new EncodeOptions(properties);
            };

            /**
             * Encodes the specified EncodeOptions message. Does not implicitly {@link protos.encoding.EncodeOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions} message EncodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EncodeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.schemaId);
                if (message.encodeType != null && Object.hasOwnProperty.call(message, "encodeType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.encodeType);
                if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                    $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                    $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EncodeOptions message, length delimited. Does not implicitly {@link protos.encoding.EncodeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions} message EncodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EncodeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EncodeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EncodeOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.EncodeOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schemaId = reader.string();
                        break;
                    case 2:
                        message.encodeType = reader.int32();
                        break;
                    case 3:
                        message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EncodeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EncodeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EncodeOptions message.
             * @function verify
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EncodeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.encodeType != null && message.hasOwnProperty("encodeType"))
                    switch (message.encodeType) {
                    default:
                        return "encodeType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                    var error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                    var error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
                return null;
            };

            /**
             * Creates an EncodeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             */
            EncodeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.EncodeOptions)
                    return object;
                var message = new $root.protos.encoding.EncodeOptions();
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                switch (object.encodeType) {
                case "ENCODE_TYPE_UNSET":
                case 0:
                    message.encodeType = 0;
                    break;
                case "ENCODE_TYPE_JSONPB":
                case 1:
                    message.encodeType = 1;
                    break;
                case "ENCODE_TYPE_AVRO":
                case 2:
                    message.encodeType = 2;
                    break;
                }
                if (object.protobufSettings != null) {
                    if (typeof object.protobufSettings !== "object")
                        throw TypeError(".protos.encoding.EncodeOptions.protobufSettings: object expected");
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
                }
                if (object.avroSettings != null) {
                    if (typeof object.avroSettings !== "object")
                        throw TypeError(".protos.encoding.EncodeOptions.avroSettings: object expected");
                    message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from an EncodeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.EncodeOptions} message EncodeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EncodeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.schemaId = "";
                    object.encodeType = options.enums === String ? "ENCODE_TYPE_UNSET" : 0;
                    object.protobufSettings = null;
                    object.avroSettings = null;
                }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.encodeType != null && message.hasOwnProperty("encodeType"))
                    object.encodeType = options.enums === String ? $root.protos.encoding.EncodeType[message.encodeType] : message.encodeType;
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings"))
                    object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings"))
                    object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                return object;
            };

            /**
             * Converts this EncodeOptions to JSON.
             * @function toJSON
             * @memberof protos.encoding.EncodeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EncodeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EncodeOptions;
        })();

        encoding.DecodeOptions = (function() {

            /**
             * Properties of a DecodeOptions.
             * @memberof protos.encoding
             * @interface IDecodeOptions
             * @property {string|null} [schemaId] DecodeOptions schemaId
             * @property {protos.encoding.DecodeType|null} [decodeType] DecodeOptions decodeType
             * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] DecodeOptions protobufSettings
             * @property {protos.encoding.IAvroSettings|null} [avroSettings] DecodeOptions avroSettings
             */

            /**
             * Constructs a new DecodeOptions.
             * @memberof protos.encoding
             * @classdesc Represents a DecodeOptions.
             * @implements IDecodeOptions
             * @constructor
             * @param {protos.encoding.IDecodeOptions=} [properties] Properties to set
             */
            function DecodeOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DecodeOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.schemaId = "";

            /**
             * DecodeOptions decodeType.
             * @member {protos.encoding.DecodeType} decodeType
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.decodeType = 0;

            /**
             * DecodeOptions protobufSettings.
             * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.protobufSettings = null;

            /**
             * DecodeOptions avroSettings.
             * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.avroSettings = null;

            /**
             * Creates a new DecodeOptions instance using the specified properties.
             * @function create
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions=} [properties] Properties to set
             * @returns {protos.encoding.DecodeOptions} DecodeOptions instance
             */
            DecodeOptions.create = function create(properties) {
                return new DecodeOptions(properties);
            };

            /**
             * Encodes the specified DecodeOptions message. Does not implicitly {@link protos.encoding.DecodeOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions} message DecodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecodeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.schemaId);
                if (message.decodeType != null && Object.hasOwnProperty.call(message, "decodeType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.decodeType);
                if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                    $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                    $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DecodeOptions message, length delimited. Does not implicitly {@link protos.encoding.DecodeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions} message DecodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecodeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DecodeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecodeOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.DecodeOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schemaId = reader.string();
                        break;
                    case 2:
                        message.decodeType = reader.int32();
                        break;
                    case 3:
                        message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DecodeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecodeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DecodeOptions message.
             * @function verify
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DecodeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.decodeType != null && message.hasOwnProperty("decodeType"))
                    switch (message.decodeType) {
                    default:
                        return "decodeType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                    var error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                    var error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
                return null;
            };

            /**
             * Creates a DecodeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             */
            DecodeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.DecodeOptions)
                    return object;
                var message = new $root.protos.encoding.DecodeOptions();
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                switch (object.decodeType) {
                case "DECODE_TYPE_UNSET":
                case 0:
                    message.decodeType = 0;
                    break;
                case "DECODE_TYPE_PROTOBUF":
                case 1:
                    message.decodeType = 1;
                    break;
                case "DECODE_TYPE_AVRO":
                case 2:
                    message.decodeType = 2;
                    break;
                case "DECODE_TYPE_THRIFT":
                case 3:
                    message.decodeType = 3;
                    break;
                case "DECODE_TYPE_FLATBUFFER":
                case 4:
                    message.decodeType = 4;
                    break;
                }
                if (object.protobufSettings != null) {
                    if (typeof object.protobufSettings !== "object")
                        throw TypeError(".protos.encoding.DecodeOptions.protobufSettings: object expected");
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
                }
                if (object.avroSettings != null) {
                    if (typeof object.avroSettings !== "object")
                        throw TypeError(".protos.encoding.DecodeOptions.avroSettings: object expected");
                    message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from a DecodeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.DecodeOptions} message DecodeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DecodeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.schemaId = "";
                    object.decodeType = options.enums === String ? "DECODE_TYPE_UNSET" : 0;
                    object.protobufSettings = null;
                    object.avroSettings = null;
                }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.decodeType != null && message.hasOwnProperty("decodeType"))
                    object.decodeType = options.enums === String ? $root.protos.encoding.DecodeType[message.decodeType] : message.decodeType;
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings"))
                    object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings"))
                    object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                return object;
            };

            /**
             * Converts this DecodeOptions to JSON.
             * @function toJSON
             * @memberof protos.encoding.DecodeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DecodeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DecodeOptions;
        })();

        return encoding;
    })();

    protos.WriteRequest = (function() {

        /**
         * Properties of a WriteRequest.
         * @memberof protos
         * @interface IWriteRequest
         * @property {protos.common.IAuth|null} [auth] WriteRequest auth
         * @property {protos.opts.IWriteOptions|null} [opts] WriteRequest opts
         */

        /**
         * Constructs a new WriteRequest.
         * @memberof protos
         * @classdesc Represents a WriteRequest.
         * @implements IWriteRequest
         * @constructor
         * @param {protos.IWriteRequest=} [properties] Properties to set
         */
        function WriteRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WriteRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.WriteRequest
         * @instance
         */
        WriteRequest.prototype.auth = null;

        /**
         * WriteRequest opts.
         * @member {protos.opts.IWriteOptions|null|undefined} opts
         * @memberof protos.WriteRequest
         * @instance
         */
        WriteRequest.prototype.opts = null;

        /**
         * Creates a new WriteRequest instance using the specified properties.
         * @function create
         * @memberof protos.WriteRequest
         * @static
         * @param {protos.IWriteRequest=} [properties] Properties to set
         * @returns {protos.WriteRequest} WriteRequest instance
         */
        WriteRequest.create = function create(properties) {
            return new WriteRequest(properties);
        };

        /**
         * Encodes the specified WriteRequest message. Does not implicitly {@link protos.WriteRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.WriteRequest
         * @static
         * @param {protos.IWriteRequest} message WriteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WriteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.WriteOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WriteRequest message, length delimited. Does not implicitly {@link protos.WriteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.WriteRequest
         * @static
         * @param {protos.IWriteRequest} message WriteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WriteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WriteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.WriteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.WriteRequest} WriteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WriteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.WriteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.WriteOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WriteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.WriteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.WriteRequest} WriteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WriteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WriteRequest message.
         * @function verify
         * @memberof protos.WriteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WriteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.WriteOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a WriteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.WriteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.WriteRequest} WriteRequest
         */
        WriteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.WriteRequest)
                return object;
            var message = new $root.protos.WriteRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.WriteRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.WriteRequest.opts: object expected");
                message.opts = $root.protos.opts.WriteOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a WriteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.WriteRequest
         * @static
         * @param {protos.WriteRequest} message WriteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WriteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.auth = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.WriteOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this WriteRequest to JSON.
         * @function toJSON
         * @memberof protos.WriteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WriteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WriteRequest;
    })();

    protos.WriteResponse = (function() {

        /**
         * Properties of a WriteResponse.
         * @memberof protos
         * @interface IWriteResponse
         * @property {protos.common.IStatus|null} [status] WriteResponse status
         */

        /**
         * Constructs a new WriteResponse.
         * @memberof protos
         * @classdesc Represents a WriteResponse.
         * @implements IWriteResponse
         * @constructor
         * @param {protos.IWriteResponse=} [properties] Properties to set
         */
        function WriteResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WriteResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.WriteResponse
         * @instance
         */
        WriteResponse.prototype.status = null;

        /**
         * Creates a new WriteResponse instance using the specified properties.
         * @function create
         * @memberof protos.WriteResponse
         * @static
         * @param {protos.IWriteResponse=} [properties] Properties to set
         * @returns {protos.WriteResponse} WriteResponse instance
         */
        WriteResponse.create = function create(properties) {
            return new WriteResponse(properties);
        };

        /**
         * Encodes the specified WriteResponse message. Does not implicitly {@link protos.WriteResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.WriteResponse
         * @static
         * @param {protos.IWriteResponse} message WriteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WriteResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WriteResponse message, length delimited. Does not implicitly {@link protos.WriteResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.WriteResponse
         * @static
         * @param {protos.IWriteResponse} message WriteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WriteResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WriteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.WriteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.WriteResponse} WriteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WriteResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.WriteResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WriteResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.WriteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.WriteResponse} WriteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WriteResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WriteResponse message.
         * @function verify
         * @memberof protos.WriteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WriteResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a WriteResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.WriteResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.WriteResponse} WriteResponse
         */
        WriteResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.WriteResponse)
                return object;
            var message = new $root.protos.WriteResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.WriteResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a WriteResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.WriteResponse
         * @static
         * @param {protos.WriteResponse} message WriteResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WriteResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this WriteResponse to JSON.
         * @function toJSON
         * @memberof protos.WriteResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WriteResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WriteResponse;
    })();

    protos.GetAllRelaysRequest = (function() {

        /**
         * Properties of a GetAllRelaysRequest.
         * @memberof protos
         * @interface IGetAllRelaysRequest
         * @property {protos.common.IAuth|null} [auth] GetAllRelaysRequest auth
         */

        /**
         * Constructs a new GetAllRelaysRequest.
         * @memberof protos
         * @classdesc Represents a GetAllRelaysRequest.
         * @implements IGetAllRelaysRequest
         * @constructor
         * @param {protos.IGetAllRelaysRequest=} [properties] Properties to set
         */
        function GetAllRelaysRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllRelaysRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllRelaysRequest
         * @instance
         */
        GetAllRelaysRequest.prototype.auth = null;

        /**
         * Creates a new GetAllRelaysRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.IGetAllRelaysRequest=} [properties] Properties to set
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest instance
         */
        GetAllRelaysRequest.create = function create(properties) {
            return new GetAllRelaysRequest(properties);
        };

        /**
         * Encodes the specified GetAllRelaysRequest message. Does not implicitly {@link protos.GetAllRelaysRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.IGetAllRelaysRequest} message GetAllRelaysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllRelaysRequest message, length delimited. Does not implicitly {@link protos.GetAllRelaysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.IGetAllRelaysRequest} message GetAllRelaysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllRelaysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllRelaysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllRelaysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllRelaysRequest message.
         * @function verify
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllRelaysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllRelaysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest
         */
        GetAllRelaysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllRelaysRequest)
                return object;
            var message = new $root.protos.GetAllRelaysRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllRelaysRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllRelaysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.GetAllRelaysRequest} message GetAllRelaysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllRelaysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllRelaysRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllRelaysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllRelaysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllRelaysRequest;
    })();

    protos.GetAllRelaysResponse = (function() {

        /**
         * Properties of a GetAllRelaysResponse.
         * @memberof protos
         * @interface IGetAllRelaysResponse
         * @property {protos.common.IStatus|null} [status] GetAllRelaysResponse status
         * @property {Array.<protos.opts.IRelayOptions>|null} [opts] GetAllRelaysResponse opts
         */

        /**
         * Constructs a new GetAllRelaysResponse.
         * @memberof protos
         * @classdesc Represents a GetAllRelaysResponse.
         * @implements IGetAllRelaysResponse
         * @constructor
         * @param {protos.IGetAllRelaysResponse=} [properties] Properties to set
         */
        function GetAllRelaysResponse(properties) {
            this.opts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllRelaysResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetAllRelaysResponse
         * @instance
         */
        GetAllRelaysResponse.prototype.status = null;

        /**
         * GetAllRelaysResponse opts.
         * @member {Array.<protos.opts.IRelayOptions>} opts
         * @memberof protos.GetAllRelaysResponse
         * @instance
         */
        GetAllRelaysResponse.prototype.opts = $util.emptyArray;

        /**
         * Creates a new GetAllRelaysResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.IGetAllRelaysResponse=} [properties] Properties to set
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse instance
         */
        GetAllRelaysResponse.create = function create(properties) {
            return new GetAllRelaysResponse(properties);
        };

        /**
         * Encodes the specified GetAllRelaysResponse message. Does not implicitly {@link protos.GetAllRelaysResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.IGetAllRelaysResponse} message GetAllRelaysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && message.opts.length)
                for (var i = 0; i < message.opts.length; ++i)
                    $root.protos.opts.RelayOptions.encode(message.opts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllRelaysResponse message, length delimited. Does not implicitly {@link protos.GetAllRelaysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.IGetAllRelaysResponse} message GetAllRelaysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllRelaysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllRelaysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    if (!(message.opts && message.opts.length))
                        message.opts = [];
                    message.opts.push($root.protos.opts.RelayOptions.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllRelaysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllRelaysResponse message.
         * @function verify
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllRelaysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                if (!Array.isArray(message.opts))
                    return "opts: array expected";
                for (var i = 0; i < message.opts.length; ++i) {
                    var error = $root.protos.opts.RelayOptions.verify(message.opts[i]);
                    if (error)
                        return "opts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetAllRelaysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse
         */
        GetAllRelaysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllRelaysResponse)
                return object;
            var message = new $root.protos.GetAllRelaysResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetAllRelaysResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.opts) {
                if (!Array.isArray(object.opts))
                    throw TypeError(".protos.GetAllRelaysResponse.opts: array expected");
                message.opts = [];
                for (var i = 0; i < object.opts.length; ++i) {
                    if (typeof object.opts[i] !== "object")
                        throw TypeError(".protos.GetAllRelaysResponse.opts: object expected");
                    message.opts[i] = $root.protos.opts.RelayOptions.fromObject(object.opts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllRelaysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.GetAllRelaysResponse} message GetAllRelaysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllRelaysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.opts = [];
            if (options.defaults)
                object.status = null;
            if (message.opts && message.opts.length) {
                object.opts = [];
                for (var j = 0; j < message.opts.length; ++j)
                    object.opts[j] = $root.protos.opts.RelayOptions.toObject(message.opts[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetAllRelaysResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllRelaysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllRelaysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllRelaysResponse;
    })();

    protos.GetRelayRequest = (function() {

        /**
         * Properties of a GetRelayRequest.
         * @memberof protos
         * @interface IGetRelayRequest
         * @property {protos.common.IAuth|null} [auth] GetRelayRequest auth
         * @property {string|null} [relayId] GetRelayRequest relayId
         */

        /**
         * Constructs a new GetRelayRequest.
         * @memberof protos
         * @classdesc Represents a GetRelayRequest.
         * @implements IGetRelayRequest
         * @constructor
         * @param {protos.IGetRelayRequest=} [properties] Properties to set
         */
        function GetRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetRelayRequest
         * @instance
         */
        GetRelayRequest.prototype.auth = null;

        /**
         * GetRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.GetRelayRequest
         * @instance
         */
        GetRelayRequest.prototype.relayId = "";

        /**
         * Creates a new GetRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.IGetRelayRequest=} [properties] Properties to set
         * @returns {protos.GetRelayRequest} GetRelayRequest instance
         */
        GetRelayRequest.create = function create(properties) {
            return new GetRelayRequest(properties);
        };

        /**
         * Encodes the specified GetRelayRequest message. Does not implicitly {@link protos.GetRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.IGetRelayRequest} message GetRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRelayRequest message, length delimited. Does not implicitly {@link protos.GetRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.IGetRelayRequest} message GetRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRelayRequest} GetRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRelayRequest} GetRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRelayRequest message.
         * @function verify
         * @memberof protos.GetRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a GetRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRelayRequest} GetRelayRequest
         */
        GetRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRelayRequest)
                return object;
            var message = new $root.protos.GetRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a GetRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.GetRelayRequest} message GetRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.GetRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRelayRequest;
    })();

    protos.GetRelayResponse = (function() {

        /**
         * Properties of a GetRelayResponse.
         * @memberof protos
         * @interface IGetRelayResponse
         * @property {protos.common.IStatus|null} [status] GetRelayResponse status
         * @property {protos.opts.IRelayOptions|null} [opts] GetRelayResponse opts
         */

        /**
         * Constructs a new GetRelayResponse.
         * @memberof protos
         * @classdesc Represents a GetRelayResponse.
         * @implements IGetRelayResponse
         * @constructor
         * @param {protos.IGetRelayResponse=} [properties] Properties to set
         */
        function GetRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetRelayResponse
         * @instance
         */
        GetRelayResponse.prototype.status = null;

        /**
         * GetRelayResponse opts.
         * @member {protos.opts.IRelayOptions|null|undefined} opts
         * @memberof protos.GetRelayResponse
         * @instance
         */
        GetRelayResponse.prototype.opts = null;

        /**
         * Creates a new GetRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.IGetRelayResponse=} [properties] Properties to set
         * @returns {protos.GetRelayResponse} GetRelayResponse instance
         */
        GetRelayResponse.create = function create(properties) {
            return new GetRelayResponse(properties);
        };

        /**
         * Encodes the specified GetRelayResponse message. Does not implicitly {@link protos.GetRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.IGetRelayResponse} message GetRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.RelayOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRelayResponse message, length delimited. Does not implicitly {@link protos.GetRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.IGetRelayResponse} message GetRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRelayResponse} GetRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRelayResponse} GetRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRelayResponse message.
         * @function verify
         * @memberof protos.GetRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.RelayOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a GetRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRelayResponse} GetRelayResponse
         */
        GetRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRelayResponse)
                return object;
            var message = new $root.protos.GetRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.GetRelayResponse.opts: object expected");
                message.opts = $root.protos.opts.RelayOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.GetRelayResponse} message GetRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.status = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.RelayOptions.toObject(message.opts, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.GetRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRelayResponse;
    })();

    protos.CreateRelayRequest = (function() {

        /**
         * Properties of a CreateRelayRequest.
         * @memberof protos
         * @interface ICreateRelayRequest
         * @property {protos.common.IAuth|null} [auth] CreateRelayRequest auth
         * @property {protos.opts.IRelayOptions|null} [opts] CreateRelayRequest opts
         */

        /**
         * Constructs a new CreateRelayRequest.
         * @memberof protos
         * @classdesc Represents a CreateRelayRequest.
         * @implements ICreateRelayRequest
         * @constructor
         * @param {protos.ICreateRelayRequest=} [properties] Properties to set
         */
        function CreateRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateRelayRequest
         * @instance
         */
        CreateRelayRequest.prototype.auth = null;

        /**
         * CreateRelayRequest opts.
         * @member {protos.opts.IRelayOptions|null|undefined} opts
         * @memberof protos.CreateRelayRequest
         * @instance
         */
        CreateRelayRequest.prototype.opts = null;

        /**
         * Creates a new CreateRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.ICreateRelayRequest=} [properties] Properties to set
         * @returns {protos.CreateRelayRequest} CreateRelayRequest instance
         */
        CreateRelayRequest.create = function create(properties) {
            return new CreateRelayRequest(properties);
        };

        /**
         * Encodes the specified CreateRelayRequest message. Does not implicitly {@link protos.CreateRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.ICreateRelayRequest} message CreateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.RelayOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateRelayRequest message, length delimited. Does not implicitly {@link protos.CreateRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.ICreateRelayRequest} message CreateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateRelayRequest} CreateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateRelayRequest} CreateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateRelayRequest message.
         * @function verify
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.RelayOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a CreateRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateRelayRequest} CreateRelayRequest
         */
        CreateRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateRelayRequest)
                return object;
            var message = new $root.protos.CreateRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.CreateRelayRequest.opts: object expected");
                message.opts = $root.protos.opts.RelayOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.CreateRelayRequest} message CreateRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.auth = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.RelayOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateRelayRequest;
    })();

    protos.CreateRelayResponse = (function() {

        /**
         * Properties of a CreateRelayResponse.
         * @memberof protos
         * @interface ICreateRelayResponse
         * @property {protos.common.IStatus|null} [status] CreateRelayResponse status
         * @property {string|null} [relayId] CreateRelayResponse relayId
         */

        /**
         * Constructs a new CreateRelayResponse.
         * @memberof protos
         * @classdesc Represents a CreateRelayResponse.
         * @implements ICreateRelayResponse
         * @constructor
         * @param {protos.ICreateRelayResponse=} [properties] Properties to set
         */
        function CreateRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.CreateRelayResponse
         * @instance
         */
        CreateRelayResponse.prototype.status = null;

        /**
         * CreateRelayResponse relayId.
         * @member {string} relayId
         * @memberof protos.CreateRelayResponse
         * @instance
         */
        CreateRelayResponse.prototype.relayId = "";

        /**
         * Creates a new CreateRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.ICreateRelayResponse=} [properties] Properties to set
         * @returns {protos.CreateRelayResponse} CreateRelayResponse instance
         */
        CreateRelayResponse.create = function create(properties) {
            return new CreateRelayResponse(properties);
        };

        /**
         * Encodes the specified CreateRelayResponse message. Does not implicitly {@link protos.CreateRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.ICreateRelayResponse} message CreateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateRelayResponse message, length delimited. Does not implicitly {@link protos.CreateRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.ICreateRelayResponse} message CreateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateRelayResponse} CreateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateRelayResponse} CreateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateRelayResponse message.
         * @function verify
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a CreateRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateRelayResponse} CreateRelayResponse
         */
        CreateRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateRelayResponse)
                return object;
            var message = new $root.protos.CreateRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.CreateRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a CreateRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.CreateRelayResponse} message CreateRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.status = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this CreateRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateRelayResponse;
    })();

    protos.UpdateRelayRequest = (function() {

        /**
         * Properties of an UpdateRelayRequest.
         * @memberof protos
         * @interface IUpdateRelayRequest
         * @property {protos.common.IAuth|null} [auth] UpdateRelayRequest auth
         * @property {string|null} [relayId] UpdateRelayRequest relayId
         * @property {protos.opts.IRelayOptions|null} [opts] UpdateRelayRequest opts
         */

        /**
         * Constructs a new UpdateRelayRequest.
         * @memberof protos
         * @classdesc Represents an UpdateRelayRequest.
         * @implements IUpdateRelayRequest
         * @constructor
         * @param {protos.IUpdateRelayRequest=} [properties] Properties to set
         */
        function UpdateRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateRelayRequest
         * @instance
         */
        UpdateRelayRequest.prototype.auth = null;

        /**
         * UpdateRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.UpdateRelayRequest
         * @instance
         */
        UpdateRelayRequest.prototype.relayId = "";

        /**
         * UpdateRelayRequest opts.
         * @member {protos.opts.IRelayOptions|null|undefined} opts
         * @memberof protos.UpdateRelayRequest
         * @instance
         */
        UpdateRelayRequest.prototype.opts = null;

        /**
         * Creates a new UpdateRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.IUpdateRelayRequest=} [properties] Properties to set
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest instance
         */
        UpdateRelayRequest.create = function create(properties) {
            return new UpdateRelayRequest(properties);
        };

        /**
         * Encodes the specified UpdateRelayRequest message. Does not implicitly {@link protos.UpdateRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.IUpdateRelayRequest} message UpdateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.RelayOptions.encode(message.opts, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateRelayRequest message, length delimited. Does not implicitly {@link protos.UpdateRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.IUpdateRelayRequest} message UpdateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                case 2:
                    message.opts = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateRelayRequest message.
         * @function verify
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.RelayOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest
         */
        UpdateRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateRelayRequest)
                return object;
            var message = new $root.protos.UpdateRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.UpdateRelayRequest.opts: object expected");
                message.opts = $root.protos.opts.RelayOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.UpdateRelayRequest} message UpdateRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.opts = null;
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.RelayOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateRelayRequest;
    })();

    protos.UpdateRelayResponse = (function() {

        /**
         * Properties of an UpdateRelayResponse.
         * @memberof protos
         * @interface IUpdateRelayResponse
         * @property {protos.common.IStatus|null} [status] UpdateRelayResponse status
         */

        /**
         * Constructs a new UpdateRelayResponse.
         * @memberof protos
         * @classdesc Represents an UpdateRelayResponse.
         * @implements IUpdateRelayResponse
         * @constructor
         * @param {protos.IUpdateRelayResponse=} [properties] Properties to set
         */
        function UpdateRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateRelayResponse
         * @instance
         */
        UpdateRelayResponse.prototype.status = null;

        /**
         * Creates a new UpdateRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.IUpdateRelayResponse=} [properties] Properties to set
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse instance
         */
        UpdateRelayResponse.create = function create(properties) {
            return new UpdateRelayResponse(properties);
        };

        /**
         * Encodes the specified UpdateRelayResponse message. Does not implicitly {@link protos.UpdateRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.IUpdateRelayResponse} message UpdateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateRelayResponse message, length delimited. Does not implicitly {@link protos.UpdateRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.IUpdateRelayResponse} message UpdateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateRelayResponse message.
         * @function verify
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse
         */
        UpdateRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateRelayResponse)
                return object;
            var message = new $root.protos.UpdateRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.UpdateRelayResponse} message UpdateRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateRelayResponse;
    })();

    protos.ResumeRelayRequest = (function() {

        /**
         * Properties of a ResumeRelayRequest.
         * @memberof protos
         * @interface IResumeRelayRequest
         * @property {protos.common.IAuth|null} [auth] ResumeRelayRequest auth
         * @property {string|null} [relayId] ResumeRelayRequest relayId
         */

        /**
         * Constructs a new ResumeRelayRequest.
         * @memberof protos
         * @classdesc Represents a ResumeRelayRequest.
         * @implements IResumeRelayRequest
         * @constructor
         * @param {protos.IResumeRelayRequest=} [properties] Properties to set
         */
        function ResumeRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.ResumeRelayRequest
         * @instance
         */
        ResumeRelayRequest.prototype.auth = null;

        /**
         * ResumeRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.ResumeRelayRequest
         * @instance
         */
        ResumeRelayRequest.prototype.relayId = "";

        /**
         * Creates a new ResumeRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.IResumeRelayRequest=} [properties] Properties to set
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest instance
         */
        ResumeRelayRequest.create = function create(properties) {
            return new ResumeRelayRequest(properties);
        };

        /**
         * Encodes the specified ResumeRelayRequest message. Does not implicitly {@link protos.ResumeRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.IResumeRelayRequest} message ResumeRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeRelayRequest message, length delimited. Does not implicitly {@link protos.ResumeRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.IResumeRelayRequest} message ResumeRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeRelayRequest message.
         * @function verify
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a ResumeRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest
         */
        ResumeRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeRelayRequest)
                return object;
            var message = new $root.protos.ResumeRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.ResumeRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a ResumeRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.ResumeRelayRequest} message ResumeRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ResumeRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.ResumeRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeRelayRequest;
    })();

    protos.ResumeRelayResponse = (function() {

        /**
         * Properties of a ResumeRelayResponse.
         * @memberof protos
         * @interface IResumeRelayResponse
         * @property {protos.common.IStatus|null} [status] ResumeRelayResponse status
         */

        /**
         * Constructs a new ResumeRelayResponse.
         * @memberof protos
         * @classdesc Represents a ResumeRelayResponse.
         * @implements IResumeRelayResponse
         * @constructor
         * @param {protos.IResumeRelayResponse=} [properties] Properties to set
         */
        function ResumeRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.ResumeRelayResponse
         * @instance
         */
        ResumeRelayResponse.prototype.status = null;

        /**
         * Creates a new ResumeRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.IResumeRelayResponse=} [properties] Properties to set
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse instance
         */
        ResumeRelayResponse.create = function create(properties) {
            return new ResumeRelayResponse(properties);
        };

        /**
         * Encodes the specified ResumeRelayResponse message. Does not implicitly {@link protos.ResumeRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.IResumeRelayResponse} message ResumeRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeRelayResponse message, length delimited. Does not implicitly {@link protos.ResumeRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.IResumeRelayResponse} message ResumeRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeRelayResponse message.
         * @function verify
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a ResumeRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse
         */
        ResumeRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeRelayResponse)
                return object;
            var message = new $root.protos.ResumeRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.ResumeRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResumeRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.ResumeRelayResponse} message ResumeRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ResumeRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.ResumeRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeRelayResponse;
    })();

    protos.StopRelayRequest = (function() {

        /**
         * Properties of a StopRelayRequest.
         * @memberof protos
         * @interface IStopRelayRequest
         * @property {protos.common.IAuth|null} [auth] StopRelayRequest auth
         * @property {string|null} [relayId] StopRelayRequest relayId
         */

        /**
         * Constructs a new StopRelayRequest.
         * @memberof protos
         * @classdesc Represents a StopRelayRequest.
         * @implements IStopRelayRequest
         * @constructor
         * @param {protos.IStopRelayRequest=} [properties] Properties to set
         */
        function StopRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.StopRelayRequest
         * @instance
         */
        StopRelayRequest.prototype.auth = null;

        /**
         * StopRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.StopRelayRequest
         * @instance
         */
        StopRelayRequest.prototype.relayId = "";

        /**
         * Creates a new StopRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.IStopRelayRequest=} [properties] Properties to set
         * @returns {protos.StopRelayRequest} StopRelayRequest instance
         */
        StopRelayRequest.create = function create(properties) {
            return new StopRelayRequest(properties);
        };

        /**
         * Encodes the specified StopRelayRequest message. Does not implicitly {@link protos.StopRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.IStopRelayRequest} message StopRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopRelayRequest message, length delimited. Does not implicitly {@link protos.StopRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.IStopRelayRequest} message StopRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopRelayRequest} StopRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopRelayRequest} StopRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopRelayRequest message.
         * @function verify
         * @memberof protos.StopRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a StopRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopRelayRequest} StopRelayRequest
         */
        StopRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopRelayRequest)
                return object;
            var message = new $root.protos.StopRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.StopRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a StopRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.StopRelayRequest} message StopRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this StopRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.StopRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopRelayRequest;
    })();

    protos.StopRelayResponse = (function() {

        /**
         * Properties of a StopRelayResponse.
         * @memberof protos
         * @interface IStopRelayResponse
         * @property {protos.common.IStatus|null} [status] StopRelayResponse status
         */

        /**
         * Constructs a new StopRelayResponse.
         * @memberof protos
         * @classdesc Represents a StopRelayResponse.
         * @implements IStopRelayResponse
         * @constructor
         * @param {protos.IStopRelayResponse=} [properties] Properties to set
         */
        function StopRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.StopRelayResponse
         * @instance
         */
        StopRelayResponse.prototype.status = null;

        /**
         * Creates a new StopRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.IStopRelayResponse=} [properties] Properties to set
         * @returns {protos.StopRelayResponse} StopRelayResponse instance
         */
        StopRelayResponse.create = function create(properties) {
            return new StopRelayResponse(properties);
        };

        /**
         * Encodes the specified StopRelayResponse message. Does not implicitly {@link protos.StopRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.IStopRelayResponse} message StopRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopRelayResponse message, length delimited. Does not implicitly {@link protos.StopRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.IStopRelayResponse} message StopRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopRelayResponse} StopRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopRelayResponse} StopRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopRelayResponse message.
         * @function verify
         * @memberof protos.StopRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a StopRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopRelayResponse} StopRelayResponse
         */
        StopRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopRelayResponse)
                return object;
            var message = new $root.protos.StopRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.StopRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a StopRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.StopRelayResponse} message StopRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this StopRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.StopRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopRelayResponse;
    })();

    protos.DeleteRelayRequest = (function() {

        /**
         * Properties of a DeleteRelayRequest.
         * @memberof protos
         * @interface IDeleteRelayRequest
         * @property {protos.common.IAuth|null} [auth] DeleteRelayRequest auth
         * @property {string|null} [relayId] DeleteRelayRequest relayId
         */

        /**
         * Constructs a new DeleteRelayRequest.
         * @memberof protos
         * @classdesc Represents a DeleteRelayRequest.
         * @implements IDeleteRelayRequest
         * @constructor
         * @param {protos.IDeleteRelayRequest=} [properties] Properties to set
         */
        function DeleteRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteRelayRequest
         * @instance
         */
        DeleteRelayRequest.prototype.auth = null;

        /**
         * DeleteRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.DeleteRelayRequest
         * @instance
         */
        DeleteRelayRequest.prototype.relayId = "";

        /**
         * Creates a new DeleteRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.IDeleteRelayRequest=} [properties] Properties to set
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest instance
         */
        DeleteRelayRequest.create = function create(properties) {
            return new DeleteRelayRequest(properties);
        };

        /**
         * Encodes the specified DeleteRelayRequest message. Does not implicitly {@link protos.DeleteRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.IDeleteRelayRequest} message DeleteRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteRelayRequest message, length delimited. Does not implicitly {@link protos.DeleteRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.IDeleteRelayRequest} message DeleteRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteRelayRequest message.
         * @function verify
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a DeleteRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest
         */
        DeleteRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteRelayRequest)
                return object;
            var message = new $root.protos.DeleteRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.DeleteRelayRequest} message DeleteRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteRelayRequest;
    })();

    protos.DeleteRelayResponse = (function() {

        /**
         * Properties of a DeleteRelayResponse.
         * @memberof protos
         * @interface IDeleteRelayResponse
         * @property {protos.common.IStatus|null} [status] DeleteRelayResponse status
         */

        /**
         * Constructs a new DeleteRelayResponse.
         * @memberof protos
         * @classdesc Represents a DeleteRelayResponse.
         * @implements IDeleteRelayResponse
         * @constructor
         * @param {protos.IDeleteRelayResponse=} [properties] Properties to set
         */
        function DeleteRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteRelayResponse
         * @instance
         */
        DeleteRelayResponse.prototype.status = null;

        /**
         * Creates a new DeleteRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.IDeleteRelayResponse=} [properties] Properties to set
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse instance
         */
        DeleteRelayResponse.create = function create(properties) {
            return new DeleteRelayResponse(properties);
        };

        /**
         * Encodes the specified DeleteRelayResponse message. Does not implicitly {@link protos.DeleteRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.IDeleteRelayResponse} message DeleteRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteRelayResponse message, length delimited. Does not implicitly {@link protos.DeleteRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.IDeleteRelayResponse} message DeleteRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteRelayResponse message.
         * @function verify
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse
         */
        DeleteRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteRelayResponse)
                return object;
            var message = new $root.protos.DeleteRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.DeleteRelayResponse} message DeleteRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteRelayResponse;
    })();

    protos.Schema = (function() {

        /**
         * Properties of a Schema.
         * @memberof protos
         * @interface ISchema
         * @property {string|null} [id] Schema id
         * @property {string|null} [name] Schema name
         * @property {protos.SchemaType|null} [type] Schema type
         * @property {string|null} [notes] Schema notes
         * @property {string|null} [ownerId] Schema ownerId
         * @property {Array.<protos.ISchemaVersion>|null} [versions] Schema versions
         * @property {protos.encoding.IJSONSchemaSettings|null} [inferredSchema] Schema inferredSchema
         */

        /**
         * Constructs a new Schema.
         * @memberof protos
         * @classdesc Represents a Schema.
         * @implements ISchema
         * @constructor
         * @param {protos.ISchema=} [properties] Properties to set
         */
        function Schema(properties) {
            this.versions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Schema id.
         * @member {string} id
         * @memberof protos.Schema
         * @instance
         */
        Schema.prototype.id = "";

        /**
         * Schema name.
         * @member {string} name
         * @memberof protos.Schema
         * @instance
         */
        Schema.prototype.name = "";

        /**
         * Schema type.
         * @member {protos.SchemaType} type
         * @memberof protos.Schema
         * @instance
         */
        Schema.prototype.type = 0;

        /**
         * Schema notes.
         * @member {string} notes
         * @memberof protos.Schema
         * @instance
         */
        Schema.prototype.notes = "";

        /**
         * Schema ownerId.
         * @member {string} ownerId
         * @memberof protos.Schema
         * @instance
         */
        Schema.prototype.ownerId = "";

        /**
         * Schema versions.
         * @member {Array.<protos.ISchemaVersion>} versions
         * @memberof protos.Schema
         * @instance
         */
        Schema.prototype.versions = $util.emptyArray;

        /**
         * Schema inferredSchema.
         * @member {protos.encoding.IJSONSchemaSettings|null|undefined} inferredSchema
         * @memberof protos.Schema
         * @instance
         */
        Schema.prototype.inferredSchema = null;

        /**
         * Creates a new Schema instance using the specified properties.
         * @function create
         * @memberof protos.Schema
         * @static
         * @param {protos.ISchema=} [properties] Properties to set
         * @returns {protos.Schema} Schema instance
         */
        Schema.create = function create(properties) {
            return new Schema(properties);
        };

        /**
         * Encodes the specified Schema message. Does not implicitly {@link protos.Schema.verify|verify} messages.
         * @function encode
         * @memberof protos.Schema
         * @static
         * @param {protos.ISchema} message Schema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Schema.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.notes);
            if (message.ownerId != null && Object.hasOwnProperty.call(message, "ownerId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.ownerId);
            if (message.versions != null && message.versions.length)
                for (var i = 0; i < message.versions.length; ++i)
                    $root.protos.SchemaVersion.encode(message.versions[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.inferredSchema != null && Object.hasOwnProperty.call(message, "inferredSchema"))
                $root.protos.encoding.JSONSchemaSettings.encode(message.inferredSchema, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Schema message, length delimited. Does not implicitly {@link protos.Schema.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.Schema
         * @static
         * @param {protos.ISchema} message Schema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Schema.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Schema message from the specified reader or buffer.
         * @function decode
         * @memberof protos.Schema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.Schema} Schema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Schema.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Schema();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.notes = reader.string();
                    break;
                case 5:
                    message.ownerId = reader.string();
                    break;
                case 6:
                    if (!(message.versions && message.versions.length))
                        message.versions = [];
                    message.versions.push($root.protos.SchemaVersion.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.inferredSchema = $root.protos.encoding.JSONSchemaSettings.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Schema message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.Schema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.Schema} Schema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Schema.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Schema message.
         * @function verify
         * @memberof protos.Schema
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Schema.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.notes != null && message.hasOwnProperty("notes"))
                if (!$util.isString(message.notes))
                    return "notes: string expected";
            if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                if (!$util.isString(message.ownerId))
                    return "ownerId: string expected";
            if (message.versions != null && message.hasOwnProperty("versions")) {
                if (!Array.isArray(message.versions))
                    return "versions: array expected";
                for (var i = 0; i < message.versions.length; ++i) {
                    var error = $root.protos.SchemaVersion.verify(message.versions[i]);
                    if (error)
                        return "versions." + error;
                }
            }
            if (message.inferredSchema != null && message.hasOwnProperty("inferredSchema")) {
                var error = $root.protos.encoding.JSONSchemaSettings.verify(message.inferredSchema);
                if (error)
                    return "inferredSchema." + error;
            }
            return null;
        };

        /**
         * Creates a Schema message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.Schema
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.Schema} Schema
         */
        Schema.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.Schema)
                return object;
            var message = new $root.protos.Schema();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            case "SCHEMA_TYPE_UNSET":
            case 0:
                message.type = 0;
                break;
            case "SCHEMA_TYPE_PROTOBUF":
            case 1:
                message.type = 1;
                break;
            case "SCHEMA_TYPE_AVRO":
            case 2:
                message.type = 2;
                break;
            case "SCHEMA_TYPE_JSONSCHEMA":
            case 3:
                message.type = 3;
                break;
            }
            if (object.notes != null)
                message.notes = String(object.notes);
            if (object.ownerId != null)
                message.ownerId = String(object.ownerId);
            if (object.versions) {
                if (!Array.isArray(object.versions))
                    throw TypeError(".protos.Schema.versions: array expected");
                message.versions = [];
                for (var i = 0; i < object.versions.length; ++i) {
                    if (typeof object.versions[i] !== "object")
                        throw TypeError(".protos.Schema.versions: object expected");
                    message.versions[i] = $root.protos.SchemaVersion.fromObject(object.versions[i]);
                }
            }
            if (object.inferredSchema != null) {
                if (typeof object.inferredSchema !== "object")
                    throw TypeError(".protos.Schema.inferredSchema: object expected");
                message.inferredSchema = $root.protos.encoding.JSONSchemaSettings.fromObject(object.inferredSchema);
            }
            return message;
        };

        /**
         * Creates a plain object from a Schema message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.Schema
         * @static
         * @param {protos.Schema} message Schema
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Schema.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.versions = [];
            if (options.defaults) {
                object.id = "";
                object.name = "";
                object.type = options.enums === String ? "SCHEMA_TYPE_UNSET" : 0;
                object.notes = "";
                object.ownerId = "";
                object.inferredSchema = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protos.SchemaType[message.type] : message.type;
            if (message.notes != null && message.hasOwnProperty("notes"))
                object.notes = message.notes;
            if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                object.ownerId = message.ownerId;
            if (message.versions && message.versions.length) {
                object.versions = [];
                for (var j = 0; j < message.versions.length; ++j)
                    object.versions[j] = $root.protos.SchemaVersion.toObject(message.versions[j], options);
            }
            if (message.inferredSchema != null && message.hasOwnProperty("inferredSchema"))
                object.inferredSchema = $root.protos.encoding.JSONSchemaSettings.toObject(message.inferredSchema, options);
            return object;
        };

        /**
         * Converts this Schema to JSON.
         * @function toJSON
         * @memberof protos.Schema
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Schema.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Schema;
    })();

    protos.SchemaVersion = (function() {

        /**
         * Properties of a SchemaVersion.
         * @memberof protos
         * @interface ISchemaVersion
         * @property {number|null} [version] SchemaVersion version
         * @property {protos.SchemaStatus|null} [status] SchemaVersion status
         * @property {Object.<string,string>|null} [files] SchemaVersion files
         * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] SchemaVersion protobufSettings
         * @property {protos.encoding.IAvroSettings|null} [avroSettings] SchemaVersion avroSettings
         * @property {protos.encoding.IJSONSchemaSettings|null} [jsonSchemaSettings] SchemaVersion jsonSchemaSettings
         */

        /**
         * Constructs a new SchemaVersion.
         * @memberof protos
         * @classdesc Represents a SchemaVersion.
         * @implements ISchemaVersion
         * @constructor
         * @param {protos.ISchemaVersion=} [properties] Properties to set
         */
        function SchemaVersion(properties) {
            this.files = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SchemaVersion version.
         * @member {number} version
         * @memberof protos.SchemaVersion
         * @instance
         */
        SchemaVersion.prototype.version = 0;

        /**
         * SchemaVersion status.
         * @member {protos.SchemaStatus} status
         * @memberof protos.SchemaVersion
         * @instance
         */
        SchemaVersion.prototype.status = 0;

        /**
         * SchemaVersion files.
         * @member {Object.<string,string>} files
         * @memberof protos.SchemaVersion
         * @instance
         */
        SchemaVersion.prototype.files = $util.emptyObject;

        /**
         * SchemaVersion protobufSettings.
         * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
         * @memberof protos.SchemaVersion
         * @instance
         */
        SchemaVersion.prototype.protobufSettings = null;

        /**
         * SchemaVersion avroSettings.
         * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
         * @memberof protos.SchemaVersion
         * @instance
         */
        SchemaVersion.prototype.avroSettings = null;

        /**
         * SchemaVersion jsonSchemaSettings.
         * @member {protos.encoding.IJSONSchemaSettings|null|undefined} jsonSchemaSettings
         * @memberof protos.SchemaVersion
         * @instance
         */
        SchemaVersion.prototype.jsonSchemaSettings = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SchemaVersion settings.
         * @member {"protobufSettings"|"avroSettings"|"jsonSchemaSettings"|undefined} settings
         * @memberof protos.SchemaVersion
         * @instance
         */
        Object.defineProperty(SchemaVersion.prototype, "settings", {
            get: $util.oneOfGetter($oneOfFields = ["protobufSettings", "avroSettings", "jsonSchemaSettings"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SchemaVersion instance using the specified properties.
         * @function create
         * @memberof protos.SchemaVersion
         * @static
         * @param {protos.ISchemaVersion=} [properties] Properties to set
         * @returns {protos.SchemaVersion} SchemaVersion instance
         */
        SchemaVersion.create = function create(properties) {
            return new SchemaVersion(properties);
        };

        /**
         * Encodes the specified SchemaVersion message. Does not implicitly {@link protos.SchemaVersion.verify|verify} messages.
         * @function encode
         * @memberof protos.SchemaVersion
         * @static
         * @param {protos.ISchemaVersion} message SchemaVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SchemaVersion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.files != null && Object.hasOwnProperty.call(message, "files"))
                for (var keys = Object.keys(message.files), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.files[keys[i]]).ldelim();
            if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
            if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.jsonSchemaSettings != null && Object.hasOwnProperty.call(message, "jsonSchemaSettings"))
                $root.protos.encoding.JSONSchemaSettings.encode(message.jsonSchemaSettings, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SchemaVersion message, length delimited. Does not implicitly {@link protos.SchemaVersion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.SchemaVersion
         * @static
         * @param {protos.ISchemaVersion} message SchemaVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SchemaVersion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SchemaVersion message from the specified reader or buffer.
         * @function decode
         * @memberof protos.SchemaVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.SchemaVersion} SchemaVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SchemaVersion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.SchemaVersion(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.int32();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                case 3:
                    if (message.files === $util.emptyObject)
                        message.files = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = "";
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.string();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.files[key] = value;
                    break;
                case 100:
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                    break;
                case 101:
                    message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.jsonSchemaSettings = $root.protos.encoding.JSONSchemaSettings.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SchemaVersion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.SchemaVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.SchemaVersion} SchemaVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SchemaVersion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SchemaVersion message.
         * @function verify
         * @memberof protos.SchemaVersion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SchemaVersion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.files != null && message.hasOwnProperty("files")) {
                if (!$util.isObject(message.files))
                    return "files: object expected";
                var key = Object.keys(message.files);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.files[key[i]]))
                        return "files: string{k:string} expected";
            }
            if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                properties.settings = 1;
                {
                    var error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
            }
            if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                if (properties.settings === 1)
                    return "settings: multiple values";
                properties.settings = 1;
                {
                    var error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
            }
            if (message.jsonSchemaSettings != null && message.hasOwnProperty("jsonSchemaSettings")) {
                if (properties.settings === 1)
                    return "settings: multiple values";
                properties.settings = 1;
                {
                    var error = $root.protos.encoding.JSONSchemaSettings.verify(message.jsonSchemaSettings);
                    if (error)
                        return "jsonSchemaSettings." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SchemaVersion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.SchemaVersion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.SchemaVersion} SchemaVersion
         */
        SchemaVersion.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.SchemaVersion)
                return object;
            var message = new $root.protos.SchemaVersion();
            if (object.version != null)
                message.version = object.version | 0;
            switch (object.status) {
            case "SCHEMA_STATUS_UNSET":
            case 0:
                message.status = 0;
                break;
            case "SCHEMA_STATUS_ACCEPTED":
            case 1:
                message.status = 1;
                break;
            case "SCHEMA_STATUS_PROPOSED":
            case 2:
                message.status = 2;
                break;
            }
            if (object.files) {
                if (typeof object.files !== "object")
                    throw TypeError(".protos.SchemaVersion.files: object expected");
                message.files = {};
                for (var keys = Object.keys(object.files), i = 0; i < keys.length; ++i)
                    message.files[keys[i]] = String(object.files[keys[i]]);
            }
            if (object.protobufSettings != null) {
                if (typeof object.protobufSettings !== "object")
                    throw TypeError(".protos.SchemaVersion.protobufSettings: object expected");
                message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
            }
            if (object.avroSettings != null) {
                if (typeof object.avroSettings !== "object")
                    throw TypeError(".protos.SchemaVersion.avroSettings: object expected");
                message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
            }
            if (object.jsonSchemaSettings != null) {
                if (typeof object.jsonSchemaSettings !== "object")
                    throw TypeError(".protos.SchemaVersion.jsonSchemaSettings: object expected");
                message.jsonSchemaSettings = $root.protos.encoding.JSONSchemaSettings.fromObject(object.jsonSchemaSettings);
            }
            return message;
        };

        /**
         * Creates a plain object from a SchemaVersion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.SchemaVersion
         * @static
         * @param {protos.SchemaVersion} message SchemaVersion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SchemaVersion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.files = {};
            if (options.defaults) {
                object.version = 0;
                object.status = options.enums === String ? "SCHEMA_STATUS_UNSET" : 0;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.protos.SchemaStatus[message.status] : message.status;
            var keys2;
            if (message.files && (keys2 = Object.keys(message.files)).length) {
                object.files = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.files[keys2[j]] = message.files[keys2[j]];
            }
            if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (options.oneofs)
                    object.settings = "protobufSettings";
            }
            if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                if (options.oneofs)
                    object.settings = "avroSettings";
            }
            if (message.jsonSchemaSettings != null && message.hasOwnProperty("jsonSchemaSettings")) {
                object.jsonSchemaSettings = $root.protos.encoding.JSONSchemaSettings.toObject(message.jsonSchemaSettings, options);
                if (options.oneofs)
                    object.settings = "jsonSchemaSettings";
            }
            return object;
        };

        /**
         * Converts this SchemaVersion to JSON.
         * @function toJSON
         * @memberof protos.SchemaVersion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SchemaVersion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SchemaVersion;
    })();

    /**
     * SchemaStatus enum.
     * @name protos.SchemaStatus
     * @enum {number}
     * @property {number} SCHEMA_STATUS_UNSET=0 SCHEMA_STATUS_UNSET value
     * @property {number} SCHEMA_STATUS_ACCEPTED=1 SCHEMA_STATUS_ACCEPTED value
     * @property {number} SCHEMA_STATUS_PROPOSED=2 SCHEMA_STATUS_PROPOSED value
     */
    protos.SchemaStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SCHEMA_STATUS_UNSET"] = 0;
        values[valuesById[1] = "SCHEMA_STATUS_ACCEPTED"] = 1;
        values[valuesById[2] = "SCHEMA_STATUS_PROPOSED"] = 2;
        return values;
    })();

    /**
     * SchemaType enum.
     * @name protos.SchemaType
     * @enum {number}
     * @property {number} SCHEMA_TYPE_UNSET=0 SCHEMA_TYPE_UNSET value
     * @property {number} SCHEMA_TYPE_PROTOBUF=1 SCHEMA_TYPE_PROTOBUF value
     * @property {number} SCHEMA_TYPE_AVRO=2 SCHEMA_TYPE_AVRO value
     * @property {number} SCHEMA_TYPE_JSONSCHEMA=3 SCHEMA_TYPE_JSONSCHEMA value
     */
    protos.SchemaType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SCHEMA_TYPE_UNSET"] = 0;
        values[valuesById[1] = "SCHEMA_TYPE_PROTOBUF"] = 1;
        values[valuesById[2] = "SCHEMA_TYPE_AVRO"] = 2;
        values[valuesById[3] = "SCHEMA_TYPE_JSONSCHEMA"] = 3;
        return values;
    })();

    protos.GetSchemaRequest = (function() {

        /**
         * Properties of a GetSchemaRequest.
         * @memberof protos
         * @interface IGetSchemaRequest
         * @property {protos.common.IAuth|null} [auth] GetSchemaRequest auth
         * @property {string|null} [id] GetSchemaRequest id
         */

        /**
         * Constructs a new GetSchemaRequest.
         * @memberof protos
         * @classdesc Represents a GetSchemaRequest.
         * @implements IGetSchemaRequest
         * @constructor
         * @param {protos.IGetSchemaRequest=} [properties] Properties to set
         */
        function GetSchemaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSchemaRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.auth = null;

        /**
         * GetSchemaRequest id.
         * @member {string} id
         * @memberof protos.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.id = "";

        /**
         * Creates a new GetSchemaRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetSchemaRequest
         * @static
         * @param {protos.IGetSchemaRequest=} [properties] Properties to set
         * @returns {protos.GetSchemaRequest} GetSchemaRequest instance
         */
        GetSchemaRequest.create = function create(properties) {
            return new GetSchemaRequest(properties);
        };

        /**
         * Encodes the specified GetSchemaRequest message. Does not implicitly {@link protos.GetSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetSchemaRequest
         * @static
         * @param {protos.IGetSchemaRequest} message GetSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetSchemaRequest message, length delimited. Does not implicitly {@link protos.GetSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetSchemaRequest
         * @static
         * @param {protos.IGetSchemaRequest} message GetSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetSchemaRequest} GetSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetSchemaRequest} GetSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSchemaRequest message.
         * @function verify
         * @memberof protos.GetSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a GetSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetSchemaRequest} GetSchemaRequest
         */
        GetSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetSchemaRequest)
                return object;
            var message = new $root.protos.GetSchemaRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetSchemaRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a GetSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetSchemaRequest
         * @static
         * @param {protos.GetSchemaRequest} message GetSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetSchemaRequest to JSON.
         * @function toJSON
         * @memberof protos.GetSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSchemaRequest;
    })();

    protos.GetSchemaResponse = (function() {

        /**
         * Properties of a GetSchemaResponse.
         * @memberof protos
         * @interface IGetSchemaResponse
         * @property {protos.ISchema|null} [schema] GetSchemaResponse schema
         */

        /**
         * Constructs a new GetSchemaResponse.
         * @memberof protos
         * @classdesc Represents a GetSchemaResponse.
         * @implements IGetSchemaResponse
         * @constructor
         * @param {protos.IGetSchemaResponse=} [properties] Properties to set
         */
        function GetSchemaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSchemaResponse schema.
         * @member {protos.ISchema|null|undefined} schema
         * @memberof protos.GetSchemaResponse
         * @instance
         */
        GetSchemaResponse.prototype.schema = null;

        /**
         * Creates a new GetSchemaResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetSchemaResponse
         * @static
         * @param {protos.IGetSchemaResponse=} [properties] Properties to set
         * @returns {protos.GetSchemaResponse} GetSchemaResponse instance
         */
        GetSchemaResponse.create = function create(properties) {
            return new GetSchemaResponse(properties);
        };

        /**
         * Encodes the specified GetSchemaResponse message. Does not implicitly {@link protos.GetSchemaResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetSchemaResponse
         * @static
         * @param {protos.IGetSchemaResponse} message GetSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                $root.protos.Schema.encode(message.schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetSchemaResponse message, length delimited. Does not implicitly {@link protos.GetSchemaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetSchemaResponse
         * @static
         * @param {protos.IGetSchemaResponse} message GetSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSchemaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetSchemaResponse} GetSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetSchemaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.schema = $root.protos.Schema.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSchemaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetSchemaResponse} GetSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSchemaResponse message.
         * @function verify
         * @memberof protos.GetSchemaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSchemaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.schema != null && message.hasOwnProperty("schema")) {
                var error = $root.protos.Schema.verify(message.schema);
                if (error)
                    return "schema." + error;
            }
            return null;
        };

        /**
         * Creates a GetSchemaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetSchemaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetSchemaResponse} GetSchemaResponse
         */
        GetSchemaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetSchemaResponse)
                return object;
            var message = new $root.protos.GetSchemaResponse();
            if (object.schema != null) {
                if (typeof object.schema !== "object")
                    throw TypeError(".protos.GetSchemaResponse.schema: object expected");
                message.schema = $root.protos.Schema.fromObject(object.schema);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSchemaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetSchemaResponse
         * @static
         * @param {protos.GetSchemaResponse} message GetSchemaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSchemaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.schema = null;
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = $root.protos.Schema.toObject(message.schema, options);
            return object;
        };

        /**
         * Converts this GetSchemaResponse to JSON.
         * @function toJSON
         * @memberof protos.GetSchemaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSchemaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSchemaResponse;
    })();

    protos.GetAllSchemasRequest = (function() {

        /**
         * Properties of a GetAllSchemasRequest.
         * @memberof protos
         * @interface IGetAllSchemasRequest
         * @property {protos.common.IAuth|null} [auth] GetAllSchemasRequest auth
         */

        /**
         * Constructs a new GetAllSchemasRequest.
         * @memberof protos
         * @classdesc Represents a GetAllSchemasRequest.
         * @implements IGetAllSchemasRequest
         * @constructor
         * @param {protos.IGetAllSchemasRequest=} [properties] Properties to set
         */
        function GetAllSchemasRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllSchemasRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllSchemasRequest
         * @instance
         */
        GetAllSchemasRequest.prototype.auth = null;

        /**
         * Creates a new GetAllSchemasRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllSchemasRequest
         * @static
         * @param {protos.IGetAllSchemasRequest=} [properties] Properties to set
         * @returns {protos.GetAllSchemasRequest} GetAllSchemasRequest instance
         */
        GetAllSchemasRequest.create = function create(properties) {
            return new GetAllSchemasRequest(properties);
        };

        /**
         * Encodes the specified GetAllSchemasRequest message. Does not implicitly {@link protos.GetAllSchemasRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllSchemasRequest
         * @static
         * @param {protos.IGetAllSchemasRequest} message GetAllSchemasRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllSchemasRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllSchemasRequest message, length delimited. Does not implicitly {@link protos.GetAllSchemasRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllSchemasRequest
         * @static
         * @param {protos.IGetAllSchemasRequest} message GetAllSchemasRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllSchemasRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllSchemasRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllSchemasRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllSchemasRequest} GetAllSchemasRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllSchemasRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllSchemasRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllSchemasRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllSchemasRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllSchemasRequest} GetAllSchemasRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllSchemasRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllSchemasRequest message.
         * @function verify
         * @memberof protos.GetAllSchemasRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllSchemasRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllSchemasRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllSchemasRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllSchemasRequest} GetAllSchemasRequest
         */
        GetAllSchemasRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllSchemasRequest)
                return object;
            var message = new $root.protos.GetAllSchemasRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllSchemasRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllSchemasRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllSchemasRequest
         * @static
         * @param {protos.GetAllSchemasRequest} message GetAllSchemasRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllSchemasRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllSchemasRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllSchemasRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllSchemasRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllSchemasRequest;
    })();

    protos.GetAllSchemasResponse = (function() {

        /**
         * Properties of a GetAllSchemasResponse.
         * @memberof protos
         * @interface IGetAllSchemasResponse
         * @property {Array.<protos.ISchema>|null} [schema] GetAllSchemasResponse schema
         */

        /**
         * Constructs a new GetAllSchemasResponse.
         * @memberof protos
         * @classdesc Represents a GetAllSchemasResponse.
         * @implements IGetAllSchemasResponse
         * @constructor
         * @param {protos.IGetAllSchemasResponse=} [properties] Properties to set
         */
        function GetAllSchemasResponse(properties) {
            this.schema = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllSchemasResponse schema.
         * @member {Array.<protos.ISchema>} schema
         * @memberof protos.GetAllSchemasResponse
         * @instance
         */
        GetAllSchemasResponse.prototype.schema = $util.emptyArray;

        /**
         * Creates a new GetAllSchemasResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllSchemasResponse
         * @static
         * @param {protos.IGetAllSchemasResponse=} [properties] Properties to set
         * @returns {protos.GetAllSchemasResponse} GetAllSchemasResponse instance
         */
        GetAllSchemasResponse.create = function create(properties) {
            return new GetAllSchemasResponse(properties);
        };

        /**
         * Encodes the specified GetAllSchemasResponse message. Does not implicitly {@link protos.GetAllSchemasResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllSchemasResponse
         * @static
         * @param {protos.IGetAllSchemasResponse} message GetAllSchemasResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllSchemasResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && message.schema.length)
                for (var i = 0; i < message.schema.length; ++i)
                    $root.protos.Schema.encode(message.schema[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllSchemasResponse message, length delimited. Does not implicitly {@link protos.GetAllSchemasResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllSchemasResponse
         * @static
         * @param {protos.IGetAllSchemasResponse} message GetAllSchemasResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllSchemasResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllSchemasResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllSchemasResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllSchemasResponse} GetAllSchemasResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllSchemasResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllSchemasResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.schema && message.schema.length))
                        message.schema = [];
                    message.schema.push($root.protos.Schema.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllSchemasResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllSchemasResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllSchemasResponse} GetAllSchemasResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllSchemasResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllSchemasResponse message.
         * @function verify
         * @memberof protos.GetAllSchemasResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllSchemasResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.schema != null && message.hasOwnProperty("schema")) {
                if (!Array.isArray(message.schema))
                    return "schema: array expected";
                for (var i = 0; i < message.schema.length; ++i) {
                    var error = $root.protos.Schema.verify(message.schema[i]);
                    if (error)
                        return "schema." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetAllSchemasResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllSchemasResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllSchemasResponse} GetAllSchemasResponse
         */
        GetAllSchemasResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllSchemasResponse)
                return object;
            var message = new $root.protos.GetAllSchemasResponse();
            if (object.schema) {
                if (!Array.isArray(object.schema))
                    throw TypeError(".protos.GetAllSchemasResponse.schema: array expected");
                message.schema = [];
                for (var i = 0; i < object.schema.length; ++i) {
                    if (typeof object.schema[i] !== "object")
                        throw TypeError(".protos.GetAllSchemasResponse.schema: object expected");
                    message.schema[i] = $root.protos.Schema.fromObject(object.schema[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllSchemasResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllSchemasResponse
         * @static
         * @param {protos.GetAllSchemasResponse} message GetAllSchemasResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllSchemasResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.schema = [];
            if (message.schema && message.schema.length) {
                object.schema = [];
                for (var j = 0; j < message.schema.length; ++j)
                    object.schema[j] = $root.protos.Schema.toObject(message.schema[j], options);
            }
            return object;
        };

        /**
         * Converts this GetAllSchemasResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllSchemasResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllSchemasResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllSchemasResponse;
    })();

    protos.ImportGithubRequest = (function() {

        /**
         * Properties of an ImportGithubRequest.
         * @memberof protos
         * @interface IImportGithubRequest
         * @property {protos.common.IAuth|null} [auth] ImportGithubRequest auth
         * @property {string|null} [name] ImportGithubRequest name
         * @property {protos.SchemaType|null} [type] ImportGithubRequest type
         * @property {string|null} [githubUrl] ImportGithubRequest githubUrl
         * @property {string|null} [_id] ImportGithubRequest _id
         */

        /**
         * Constructs a new ImportGithubRequest.
         * @memberof protos
         * @classdesc Represents an ImportGithubRequest.
         * @implements IImportGithubRequest
         * @constructor
         * @param {protos.IImportGithubRequest=} [properties] Properties to set
         */
        function ImportGithubRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportGithubRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.ImportGithubRequest
         * @instance
         */
        ImportGithubRequest.prototype.auth = null;

        /**
         * ImportGithubRequest name.
         * @member {string} name
         * @memberof protos.ImportGithubRequest
         * @instance
         */
        ImportGithubRequest.prototype.name = "";

        /**
         * ImportGithubRequest type.
         * @member {protos.SchemaType} type
         * @memberof protos.ImportGithubRequest
         * @instance
         */
        ImportGithubRequest.prototype.type = 0;

        /**
         * ImportGithubRequest githubUrl.
         * @member {string} githubUrl
         * @memberof protos.ImportGithubRequest
         * @instance
         */
        ImportGithubRequest.prototype.githubUrl = "";

        /**
         * ImportGithubRequest _id.
         * @member {string} _id
         * @memberof protos.ImportGithubRequest
         * @instance
         */
        ImportGithubRequest.prototype._id = "";

        /**
         * Creates a new ImportGithubRequest instance using the specified properties.
         * @function create
         * @memberof protos.ImportGithubRequest
         * @static
         * @param {protos.IImportGithubRequest=} [properties] Properties to set
         * @returns {protos.ImportGithubRequest} ImportGithubRequest instance
         */
        ImportGithubRequest.create = function create(properties) {
            return new ImportGithubRequest(properties);
        };

        /**
         * Encodes the specified ImportGithubRequest message. Does not implicitly {@link protos.ImportGithubRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ImportGithubRequest
         * @static
         * @param {protos.IImportGithubRequest} message ImportGithubRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportGithubRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.githubUrl != null && Object.hasOwnProperty.call(message, "githubUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.githubUrl);
            if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message._id);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportGithubRequest message, length delimited. Does not implicitly {@link protos.ImportGithubRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ImportGithubRequest
         * @static
         * @param {protos.IImportGithubRequest} message ImportGithubRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportGithubRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportGithubRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ImportGithubRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ImportGithubRequest} ImportGithubRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportGithubRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ImportGithubRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.githubUrl = reader.string();
                    break;
                case 4:
                    message._id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportGithubRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ImportGithubRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ImportGithubRequest} ImportGithubRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportGithubRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportGithubRequest message.
         * @function verify
         * @memberof protos.ImportGithubRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportGithubRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.githubUrl != null && message.hasOwnProperty("githubUrl"))
                if (!$util.isString(message.githubUrl))
                    return "githubUrl: string expected";
            if (message._id != null && message.hasOwnProperty("_id"))
                if (!$util.isString(message._id))
                    return "_id: string expected";
            return null;
        };

        /**
         * Creates an ImportGithubRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ImportGithubRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ImportGithubRequest} ImportGithubRequest
         */
        ImportGithubRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ImportGithubRequest)
                return object;
            var message = new $root.protos.ImportGithubRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.ImportGithubRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            case "SCHEMA_TYPE_UNSET":
            case 0:
                message.type = 0;
                break;
            case "SCHEMA_TYPE_PROTOBUF":
            case 1:
                message.type = 1;
                break;
            case "SCHEMA_TYPE_AVRO":
            case 2:
                message.type = 2;
                break;
            case "SCHEMA_TYPE_JSONSCHEMA":
            case 3:
                message.type = 3;
                break;
            }
            if (object.githubUrl != null)
                message.githubUrl = String(object.githubUrl);
            if (object._id != null)
                message._id = String(object._id);
            return message;
        };

        /**
         * Creates a plain object from an ImportGithubRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ImportGithubRequest
         * @static
         * @param {protos.ImportGithubRequest} message ImportGithubRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportGithubRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = options.enums === String ? "SCHEMA_TYPE_UNSET" : 0;
                object.githubUrl = "";
                object._id = "";
                object.auth = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protos.SchemaType[message.type] : message.type;
            if (message.githubUrl != null && message.hasOwnProperty("githubUrl"))
                object.githubUrl = message.githubUrl;
            if (message._id != null && message.hasOwnProperty("_id"))
                object._id = message._id;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ImportGithubRequest to JSON.
         * @function toJSON
         * @memberof protos.ImportGithubRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportGithubRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImportGithubRequest;
    })();

    protos.ImportGithubResponse = (function() {

        /**
         * Properties of an ImportGithubResponse.
         * @memberof protos
         * @interface IImportGithubResponse
         * @property {protos.common.IStatus|null} [status] ImportGithubResponse status
         * @property {string|null} [id] ImportGithubResponse id
         * @property {protos.IDirectory|null} [tree] ImportGithubResponse tree
         */

        /**
         * Constructs a new ImportGithubResponse.
         * @memberof protos
         * @classdesc Represents an ImportGithubResponse.
         * @implements IImportGithubResponse
         * @constructor
         * @param {protos.IImportGithubResponse=} [properties] Properties to set
         */
        function ImportGithubResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportGithubResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.ImportGithubResponse
         * @instance
         */
        ImportGithubResponse.prototype.status = null;

        /**
         * ImportGithubResponse id.
         * @member {string} id
         * @memberof protos.ImportGithubResponse
         * @instance
         */
        ImportGithubResponse.prototype.id = "";

        /**
         * ImportGithubResponse tree.
         * @member {protos.IDirectory|null|undefined} tree
         * @memberof protos.ImportGithubResponse
         * @instance
         */
        ImportGithubResponse.prototype.tree = null;

        /**
         * Creates a new ImportGithubResponse instance using the specified properties.
         * @function create
         * @memberof protos.ImportGithubResponse
         * @static
         * @param {protos.IImportGithubResponse=} [properties] Properties to set
         * @returns {protos.ImportGithubResponse} ImportGithubResponse instance
         */
        ImportGithubResponse.create = function create(properties) {
            return new ImportGithubResponse(properties);
        };

        /**
         * Encodes the specified ImportGithubResponse message. Does not implicitly {@link protos.ImportGithubResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ImportGithubResponse
         * @static
         * @param {protos.IImportGithubResponse} message ImportGithubResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportGithubResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.tree != null && Object.hasOwnProperty.call(message, "tree"))
                $root.protos.Directory.encode(message.tree, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportGithubResponse message, length delimited. Does not implicitly {@link protos.ImportGithubResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ImportGithubResponse
         * @static
         * @param {protos.IImportGithubResponse} message ImportGithubResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportGithubResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportGithubResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ImportGithubResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ImportGithubResponse} ImportGithubResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportGithubResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ImportGithubResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.tree = $root.protos.Directory.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportGithubResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ImportGithubResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ImportGithubResponse} ImportGithubResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportGithubResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportGithubResponse message.
         * @function verify
         * @memberof protos.ImportGithubResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportGithubResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.tree != null && message.hasOwnProperty("tree")) {
                var error = $root.protos.Directory.verify(message.tree);
                if (error)
                    return "tree." + error;
            }
            return null;
        };

        /**
         * Creates an ImportGithubResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ImportGithubResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ImportGithubResponse} ImportGithubResponse
         */
        ImportGithubResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ImportGithubResponse)
                return object;
            var message = new $root.protos.ImportGithubResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.ImportGithubResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.tree != null) {
                if (typeof object.tree !== "object")
                    throw TypeError(".protos.ImportGithubResponse.tree: object expected");
                message.tree = $root.protos.Directory.fromObject(object.tree);
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportGithubResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ImportGithubResponse
         * @static
         * @param {protos.ImportGithubResponse} message ImportGithubResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportGithubResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.tree = null;
                object.status = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.tree != null && message.hasOwnProperty("tree"))
                object.tree = $root.protos.Directory.toObject(message.tree, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ImportGithubResponse to JSON.
         * @function toJSON
         * @memberof protos.ImportGithubResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportGithubResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImportGithubResponse;
    })();

    protos.ImportGithubSelectRequest = (function() {

        /**
         * Properties of an ImportGithubSelectRequest.
         * @memberof protos
         * @interface IImportGithubSelectRequest
         * @property {protos.common.IAuth|null} [auth] ImportGithubSelectRequest auth
         * @property {string|null} [importId] ImportGithubSelectRequest importId
         * @property {string|null} [schemaFileName] ImportGithubSelectRequest schemaFileName
         * @property {string|null} [schemaFileSha] ImportGithubSelectRequest schemaFileSha
         * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] ImportGithubSelectRequest protobufSettings
         * @property {protos.encoding.IAvroSettings|null} [avroSettings] ImportGithubSelectRequest avroSettings
         * @property {protos.encoding.IJSONSchemaSettings|null} [jsonSchemaSettings] ImportGithubSelectRequest jsonSchemaSettings
         */

        /**
         * Constructs a new ImportGithubSelectRequest.
         * @memberof protos
         * @classdesc Represents an ImportGithubSelectRequest.
         * @implements IImportGithubSelectRequest
         * @constructor
         * @param {protos.IImportGithubSelectRequest=} [properties] Properties to set
         */
        function ImportGithubSelectRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportGithubSelectRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.ImportGithubSelectRequest
         * @instance
         */
        ImportGithubSelectRequest.prototype.auth = null;

        /**
         * ImportGithubSelectRequest importId.
         * @member {string} importId
         * @memberof protos.ImportGithubSelectRequest
         * @instance
         */
        ImportGithubSelectRequest.prototype.importId = "";

        /**
         * ImportGithubSelectRequest schemaFileName.
         * @member {string} schemaFileName
         * @memberof protos.ImportGithubSelectRequest
         * @instance
         */
        ImportGithubSelectRequest.prototype.schemaFileName = "";

        /**
         * ImportGithubSelectRequest schemaFileSha.
         * @member {string} schemaFileSha
         * @memberof protos.ImportGithubSelectRequest
         * @instance
         */
        ImportGithubSelectRequest.prototype.schemaFileSha = "";

        /**
         * ImportGithubSelectRequest protobufSettings.
         * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
         * @memberof protos.ImportGithubSelectRequest
         * @instance
         */
        ImportGithubSelectRequest.prototype.protobufSettings = null;

        /**
         * ImportGithubSelectRequest avroSettings.
         * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
         * @memberof protos.ImportGithubSelectRequest
         * @instance
         */
        ImportGithubSelectRequest.prototype.avroSettings = null;

        /**
         * ImportGithubSelectRequest jsonSchemaSettings.
         * @member {protos.encoding.IJSONSchemaSettings|null|undefined} jsonSchemaSettings
         * @memberof protos.ImportGithubSelectRequest
         * @instance
         */
        ImportGithubSelectRequest.prototype.jsonSchemaSettings = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ImportGithubSelectRequest settings.
         * @member {"protobufSettings"|"avroSettings"|"jsonSchemaSettings"|undefined} settings
         * @memberof protos.ImportGithubSelectRequest
         * @instance
         */
        Object.defineProperty(ImportGithubSelectRequest.prototype, "settings", {
            get: $util.oneOfGetter($oneOfFields = ["protobufSettings", "avroSettings", "jsonSchemaSettings"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ImportGithubSelectRequest instance using the specified properties.
         * @function create
         * @memberof protos.ImportGithubSelectRequest
         * @static
         * @param {protos.IImportGithubSelectRequest=} [properties] Properties to set
         * @returns {protos.ImportGithubSelectRequest} ImportGithubSelectRequest instance
         */
        ImportGithubSelectRequest.create = function create(properties) {
            return new ImportGithubSelectRequest(properties);
        };

        /**
         * Encodes the specified ImportGithubSelectRequest message. Does not implicitly {@link protos.ImportGithubSelectRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ImportGithubSelectRequest
         * @static
         * @param {protos.IImportGithubSelectRequest} message ImportGithubSelectRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportGithubSelectRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.importId != null && Object.hasOwnProperty.call(message, "importId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.importId);
            if (message.schemaFileName != null && Object.hasOwnProperty.call(message, "schemaFileName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaFileName);
            if (message.schemaFileSha != null && Object.hasOwnProperty.call(message, "schemaFileSha"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaFileSha);
            if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
            if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.jsonSchemaSettings != null && Object.hasOwnProperty.call(message, "jsonSchemaSettings"))
                $root.protos.encoding.JSONSchemaSettings.encode(message.jsonSchemaSettings, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportGithubSelectRequest message, length delimited. Does not implicitly {@link protos.ImportGithubSelectRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ImportGithubSelectRequest
         * @static
         * @param {protos.IImportGithubSelectRequest} message ImportGithubSelectRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportGithubSelectRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportGithubSelectRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ImportGithubSelectRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ImportGithubSelectRequest} ImportGithubSelectRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportGithubSelectRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ImportGithubSelectRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.importId = reader.string();
                    break;
                case 2:
                    message.schemaFileName = reader.string();
                    break;
                case 3:
                    message.schemaFileSha = reader.string();
                    break;
                case 100:
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                    break;
                case 101:
                    message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.jsonSchemaSettings = $root.protos.encoding.JSONSchemaSettings.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportGithubSelectRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ImportGithubSelectRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ImportGithubSelectRequest} ImportGithubSelectRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportGithubSelectRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportGithubSelectRequest message.
         * @function verify
         * @memberof protos.ImportGithubSelectRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportGithubSelectRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.importId != null && message.hasOwnProperty("importId"))
                if (!$util.isString(message.importId))
                    return "importId: string expected";
            if (message.schemaFileName != null && message.hasOwnProperty("schemaFileName"))
                if (!$util.isString(message.schemaFileName))
                    return "schemaFileName: string expected";
            if (message.schemaFileSha != null && message.hasOwnProperty("schemaFileSha"))
                if (!$util.isString(message.schemaFileSha))
                    return "schemaFileSha: string expected";
            if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                properties.settings = 1;
                {
                    var error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
            }
            if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                if (properties.settings === 1)
                    return "settings: multiple values";
                properties.settings = 1;
                {
                    var error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
            }
            if (message.jsonSchemaSettings != null && message.hasOwnProperty("jsonSchemaSettings")) {
                if (properties.settings === 1)
                    return "settings: multiple values";
                properties.settings = 1;
                {
                    var error = $root.protos.encoding.JSONSchemaSettings.verify(message.jsonSchemaSettings);
                    if (error)
                        return "jsonSchemaSettings." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ImportGithubSelectRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ImportGithubSelectRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ImportGithubSelectRequest} ImportGithubSelectRequest
         */
        ImportGithubSelectRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ImportGithubSelectRequest)
                return object;
            var message = new $root.protos.ImportGithubSelectRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.ImportGithubSelectRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.importId != null)
                message.importId = String(object.importId);
            if (object.schemaFileName != null)
                message.schemaFileName = String(object.schemaFileName);
            if (object.schemaFileSha != null)
                message.schemaFileSha = String(object.schemaFileSha);
            if (object.protobufSettings != null) {
                if (typeof object.protobufSettings !== "object")
                    throw TypeError(".protos.ImportGithubSelectRequest.protobufSettings: object expected");
                message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
            }
            if (object.avroSettings != null) {
                if (typeof object.avroSettings !== "object")
                    throw TypeError(".protos.ImportGithubSelectRequest.avroSettings: object expected");
                message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
            }
            if (object.jsonSchemaSettings != null) {
                if (typeof object.jsonSchemaSettings !== "object")
                    throw TypeError(".protos.ImportGithubSelectRequest.jsonSchemaSettings: object expected");
                message.jsonSchemaSettings = $root.protos.encoding.JSONSchemaSettings.fromObject(object.jsonSchemaSettings);
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportGithubSelectRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ImportGithubSelectRequest
         * @static
         * @param {protos.ImportGithubSelectRequest} message ImportGithubSelectRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportGithubSelectRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.importId = "";
                object.schemaFileName = "";
                object.schemaFileSha = "";
                object.auth = null;
            }
            if (message.importId != null && message.hasOwnProperty("importId"))
                object.importId = message.importId;
            if (message.schemaFileName != null && message.hasOwnProperty("schemaFileName"))
                object.schemaFileName = message.schemaFileName;
            if (message.schemaFileSha != null && message.hasOwnProperty("schemaFileSha"))
                object.schemaFileSha = message.schemaFileSha;
            if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (options.oneofs)
                    object.settings = "protobufSettings";
            }
            if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                if (options.oneofs)
                    object.settings = "avroSettings";
            }
            if (message.jsonSchemaSettings != null && message.hasOwnProperty("jsonSchemaSettings")) {
                object.jsonSchemaSettings = $root.protos.encoding.JSONSchemaSettings.toObject(message.jsonSchemaSettings, options);
                if (options.oneofs)
                    object.settings = "jsonSchemaSettings";
            }
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ImportGithubSelectRequest to JSON.
         * @function toJSON
         * @memberof protos.ImportGithubSelectRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportGithubSelectRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImportGithubSelectRequest;
    })();

    protos.ImportGithubSelectResponse = (function() {

        /**
         * Properties of an ImportGithubSelectResponse.
         * @memberof protos
         * @interface IImportGithubSelectResponse
         * @property {protos.common.IStatus|null} [status] ImportGithubSelectResponse status
         * @property {protos.ISchema|null} [schema] ImportGithubSelectResponse schema
         */

        /**
         * Constructs a new ImportGithubSelectResponse.
         * @memberof protos
         * @classdesc Represents an ImportGithubSelectResponse.
         * @implements IImportGithubSelectResponse
         * @constructor
         * @param {protos.IImportGithubSelectResponse=} [properties] Properties to set
         */
        function ImportGithubSelectResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportGithubSelectResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.ImportGithubSelectResponse
         * @instance
         */
        ImportGithubSelectResponse.prototype.status = null;

        /**
         * ImportGithubSelectResponse schema.
         * @member {protos.ISchema|null|undefined} schema
         * @memberof protos.ImportGithubSelectResponse
         * @instance
         */
        ImportGithubSelectResponse.prototype.schema = null;

        /**
         * Creates a new ImportGithubSelectResponse instance using the specified properties.
         * @function create
         * @memberof protos.ImportGithubSelectResponse
         * @static
         * @param {protos.IImportGithubSelectResponse=} [properties] Properties to set
         * @returns {protos.ImportGithubSelectResponse} ImportGithubSelectResponse instance
         */
        ImportGithubSelectResponse.create = function create(properties) {
            return new ImportGithubSelectResponse(properties);
        };

        /**
         * Encodes the specified ImportGithubSelectResponse message. Does not implicitly {@link protos.ImportGithubSelectResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ImportGithubSelectResponse
         * @static
         * @param {protos.IImportGithubSelectResponse} message ImportGithubSelectResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportGithubSelectResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                $root.protos.Schema.encode(message.schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportGithubSelectResponse message, length delimited. Does not implicitly {@link protos.ImportGithubSelectResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ImportGithubSelectResponse
         * @static
         * @param {protos.IImportGithubSelectResponse} message ImportGithubSelectResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportGithubSelectResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportGithubSelectResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ImportGithubSelectResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ImportGithubSelectResponse} ImportGithubSelectResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportGithubSelectResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ImportGithubSelectResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.schema = $root.protos.Schema.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportGithubSelectResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ImportGithubSelectResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ImportGithubSelectResponse} ImportGithubSelectResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportGithubSelectResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportGithubSelectResponse message.
         * @function verify
         * @memberof protos.ImportGithubSelectResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportGithubSelectResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.schema != null && message.hasOwnProperty("schema")) {
                var error = $root.protos.Schema.verify(message.schema);
                if (error)
                    return "schema." + error;
            }
            return null;
        };

        /**
         * Creates an ImportGithubSelectResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ImportGithubSelectResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ImportGithubSelectResponse} ImportGithubSelectResponse
         */
        ImportGithubSelectResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ImportGithubSelectResponse)
                return object;
            var message = new $root.protos.ImportGithubSelectResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.ImportGithubSelectResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.schema != null) {
                if (typeof object.schema !== "object")
                    throw TypeError(".protos.ImportGithubSelectResponse.schema: object expected");
                message.schema = $root.protos.Schema.fromObject(object.schema);
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportGithubSelectResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ImportGithubSelectResponse
         * @static
         * @param {protos.ImportGithubSelectResponse} message ImportGithubSelectResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportGithubSelectResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.schema = null;
                object.status = null;
            }
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = $root.protos.Schema.toObject(message.schema, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ImportGithubSelectResponse to JSON.
         * @function toJSON
         * @memberof protos.ImportGithubSelectResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportGithubSelectResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImportGithubSelectResponse;
    })();

    protos.ImportLocalRequest = (function() {

        /**
         * Properties of an ImportLocalRequest.
         * @memberof protos
         * @interface IImportLocalRequest
         * @property {protos.common.IAuth|null} [auth] ImportLocalRequest auth
         * @property {string|null} [name] ImportLocalRequest name
         * @property {protos.SchemaType|null} [type] ImportLocalRequest type
         * @property {Uint8Array|null} [fileContents] ImportLocalRequest fileContents
         * @property {string|null} [fileName] ImportLocalRequest fileName
         * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] ImportLocalRequest protobufSettings
         * @property {protos.encoding.IAvroSettings|null} [avroSettings] ImportLocalRequest avroSettings
         * @property {protos.encoding.IJSONSchemaSettings|null} [jsonSchemaSettings] ImportLocalRequest jsonSchemaSettings
         */

        /**
         * Constructs a new ImportLocalRequest.
         * @memberof protos
         * @classdesc Represents an ImportLocalRequest.
         * @implements IImportLocalRequest
         * @constructor
         * @param {protos.IImportLocalRequest=} [properties] Properties to set
         */
        function ImportLocalRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportLocalRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.ImportLocalRequest
         * @instance
         */
        ImportLocalRequest.prototype.auth = null;

        /**
         * ImportLocalRequest name.
         * @member {string} name
         * @memberof protos.ImportLocalRequest
         * @instance
         */
        ImportLocalRequest.prototype.name = "";

        /**
         * ImportLocalRequest type.
         * @member {protos.SchemaType} type
         * @memberof protos.ImportLocalRequest
         * @instance
         */
        ImportLocalRequest.prototype.type = 0;

        /**
         * ImportLocalRequest fileContents.
         * @member {Uint8Array} fileContents
         * @memberof protos.ImportLocalRequest
         * @instance
         */
        ImportLocalRequest.prototype.fileContents = $util.newBuffer([]);

        /**
         * ImportLocalRequest fileName.
         * @member {string} fileName
         * @memberof protos.ImportLocalRequest
         * @instance
         */
        ImportLocalRequest.prototype.fileName = "";

        /**
         * ImportLocalRequest protobufSettings.
         * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
         * @memberof protos.ImportLocalRequest
         * @instance
         */
        ImportLocalRequest.prototype.protobufSettings = null;

        /**
         * ImportLocalRequest avroSettings.
         * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
         * @memberof protos.ImportLocalRequest
         * @instance
         */
        ImportLocalRequest.prototype.avroSettings = null;

        /**
         * ImportLocalRequest jsonSchemaSettings.
         * @member {protos.encoding.IJSONSchemaSettings|null|undefined} jsonSchemaSettings
         * @memberof protos.ImportLocalRequest
         * @instance
         */
        ImportLocalRequest.prototype.jsonSchemaSettings = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ImportLocalRequest settings.
         * @member {"protobufSettings"|"avroSettings"|"jsonSchemaSettings"|undefined} settings
         * @memberof protos.ImportLocalRequest
         * @instance
         */
        Object.defineProperty(ImportLocalRequest.prototype, "settings", {
            get: $util.oneOfGetter($oneOfFields = ["protobufSettings", "avroSettings", "jsonSchemaSettings"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ImportLocalRequest instance using the specified properties.
         * @function create
         * @memberof protos.ImportLocalRequest
         * @static
         * @param {protos.IImportLocalRequest=} [properties] Properties to set
         * @returns {protos.ImportLocalRequest} ImportLocalRequest instance
         */
        ImportLocalRequest.create = function create(properties) {
            return new ImportLocalRequest(properties);
        };

        /**
         * Encodes the specified ImportLocalRequest message. Does not implicitly {@link protos.ImportLocalRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ImportLocalRequest
         * @static
         * @param {protos.IImportLocalRequest} message ImportLocalRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportLocalRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.fileContents != null && Object.hasOwnProperty.call(message, "fileContents"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fileContents);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
            if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
            if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.jsonSchemaSettings != null && Object.hasOwnProperty.call(message, "jsonSchemaSettings"))
                $root.protos.encoding.JSONSchemaSettings.encode(message.jsonSchemaSettings, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportLocalRequest message, length delimited. Does not implicitly {@link protos.ImportLocalRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ImportLocalRequest
         * @static
         * @param {protos.IImportLocalRequest} message ImportLocalRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportLocalRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportLocalRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ImportLocalRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ImportLocalRequest} ImportLocalRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportLocalRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ImportLocalRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.fileContents = reader.bytes();
                    break;
                case 4:
                    message.fileName = reader.string();
                    break;
                case 100:
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                    break;
                case 101:
                    message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.jsonSchemaSettings = $root.protos.encoding.JSONSchemaSettings.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportLocalRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ImportLocalRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ImportLocalRequest} ImportLocalRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportLocalRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportLocalRequest message.
         * @function verify
         * @memberof protos.ImportLocalRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportLocalRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.fileContents != null && message.hasOwnProperty("fileContents"))
                if (!(message.fileContents && typeof message.fileContents.length === "number" || $util.isString(message.fileContents)))
                    return "fileContents: buffer expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                properties.settings = 1;
                {
                    var error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
            }
            if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                if (properties.settings === 1)
                    return "settings: multiple values";
                properties.settings = 1;
                {
                    var error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
            }
            if (message.jsonSchemaSettings != null && message.hasOwnProperty("jsonSchemaSettings")) {
                if (properties.settings === 1)
                    return "settings: multiple values";
                properties.settings = 1;
                {
                    var error = $root.protos.encoding.JSONSchemaSettings.verify(message.jsonSchemaSettings);
                    if (error)
                        return "jsonSchemaSettings." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ImportLocalRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ImportLocalRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ImportLocalRequest} ImportLocalRequest
         */
        ImportLocalRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ImportLocalRequest)
                return object;
            var message = new $root.protos.ImportLocalRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.ImportLocalRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            case "SCHEMA_TYPE_UNSET":
            case 0:
                message.type = 0;
                break;
            case "SCHEMA_TYPE_PROTOBUF":
            case 1:
                message.type = 1;
                break;
            case "SCHEMA_TYPE_AVRO":
            case 2:
                message.type = 2;
                break;
            case "SCHEMA_TYPE_JSONSCHEMA":
            case 3:
                message.type = 3;
                break;
            }
            if (object.fileContents != null)
                if (typeof object.fileContents === "string")
                    $util.base64.decode(object.fileContents, message.fileContents = $util.newBuffer($util.base64.length(object.fileContents)), 0);
                else if (object.fileContents.length)
                    message.fileContents = object.fileContents;
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.protobufSettings != null) {
                if (typeof object.protobufSettings !== "object")
                    throw TypeError(".protos.ImportLocalRequest.protobufSettings: object expected");
                message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
            }
            if (object.avroSettings != null) {
                if (typeof object.avroSettings !== "object")
                    throw TypeError(".protos.ImportLocalRequest.avroSettings: object expected");
                message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
            }
            if (object.jsonSchemaSettings != null) {
                if (typeof object.jsonSchemaSettings !== "object")
                    throw TypeError(".protos.ImportLocalRequest.jsonSchemaSettings: object expected");
                message.jsonSchemaSettings = $root.protos.encoding.JSONSchemaSettings.fromObject(object.jsonSchemaSettings);
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportLocalRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ImportLocalRequest
         * @static
         * @param {protos.ImportLocalRequest} message ImportLocalRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportLocalRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = options.enums === String ? "SCHEMA_TYPE_UNSET" : 0;
                if (options.bytes === String)
                    object.fileContents = "";
                else {
                    object.fileContents = [];
                    if (options.bytes !== Array)
                        object.fileContents = $util.newBuffer(object.fileContents);
                }
                object.fileName = "";
                object.auth = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protos.SchemaType[message.type] : message.type;
            if (message.fileContents != null && message.hasOwnProperty("fileContents"))
                object.fileContents = options.bytes === String ? $util.base64.encode(message.fileContents, 0, message.fileContents.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileContents) : message.fileContents;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (options.oneofs)
                    object.settings = "protobufSettings";
            }
            if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                if (options.oneofs)
                    object.settings = "avroSettings";
            }
            if (message.jsonSchemaSettings != null && message.hasOwnProperty("jsonSchemaSettings")) {
                object.jsonSchemaSettings = $root.protos.encoding.JSONSchemaSettings.toObject(message.jsonSchemaSettings, options);
                if (options.oneofs)
                    object.settings = "jsonSchemaSettings";
            }
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ImportLocalRequest to JSON.
         * @function toJSON
         * @memberof protos.ImportLocalRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportLocalRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImportLocalRequest;
    })();

    protos.ImportLocalResponse = (function() {

        /**
         * Properties of an ImportLocalResponse.
         * @memberof protos
         * @interface IImportLocalResponse
         * @property {protos.common.IStatus|null} [status] ImportLocalResponse status
         * @property {string|null} [id] ImportLocalResponse id
         */

        /**
         * Constructs a new ImportLocalResponse.
         * @memberof protos
         * @classdesc Represents an ImportLocalResponse.
         * @implements IImportLocalResponse
         * @constructor
         * @param {protos.IImportLocalResponse=} [properties] Properties to set
         */
        function ImportLocalResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportLocalResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.ImportLocalResponse
         * @instance
         */
        ImportLocalResponse.prototype.status = null;

        /**
         * ImportLocalResponse id.
         * @member {string} id
         * @memberof protos.ImportLocalResponse
         * @instance
         */
        ImportLocalResponse.prototype.id = "";

        /**
         * Creates a new ImportLocalResponse instance using the specified properties.
         * @function create
         * @memberof protos.ImportLocalResponse
         * @static
         * @param {protos.IImportLocalResponse=} [properties] Properties to set
         * @returns {protos.ImportLocalResponse} ImportLocalResponse instance
         */
        ImportLocalResponse.create = function create(properties) {
            return new ImportLocalResponse(properties);
        };

        /**
         * Encodes the specified ImportLocalResponse message. Does not implicitly {@link protos.ImportLocalResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ImportLocalResponse
         * @static
         * @param {protos.IImportLocalResponse} message ImportLocalResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportLocalResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportLocalResponse message, length delimited. Does not implicitly {@link protos.ImportLocalResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ImportLocalResponse
         * @static
         * @param {protos.IImportLocalResponse} message ImportLocalResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportLocalResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportLocalResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ImportLocalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ImportLocalResponse} ImportLocalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportLocalResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ImportLocalResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportLocalResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ImportLocalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ImportLocalResponse} ImportLocalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportLocalResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportLocalResponse message.
         * @function verify
         * @memberof protos.ImportLocalResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportLocalResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates an ImportLocalResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ImportLocalResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ImportLocalResponse} ImportLocalResponse
         */
        ImportLocalResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ImportLocalResponse)
                return object;
            var message = new $root.protos.ImportLocalResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.ImportLocalResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from an ImportLocalResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ImportLocalResponse
         * @static
         * @param {protos.ImportLocalResponse} message ImportLocalResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportLocalResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.status = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ImportLocalResponse to JSON.
         * @function toJSON
         * @memberof protos.ImportLocalResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportLocalResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImportLocalResponse;
    })();

    protos.UpdateSchemaRequest = (function() {

        /**
         * Properties of an UpdateSchemaRequest.
         * @memberof protos
         * @interface IUpdateSchemaRequest
         * @property {protos.common.IAuth|null} [auth] UpdateSchemaRequest auth
         * @property {string|null} [id] UpdateSchemaRequest id
         * @property {string|null} [name] UpdateSchemaRequest name
         * @property {string|null} [ownerId] UpdateSchemaRequest ownerId
         * @property {string|null} [notes] UpdateSchemaRequest notes
         */

        /**
         * Constructs a new UpdateSchemaRequest.
         * @memberof protos
         * @classdesc Represents an UpdateSchemaRequest.
         * @implements IUpdateSchemaRequest
         * @constructor
         * @param {protos.IUpdateSchemaRequest=} [properties] Properties to set
         */
        function UpdateSchemaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateSchemaRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateSchemaRequest
         * @instance
         */
        UpdateSchemaRequest.prototype.auth = null;

        /**
         * UpdateSchemaRequest id.
         * @member {string} id
         * @memberof protos.UpdateSchemaRequest
         * @instance
         */
        UpdateSchemaRequest.prototype.id = "";

        /**
         * UpdateSchemaRequest name.
         * @member {string} name
         * @memberof protos.UpdateSchemaRequest
         * @instance
         */
        UpdateSchemaRequest.prototype.name = "";

        /**
         * UpdateSchemaRequest ownerId.
         * @member {string} ownerId
         * @memberof protos.UpdateSchemaRequest
         * @instance
         */
        UpdateSchemaRequest.prototype.ownerId = "";

        /**
         * UpdateSchemaRequest notes.
         * @member {string} notes
         * @memberof protos.UpdateSchemaRequest
         * @instance
         */
        UpdateSchemaRequest.prototype.notes = "";

        /**
         * Creates a new UpdateSchemaRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateSchemaRequest
         * @static
         * @param {protos.IUpdateSchemaRequest=} [properties] Properties to set
         * @returns {protos.UpdateSchemaRequest} UpdateSchemaRequest instance
         */
        UpdateSchemaRequest.create = function create(properties) {
            return new UpdateSchemaRequest(properties);
        };

        /**
         * Encodes the specified UpdateSchemaRequest message. Does not implicitly {@link protos.UpdateSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateSchemaRequest
         * @static
         * @param {protos.IUpdateSchemaRequest} message UpdateSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.ownerId != null && Object.hasOwnProperty.call(message, "ownerId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ownerId);
            if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.notes);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateSchemaRequest message, length delimited. Does not implicitly {@link protos.UpdateSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateSchemaRequest
         * @static
         * @param {protos.IUpdateSchemaRequest} message UpdateSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateSchemaRequest} UpdateSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.ownerId = reader.string();
                    break;
                case 4:
                    message.notes = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateSchemaRequest} UpdateSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateSchemaRequest message.
         * @function verify
         * @memberof protos.UpdateSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                if (!$util.isString(message.ownerId))
                    return "ownerId: string expected";
            if (message.notes != null && message.hasOwnProperty("notes"))
                if (!$util.isString(message.notes))
                    return "notes: string expected";
            return null;
        };

        /**
         * Creates an UpdateSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateSchemaRequest} UpdateSchemaRequest
         */
        UpdateSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateSchemaRequest)
                return object;
            var message = new $root.protos.UpdateSchemaRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateSchemaRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.ownerId != null)
                message.ownerId = String(object.ownerId);
            if (object.notes != null)
                message.notes = String(object.notes);
            return message;
        };

        /**
         * Creates a plain object from an UpdateSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateSchemaRequest
         * @static
         * @param {protos.UpdateSchemaRequest} message UpdateSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.name = "";
                object.ownerId = "";
                object.notes = "";
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                object.ownerId = message.ownerId;
            if (message.notes != null && message.hasOwnProperty("notes"))
                object.notes = message.notes;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateSchemaRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateSchemaRequest;
    })();

    protos.UpdateSchemaResponse = (function() {

        /**
         * Properties of an UpdateSchemaResponse.
         * @memberof protos
         * @interface IUpdateSchemaResponse
         * @property {protos.common.IStatus|null} [status] UpdateSchemaResponse status
         * @property {protos.ISchema|null} [schema] UpdateSchemaResponse schema
         */

        /**
         * Constructs a new UpdateSchemaResponse.
         * @memberof protos
         * @classdesc Represents an UpdateSchemaResponse.
         * @implements IUpdateSchemaResponse
         * @constructor
         * @param {protos.IUpdateSchemaResponse=} [properties] Properties to set
         */
        function UpdateSchemaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateSchemaResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateSchemaResponse
         * @instance
         */
        UpdateSchemaResponse.prototype.status = null;

        /**
         * UpdateSchemaResponse schema.
         * @member {protos.ISchema|null|undefined} schema
         * @memberof protos.UpdateSchemaResponse
         * @instance
         */
        UpdateSchemaResponse.prototype.schema = null;

        /**
         * Creates a new UpdateSchemaResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateSchemaResponse
         * @static
         * @param {protos.IUpdateSchemaResponse=} [properties] Properties to set
         * @returns {protos.UpdateSchemaResponse} UpdateSchemaResponse instance
         */
        UpdateSchemaResponse.create = function create(properties) {
            return new UpdateSchemaResponse(properties);
        };

        /**
         * Encodes the specified UpdateSchemaResponse message. Does not implicitly {@link protos.UpdateSchemaResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateSchemaResponse
         * @static
         * @param {protos.IUpdateSchemaResponse} message UpdateSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateSchemaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                $root.protos.Schema.encode(message.schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateSchemaResponse message, length delimited. Does not implicitly {@link protos.UpdateSchemaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateSchemaResponse
         * @static
         * @param {protos.IUpdateSchemaResponse} message UpdateSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateSchemaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateSchemaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateSchemaResponse} UpdateSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateSchemaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateSchemaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.schema = $root.protos.Schema.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateSchemaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateSchemaResponse} UpdateSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateSchemaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateSchemaResponse message.
         * @function verify
         * @memberof protos.UpdateSchemaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateSchemaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.schema != null && message.hasOwnProperty("schema")) {
                var error = $root.protos.Schema.verify(message.schema);
                if (error)
                    return "schema." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateSchemaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateSchemaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateSchemaResponse} UpdateSchemaResponse
         */
        UpdateSchemaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateSchemaResponse)
                return object;
            var message = new $root.protos.UpdateSchemaResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateSchemaResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.schema != null) {
                if (typeof object.schema !== "object")
                    throw TypeError(".protos.UpdateSchemaResponse.schema: object expected");
                message.schema = $root.protos.Schema.fromObject(object.schema);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateSchemaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateSchemaResponse
         * @static
         * @param {protos.UpdateSchemaResponse} message UpdateSchemaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateSchemaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.schema = null;
                object.status = null;
            }
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = $root.protos.Schema.toObject(message.schema, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateSchemaResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateSchemaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateSchemaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateSchemaResponse;
    })();

    protos.DeleteSchemaRequest = (function() {

        /**
         * Properties of a DeleteSchemaRequest.
         * @memberof protos
         * @interface IDeleteSchemaRequest
         * @property {protos.common.IAuth|null} [auth] DeleteSchemaRequest auth
         * @property {string|null} [id] DeleteSchemaRequest id
         */

        /**
         * Constructs a new DeleteSchemaRequest.
         * @memberof protos
         * @classdesc Represents a DeleteSchemaRequest.
         * @implements IDeleteSchemaRequest
         * @constructor
         * @param {protos.IDeleteSchemaRequest=} [properties] Properties to set
         */
        function DeleteSchemaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteSchemaRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteSchemaRequest
         * @instance
         */
        DeleteSchemaRequest.prototype.auth = null;

        /**
         * DeleteSchemaRequest id.
         * @member {string} id
         * @memberof protos.DeleteSchemaRequest
         * @instance
         */
        DeleteSchemaRequest.prototype.id = "";

        /**
         * Creates a new DeleteSchemaRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteSchemaRequest
         * @static
         * @param {protos.IDeleteSchemaRequest=} [properties] Properties to set
         * @returns {protos.DeleteSchemaRequest} DeleteSchemaRequest instance
         */
        DeleteSchemaRequest.create = function create(properties) {
            return new DeleteSchemaRequest(properties);
        };

        /**
         * Encodes the specified DeleteSchemaRequest message. Does not implicitly {@link protos.DeleteSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteSchemaRequest
         * @static
         * @param {protos.IDeleteSchemaRequest} message DeleteSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteSchemaRequest message, length delimited. Does not implicitly {@link protos.DeleteSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteSchemaRequest
         * @static
         * @param {protos.IDeleteSchemaRequest} message DeleteSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteSchemaRequest} DeleteSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteSchemaRequest} DeleteSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteSchemaRequest message.
         * @function verify
         * @memberof protos.DeleteSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a DeleteSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteSchemaRequest} DeleteSchemaRequest
         */
        DeleteSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteSchemaRequest)
                return object;
            var message = new $root.protos.DeleteSchemaRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteSchemaRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a DeleteSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteSchemaRequest
         * @static
         * @param {protos.DeleteSchemaRequest} message DeleteSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteSchemaRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteSchemaRequest;
    })();

    protos.DeleteSchemaResponse = (function() {

        /**
         * Properties of a DeleteSchemaResponse.
         * @memberof protos
         * @interface IDeleteSchemaResponse
         * @property {protos.common.IStatus|null} [status] DeleteSchemaResponse status
         */

        /**
         * Constructs a new DeleteSchemaResponse.
         * @memberof protos
         * @classdesc Represents a DeleteSchemaResponse.
         * @implements IDeleteSchemaResponse
         * @constructor
         * @param {protos.IDeleteSchemaResponse=} [properties] Properties to set
         */
        function DeleteSchemaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteSchemaResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteSchemaResponse
         * @instance
         */
        DeleteSchemaResponse.prototype.status = null;

        /**
         * Creates a new DeleteSchemaResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteSchemaResponse
         * @static
         * @param {protos.IDeleteSchemaResponse=} [properties] Properties to set
         * @returns {protos.DeleteSchemaResponse} DeleteSchemaResponse instance
         */
        DeleteSchemaResponse.create = function create(properties) {
            return new DeleteSchemaResponse(properties);
        };

        /**
         * Encodes the specified DeleteSchemaResponse message. Does not implicitly {@link protos.DeleteSchemaResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteSchemaResponse
         * @static
         * @param {protos.IDeleteSchemaResponse} message DeleteSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteSchemaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteSchemaResponse message, length delimited. Does not implicitly {@link protos.DeleteSchemaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteSchemaResponse
         * @static
         * @param {protos.IDeleteSchemaResponse} message DeleteSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteSchemaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteSchemaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteSchemaResponse} DeleteSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteSchemaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteSchemaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteSchemaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteSchemaResponse} DeleteSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteSchemaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteSchemaResponse message.
         * @function verify
         * @memberof protos.DeleteSchemaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteSchemaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteSchemaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteSchemaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteSchemaResponse} DeleteSchemaResponse
         */
        DeleteSchemaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteSchemaResponse)
                return object;
            var message = new $root.protos.DeleteSchemaResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteSchemaResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteSchemaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteSchemaResponse
         * @static
         * @param {protos.DeleteSchemaResponse} message DeleteSchemaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteSchemaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteSchemaResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteSchemaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteSchemaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteSchemaResponse;
    })();

    protos.DeleteSchemaVersionRequest = (function() {

        /**
         * Properties of a DeleteSchemaVersionRequest.
         * @memberof protos
         * @interface IDeleteSchemaVersionRequest
         * @property {protos.common.IAuth|null} [auth] DeleteSchemaVersionRequest auth
         * @property {string|null} [id] DeleteSchemaVersionRequest id
         * @property {number|null} [version] DeleteSchemaVersionRequest version
         */

        /**
         * Constructs a new DeleteSchemaVersionRequest.
         * @memberof protos
         * @classdesc Represents a DeleteSchemaVersionRequest.
         * @implements IDeleteSchemaVersionRequest
         * @constructor
         * @param {protos.IDeleteSchemaVersionRequest=} [properties] Properties to set
         */
        function DeleteSchemaVersionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteSchemaVersionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteSchemaVersionRequest
         * @instance
         */
        DeleteSchemaVersionRequest.prototype.auth = null;

        /**
         * DeleteSchemaVersionRequest id.
         * @member {string} id
         * @memberof protos.DeleteSchemaVersionRequest
         * @instance
         */
        DeleteSchemaVersionRequest.prototype.id = "";

        /**
         * DeleteSchemaVersionRequest version.
         * @member {number} version
         * @memberof protos.DeleteSchemaVersionRequest
         * @instance
         */
        DeleteSchemaVersionRequest.prototype.version = 0;

        /**
         * Creates a new DeleteSchemaVersionRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteSchemaVersionRequest
         * @static
         * @param {protos.IDeleteSchemaVersionRequest=} [properties] Properties to set
         * @returns {protos.DeleteSchemaVersionRequest} DeleteSchemaVersionRequest instance
         */
        DeleteSchemaVersionRequest.create = function create(properties) {
            return new DeleteSchemaVersionRequest(properties);
        };

        /**
         * Encodes the specified DeleteSchemaVersionRequest message. Does not implicitly {@link protos.DeleteSchemaVersionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteSchemaVersionRequest
         * @static
         * @param {protos.IDeleteSchemaVersionRequest} message DeleteSchemaVersionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteSchemaVersionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.version);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteSchemaVersionRequest message, length delimited. Does not implicitly {@link protos.DeleteSchemaVersionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteSchemaVersionRequest
         * @static
         * @param {protos.IDeleteSchemaVersionRequest} message DeleteSchemaVersionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteSchemaVersionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteSchemaVersionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteSchemaVersionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteSchemaVersionRequest} DeleteSchemaVersionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteSchemaVersionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteSchemaVersionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteSchemaVersionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteSchemaVersionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteSchemaVersionRequest} DeleteSchemaVersionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteSchemaVersionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteSchemaVersionRequest message.
         * @function verify
         * @memberof protos.DeleteSchemaVersionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteSchemaVersionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates a DeleteSchemaVersionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteSchemaVersionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteSchemaVersionRequest} DeleteSchemaVersionRequest
         */
        DeleteSchemaVersionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteSchemaVersionRequest)
                return object;
            var message = new $root.protos.DeleteSchemaVersionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteSchemaVersionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.version != null)
                message.version = object.version | 0;
            return message;
        };

        /**
         * Creates a plain object from a DeleteSchemaVersionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteSchemaVersionRequest
         * @static
         * @param {protos.DeleteSchemaVersionRequest} message DeleteSchemaVersionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteSchemaVersionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.version = 0;
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteSchemaVersionRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteSchemaVersionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteSchemaVersionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteSchemaVersionRequest;
    })();

    protos.DeleteSchemaVersionResponse = (function() {

        /**
         * Properties of a DeleteSchemaVersionResponse.
         * @memberof protos
         * @interface IDeleteSchemaVersionResponse
         * @property {protos.common.IStatus|null} [status] DeleteSchemaVersionResponse status
         * @property {protos.ISchema|null} [schema] DeleteSchemaVersionResponse schema
         */

        /**
         * Constructs a new DeleteSchemaVersionResponse.
         * @memberof protos
         * @classdesc Represents a DeleteSchemaVersionResponse.
         * @implements IDeleteSchemaVersionResponse
         * @constructor
         * @param {protos.IDeleteSchemaVersionResponse=} [properties] Properties to set
         */
        function DeleteSchemaVersionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteSchemaVersionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteSchemaVersionResponse
         * @instance
         */
        DeleteSchemaVersionResponse.prototype.status = null;

        /**
         * DeleteSchemaVersionResponse schema.
         * @member {protos.ISchema|null|undefined} schema
         * @memberof protos.DeleteSchemaVersionResponse
         * @instance
         */
        DeleteSchemaVersionResponse.prototype.schema = null;

        /**
         * Creates a new DeleteSchemaVersionResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteSchemaVersionResponse
         * @static
         * @param {protos.IDeleteSchemaVersionResponse=} [properties] Properties to set
         * @returns {protos.DeleteSchemaVersionResponse} DeleteSchemaVersionResponse instance
         */
        DeleteSchemaVersionResponse.create = function create(properties) {
            return new DeleteSchemaVersionResponse(properties);
        };

        /**
         * Encodes the specified DeleteSchemaVersionResponse message. Does not implicitly {@link protos.DeleteSchemaVersionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteSchemaVersionResponse
         * @static
         * @param {protos.IDeleteSchemaVersionResponse} message DeleteSchemaVersionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteSchemaVersionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                $root.protos.Schema.encode(message.schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteSchemaVersionResponse message, length delimited. Does not implicitly {@link protos.DeleteSchemaVersionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteSchemaVersionResponse
         * @static
         * @param {protos.IDeleteSchemaVersionResponse} message DeleteSchemaVersionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteSchemaVersionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteSchemaVersionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteSchemaVersionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteSchemaVersionResponse} DeleteSchemaVersionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteSchemaVersionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteSchemaVersionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.schema = $root.protos.Schema.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteSchemaVersionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteSchemaVersionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteSchemaVersionResponse} DeleteSchemaVersionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteSchemaVersionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteSchemaVersionResponse message.
         * @function verify
         * @memberof protos.DeleteSchemaVersionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteSchemaVersionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.schema != null && message.hasOwnProperty("schema")) {
                var error = $root.protos.Schema.verify(message.schema);
                if (error)
                    return "schema." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteSchemaVersionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteSchemaVersionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteSchemaVersionResponse} DeleteSchemaVersionResponse
         */
        DeleteSchemaVersionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteSchemaVersionResponse)
                return object;
            var message = new $root.protos.DeleteSchemaVersionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteSchemaVersionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.schema != null) {
                if (typeof object.schema !== "object")
                    throw TypeError(".protos.DeleteSchemaVersionResponse.schema: object expected");
                message.schema = $root.protos.Schema.fromObject(object.schema);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteSchemaVersionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteSchemaVersionResponse
         * @static
         * @param {protos.DeleteSchemaVersionResponse} message DeleteSchemaVersionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteSchemaVersionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.schema = null;
                object.status = null;
            }
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = $root.protos.Schema.toObject(message.schema, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteSchemaVersionResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteSchemaVersionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteSchemaVersionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteSchemaVersionResponse;
    })();

    protos.ApproveSchemaVersionRequest = (function() {

        /**
         * Properties of an ApproveSchemaVersionRequest.
         * @memberof protos
         * @interface IApproveSchemaVersionRequest
         * @property {protos.common.IAuth|null} [auth] ApproveSchemaVersionRequest auth
         * @property {string|null} [id] ApproveSchemaVersionRequest id
         * @property {number|null} [version] ApproveSchemaVersionRequest version
         */

        /**
         * Constructs a new ApproveSchemaVersionRequest.
         * @memberof protos
         * @classdesc Represents an ApproveSchemaVersionRequest.
         * @implements IApproveSchemaVersionRequest
         * @constructor
         * @param {protos.IApproveSchemaVersionRequest=} [properties] Properties to set
         */
        function ApproveSchemaVersionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApproveSchemaVersionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.ApproveSchemaVersionRequest
         * @instance
         */
        ApproveSchemaVersionRequest.prototype.auth = null;

        /**
         * ApproveSchemaVersionRequest id.
         * @member {string} id
         * @memberof protos.ApproveSchemaVersionRequest
         * @instance
         */
        ApproveSchemaVersionRequest.prototype.id = "";

        /**
         * ApproveSchemaVersionRequest version.
         * @member {number} version
         * @memberof protos.ApproveSchemaVersionRequest
         * @instance
         */
        ApproveSchemaVersionRequest.prototype.version = 0;

        /**
         * Creates a new ApproveSchemaVersionRequest instance using the specified properties.
         * @function create
         * @memberof protos.ApproveSchemaVersionRequest
         * @static
         * @param {protos.IApproveSchemaVersionRequest=} [properties] Properties to set
         * @returns {protos.ApproveSchemaVersionRequest} ApproveSchemaVersionRequest instance
         */
        ApproveSchemaVersionRequest.create = function create(properties) {
            return new ApproveSchemaVersionRequest(properties);
        };

        /**
         * Encodes the specified ApproveSchemaVersionRequest message. Does not implicitly {@link protos.ApproveSchemaVersionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ApproveSchemaVersionRequest
         * @static
         * @param {protos.IApproveSchemaVersionRequest} message ApproveSchemaVersionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveSchemaVersionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.version);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApproveSchemaVersionRequest message, length delimited. Does not implicitly {@link protos.ApproveSchemaVersionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ApproveSchemaVersionRequest
         * @static
         * @param {protos.IApproveSchemaVersionRequest} message ApproveSchemaVersionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveSchemaVersionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApproveSchemaVersionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ApproveSchemaVersionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ApproveSchemaVersionRequest} ApproveSchemaVersionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveSchemaVersionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ApproveSchemaVersionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApproveSchemaVersionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ApproveSchemaVersionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ApproveSchemaVersionRequest} ApproveSchemaVersionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveSchemaVersionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApproveSchemaVersionRequest message.
         * @function verify
         * @memberof protos.ApproveSchemaVersionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApproveSchemaVersionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates an ApproveSchemaVersionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ApproveSchemaVersionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ApproveSchemaVersionRequest} ApproveSchemaVersionRequest
         */
        ApproveSchemaVersionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ApproveSchemaVersionRequest)
                return object;
            var message = new $root.protos.ApproveSchemaVersionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.ApproveSchemaVersionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.version != null)
                message.version = object.version | 0;
            return message;
        };

        /**
         * Creates a plain object from an ApproveSchemaVersionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ApproveSchemaVersionRequest
         * @static
         * @param {protos.ApproveSchemaVersionRequest} message ApproveSchemaVersionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApproveSchemaVersionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.version = 0;
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ApproveSchemaVersionRequest to JSON.
         * @function toJSON
         * @memberof protos.ApproveSchemaVersionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApproveSchemaVersionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApproveSchemaVersionRequest;
    })();

    protos.ApproveSchemaVersionResponse = (function() {

        /**
         * Properties of an ApproveSchemaVersionResponse.
         * @memberof protos
         * @interface IApproveSchemaVersionResponse
         * @property {protos.common.IStatus|null} [status] ApproveSchemaVersionResponse status
         * @property {protos.ISchema|null} [schema] ApproveSchemaVersionResponse schema
         */

        /**
         * Constructs a new ApproveSchemaVersionResponse.
         * @memberof protos
         * @classdesc Represents an ApproveSchemaVersionResponse.
         * @implements IApproveSchemaVersionResponse
         * @constructor
         * @param {protos.IApproveSchemaVersionResponse=} [properties] Properties to set
         */
        function ApproveSchemaVersionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApproveSchemaVersionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.ApproveSchemaVersionResponse
         * @instance
         */
        ApproveSchemaVersionResponse.prototype.status = null;

        /**
         * ApproveSchemaVersionResponse schema.
         * @member {protos.ISchema|null|undefined} schema
         * @memberof protos.ApproveSchemaVersionResponse
         * @instance
         */
        ApproveSchemaVersionResponse.prototype.schema = null;

        /**
         * Creates a new ApproveSchemaVersionResponse instance using the specified properties.
         * @function create
         * @memberof protos.ApproveSchemaVersionResponse
         * @static
         * @param {protos.IApproveSchemaVersionResponse=} [properties] Properties to set
         * @returns {protos.ApproveSchemaVersionResponse} ApproveSchemaVersionResponse instance
         */
        ApproveSchemaVersionResponse.create = function create(properties) {
            return new ApproveSchemaVersionResponse(properties);
        };

        /**
         * Encodes the specified ApproveSchemaVersionResponse message. Does not implicitly {@link protos.ApproveSchemaVersionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ApproveSchemaVersionResponse
         * @static
         * @param {protos.IApproveSchemaVersionResponse} message ApproveSchemaVersionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveSchemaVersionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                $root.protos.Schema.encode(message.schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApproveSchemaVersionResponse message, length delimited. Does not implicitly {@link protos.ApproveSchemaVersionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ApproveSchemaVersionResponse
         * @static
         * @param {protos.IApproveSchemaVersionResponse} message ApproveSchemaVersionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveSchemaVersionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApproveSchemaVersionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ApproveSchemaVersionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ApproveSchemaVersionResponse} ApproveSchemaVersionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveSchemaVersionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ApproveSchemaVersionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.schema = $root.protos.Schema.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApproveSchemaVersionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ApproveSchemaVersionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ApproveSchemaVersionResponse} ApproveSchemaVersionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveSchemaVersionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApproveSchemaVersionResponse message.
         * @function verify
         * @memberof protos.ApproveSchemaVersionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApproveSchemaVersionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.schema != null && message.hasOwnProperty("schema")) {
                var error = $root.protos.Schema.verify(message.schema);
                if (error)
                    return "schema." + error;
            }
            return null;
        };

        /**
         * Creates an ApproveSchemaVersionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ApproveSchemaVersionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ApproveSchemaVersionResponse} ApproveSchemaVersionResponse
         */
        ApproveSchemaVersionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ApproveSchemaVersionResponse)
                return object;
            var message = new $root.protos.ApproveSchemaVersionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.ApproveSchemaVersionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.schema != null) {
                if (typeof object.schema !== "object")
                    throw TypeError(".protos.ApproveSchemaVersionResponse.schema: object expected");
                message.schema = $root.protos.Schema.fromObject(object.schema);
            }
            return message;
        };

        /**
         * Creates a plain object from an ApproveSchemaVersionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ApproveSchemaVersionResponse
         * @static
         * @param {protos.ApproveSchemaVersionResponse} message ApproveSchemaVersionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApproveSchemaVersionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.schema = null;
                object.status = null;
            }
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = $root.protos.Schema.toObject(message.schema, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ApproveSchemaVersionResponse to JSON.
         * @function toJSON
         * @memberof protos.ApproveSchemaVersionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApproveSchemaVersionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApproveSchemaVersionResponse;
    })();

    protos.GetRepoListRequest = (function() {

        /**
         * Properties of a GetRepoListRequest.
         * @memberof protos
         * @interface IGetRepoListRequest
         * @property {protos.common.IAuth|null} [auth] GetRepoListRequest auth
         */

        /**
         * Constructs a new GetRepoListRequest.
         * @memberof protos
         * @classdesc Represents a GetRepoListRequest.
         * @implements IGetRepoListRequest
         * @constructor
         * @param {protos.IGetRepoListRequest=} [properties] Properties to set
         */
        function GetRepoListRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRepoListRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetRepoListRequest
         * @instance
         */
        GetRepoListRequest.prototype.auth = null;

        /**
         * Creates a new GetRepoListRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetRepoListRequest
         * @static
         * @param {protos.IGetRepoListRequest=} [properties] Properties to set
         * @returns {protos.GetRepoListRequest} GetRepoListRequest instance
         */
        GetRepoListRequest.create = function create(properties) {
            return new GetRepoListRequest(properties);
        };

        /**
         * Encodes the specified GetRepoListRequest message. Does not implicitly {@link protos.GetRepoListRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRepoListRequest
         * @static
         * @param {protos.IGetRepoListRequest} message GetRepoListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRepoListRequest message, length delimited. Does not implicitly {@link protos.GetRepoListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRepoListRequest
         * @static
         * @param {protos.IGetRepoListRequest} message GetRepoListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRepoListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRepoListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRepoListRequest} GetRepoListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoListRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRepoListRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRepoListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRepoListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRepoListRequest} GetRepoListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRepoListRequest message.
         * @function verify
         * @memberof protos.GetRepoListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRepoListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetRepoListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRepoListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRepoListRequest} GetRepoListRequest
         */
        GetRepoListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRepoListRequest)
                return object;
            var message = new $root.protos.GetRepoListRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetRepoListRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetRepoListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRepoListRequest
         * @static
         * @param {protos.GetRepoListRequest} message GetRepoListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRepoListRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetRepoListRequest to JSON.
         * @function toJSON
         * @memberof protos.GetRepoListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRepoListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRepoListRequest;
    })();

    protos.GetRepoListResponse = (function() {

        /**
         * Properties of a GetRepoListResponse.
         * @memberof protos
         * @interface IGetRepoListResponse
         * @property {Array.<string>|null} [repositoryUrls] GetRepoListResponse repositoryUrls
         */

        /**
         * Constructs a new GetRepoListResponse.
         * @memberof protos
         * @classdesc Represents a GetRepoListResponse.
         * @implements IGetRepoListResponse
         * @constructor
         * @param {protos.IGetRepoListResponse=} [properties] Properties to set
         */
        function GetRepoListResponse(properties) {
            this.repositoryUrls = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRepoListResponse repositoryUrls.
         * @member {Array.<string>} repositoryUrls
         * @memberof protos.GetRepoListResponse
         * @instance
         */
        GetRepoListResponse.prototype.repositoryUrls = $util.emptyArray;

        /**
         * Creates a new GetRepoListResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetRepoListResponse
         * @static
         * @param {protos.IGetRepoListResponse=} [properties] Properties to set
         * @returns {protos.GetRepoListResponse} GetRepoListResponse instance
         */
        GetRepoListResponse.create = function create(properties) {
            return new GetRepoListResponse(properties);
        };

        /**
         * Encodes the specified GetRepoListResponse message. Does not implicitly {@link protos.GetRepoListResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRepoListResponse
         * @static
         * @param {protos.IGetRepoListResponse} message GetRepoListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.repositoryUrls != null && message.repositoryUrls.length)
                for (var i = 0; i < message.repositoryUrls.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.repositoryUrls[i]);
            return writer;
        };

        /**
         * Encodes the specified GetRepoListResponse message, length delimited. Does not implicitly {@link protos.GetRepoListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRepoListResponse
         * @static
         * @param {protos.IGetRepoListResponse} message GetRepoListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRepoListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRepoListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRepoListResponse} GetRepoListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRepoListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.repositoryUrls && message.repositoryUrls.length))
                        message.repositoryUrls = [];
                    message.repositoryUrls.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRepoListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRepoListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRepoListResponse} GetRepoListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRepoListResponse message.
         * @function verify
         * @memberof protos.GetRepoListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRepoListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.repositoryUrls != null && message.hasOwnProperty("repositoryUrls")) {
                if (!Array.isArray(message.repositoryUrls))
                    return "repositoryUrls: array expected";
                for (var i = 0; i < message.repositoryUrls.length; ++i)
                    if (!$util.isString(message.repositoryUrls[i]))
                        return "repositoryUrls: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetRepoListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRepoListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRepoListResponse} GetRepoListResponse
         */
        GetRepoListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRepoListResponse)
                return object;
            var message = new $root.protos.GetRepoListResponse();
            if (object.repositoryUrls) {
                if (!Array.isArray(object.repositoryUrls))
                    throw TypeError(".protos.GetRepoListResponse.repositoryUrls: array expected");
                message.repositoryUrls = [];
                for (var i = 0; i < object.repositoryUrls.length; ++i)
                    message.repositoryUrls[i] = String(object.repositoryUrls[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetRepoListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRepoListResponse
         * @static
         * @param {protos.GetRepoListResponse} message GetRepoListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRepoListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.repositoryUrls = [];
            if (message.repositoryUrls && message.repositoryUrls.length) {
                object.repositoryUrls = [];
                for (var j = 0; j < message.repositoryUrls.length; ++j)
                    object.repositoryUrls[j] = message.repositoryUrls[j];
            }
            return object;
        };

        /**
         * Converts this GetRepoListResponse to JSON.
         * @function toJSON
         * @memberof protos.GetRepoListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRepoListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRepoListResponse;
    })();

    protos.GetRepoTreeRequest = (function() {

        /**
         * Properties of a GetRepoTreeRequest.
         * @memberof protos
         * @interface IGetRepoTreeRequest
         * @property {protos.common.IAuth|null} [auth] GetRepoTreeRequest auth
         * @property {string|null} [repoUrl] GetRepoTreeRequest repoUrl
         */

        /**
         * Constructs a new GetRepoTreeRequest.
         * @memberof protos
         * @classdesc Represents a GetRepoTreeRequest.
         * @implements IGetRepoTreeRequest
         * @constructor
         * @param {protos.IGetRepoTreeRequest=} [properties] Properties to set
         */
        function GetRepoTreeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRepoTreeRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetRepoTreeRequest
         * @instance
         */
        GetRepoTreeRequest.prototype.auth = null;

        /**
         * GetRepoTreeRequest repoUrl.
         * @member {string} repoUrl
         * @memberof protos.GetRepoTreeRequest
         * @instance
         */
        GetRepoTreeRequest.prototype.repoUrl = "";

        /**
         * Creates a new GetRepoTreeRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetRepoTreeRequest
         * @static
         * @param {protos.IGetRepoTreeRequest=} [properties] Properties to set
         * @returns {protos.GetRepoTreeRequest} GetRepoTreeRequest instance
         */
        GetRepoTreeRequest.create = function create(properties) {
            return new GetRepoTreeRequest(properties);
        };

        /**
         * Encodes the specified GetRepoTreeRequest message. Does not implicitly {@link protos.GetRepoTreeRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRepoTreeRequest
         * @static
         * @param {protos.IGetRepoTreeRequest} message GetRepoTreeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoTreeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.repoUrl != null && Object.hasOwnProperty.call(message, "repoUrl"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.repoUrl);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRepoTreeRequest message, length delimited. Does not implicitly {@link protos.GetRepoTreeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRepoTreeRequest
         * @static
         * @param {protos.IGetRepoTreeRequest} message GetRepoTreeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoTreeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRepoTreeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRepoTreeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRepoTreeRequest} GetRepoTreeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoTreeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRepoTreeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.repoUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRepoTreeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRepoTreeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRepoTreeRequest} GetRepoTreeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoTreeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRepoTreeRequest message.
         * @function verify
         * @memberof protos.GetRepoTreeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRepoTreeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.repoUrl != null && message.hasOwnProperty("repoUrl"))
                if (!$util.isString(message.repoUrl))
                    return "repoUrl: string expected";
            return null;
        };

        /**
         * Creates a GetRepoTreeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRepoTreeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRepoTreeRequest} GetRepoTreeRequest
         */
        GetRepoTreeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRepoTreeRequest)
                return object;
            var message = new $root.protos.GetRepoTreeRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetRepoTreeRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.repoUrl != null)
                message.repoUrl = String(object.repoUrl);
            return message;
        };

        /**
         * Creates a plain object from a GetRepoTreeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRepoTreeRequest
         * @static
         * @param {protos.GetRepoTreeRequest} message GetRepoTreeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRepoTreeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.repoUrl = "";
                object.auth = null;
            }
            if (message.repoUrl != null && message.hasOwnProperty("repoUrl"))
                object.repoUrl = message.repoUrl;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetRepoTreeRequest to JSON.
         * @function toJSON
         * @memberof protos.GetRepoTreeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRepoTreeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRepoTreeRequest;
    })();

    protos.GetRepoTreeResponse = (function() {

        /**
         * Properties of a GetRepoTreeResponse.
         * @memberof protos
         * @interface IGetRepoTreeResponse
         * @property {protos.IDirectory|null} [tree] GetRepoTreeResponse tree
         */

        /**
         * Constructs a new GetRepoTreeResponse.
         * @memberof protos
         * @classdesc Represents a GetRepoTreeResponse.
         * @implements IGetRepoTreeResponse
         * @constructor
         * @param {protos.IGetRepoTreeResponse=} [properties] Properties to set
         */
        function GetRepoTreeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRepoTreeResponse tree.
         * @member {protos.IDirectory|null|undefined} tree
         * @memberof protos.GetRepoTreeResponse
         * @instance
         */
        GetRepoTreeResponse.prototype.tree = null;

        /**
         * Creates a new GetRepoTreeResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetRepoTreeResponse
         * @static
         * @param {protos.IGetRepoTreeResponse=} [properties] Properties to set
         * @returns {protos.GetRepoTreeResponse} GetRepoTreeResponse instance
         */
        GetRepoTreeResponse.create = function create(properties) {
            return new GetRepoTreeResponse(properties);
        };

        /**
         * Encodes the specified GetRepoTreeResponse message. Does not implicitly {@link protos.GetRepoTreeResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRepoTreeResponse
         * @static
         * @param {protos.IGetRepoTreeResponse} message GetRepoTreeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoTreeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tree != null && Object.hasOwnProperty.call(message, "tree"))
                $root.protos.Directory.encode(message.tree, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRepoTreeResponse message, length delimited. Does not implicitly {@link protos.GetRepoTreeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRepoTreeResponse
         * @static
         * @param {protos.IGetRepoTreeResponse} message GetRepoTreeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoTreeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRepoTreeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRepoTreeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRepoTreeResponse} GetRepoTreeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoTreeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRepoTreeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tree = $root.protos.Directory.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRepoTreeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRepoTreeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRepoTreeResponse} GetRepoTreeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoTreeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRepoTreeResponse message.
         * @function verify
         * @memberof protos.GetRepoTreeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRepoTreeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tree != null && message.hasOwnProperty("tree")) {
                var error = $root.protos.Directory.verify(message.tree);
                if (error)
                    return "tree." + error;
            }
            return null;
        };

        /**
         * Creates a GetRepoTreeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRepoTreeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRepoTreeResponse} GetRepoTreeResponse
         */
        GetRepoTreeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRepoTreeResponse)
                return object;
            var message = new $root.protos.GetRepoTreeResponse();
            if (object.tree != null) {
                if (typeof object.tree !== "object")
                    throw TypeError(".protos.GetRepoTreeResponse.tree: object expected");
                message.tree = $root.protos.Directory.fromObject(object.tree);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetRepoTreeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRepoTreeResponse
         * @static
         * @param {protos.GetRepoTreeResponse} message GetRepoTreeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRepoTreeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tree = null;
            if (message.tree != null && message.hasOwnProperty("tree"))
                object.tree = $root.protos.Directory.toObject(message.tree, options);
            return object;
        };

        /**
         * Converts this GetRepoTreeResponse to JSON.
         * @function toJSON
         * @memberof protos.GetRepoTreeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRepoTreeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRepoTreeResponse;
    })();

    protos.GetRepoFileRequest = (function() {

        /**
         * Properties of a GetRepoFileRequest.
         * @memberof protos
         * @interface IGetRepoFileRequest
         * @property {protos.common.IAuth|null} [auth] GetRepoFileRequest auth
         * @property {string|null} [repoUrl] GetRepoFileRequest repoUrl
         * @property {string|null} [fileName] GetRepoFileRequest fileName
         * @property {string|null} [filePath] GetRepoFileRequest filePath
         * @property {string|null} [fileSha] GetRepoFileRequest fileSha
         */

        /**
         * Constructs a new GetRepoFileRequest.
         * @memberof protos
         * @classdesc Represents a GetRepoFileRequest.
         * @implements IGetRepoFileRequest
         * @constructor
         * @param {protos.IGetRepoFileRequest=} [properties] Properties to set
         */
        function GetRepoFileRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRepoFileRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetRepoFileRequest
         * @instance
         */
        GetRepoFileRequest.prototype.auth = null;

        /**
         * GetRepoFileRequest repoUrl.
         * @member {string} repoUrl
         * @memberof protos.GetRepoFileRequest
         * @instance
         */
        GetRepoFileRequest.prototype.repoUrl = "";

        /**
         * GetRepoFileRequest fileName.
         * @member {string} fileName
         * @memberof protos.GetRepoFileRequest
         * @instance
         */
        GetRepoFileRequest.prototype.fileName = "";

        /**
         * GetRepoFileRequest filePath.
         * @member {string} filePath
         * @memberof protos.GetRepoFileRequest
         * @instance
         */
        GetRepoFileRequest.prototype.filePath = "";

        /**
         * GetRepoFileRequest fileSha.
         * @member {string} fileSha
         * @memberof protos.GetRepoFileRequest
         * @instance
         */
        GetRepoFileRequest.prototype.fileSha = "";

        /**
         * Creates a new GetRepoFileRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetRepoFileRequest
         * @static
         * @param {protos.IGetRepoFileRequest=} [properties] Properties to set
         * @returns {protos.GetRepoFileRequest} GetRepoFileRequest instance
         */
        GetRepoFileRequest.create = function create(properties) {
            return new GetRepoFileRequest(properties);
        };

        /**
         * Encodes the specified GetRepoFileRequest message. Does not implicitly {@link protos.GetRepoFileRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRepoFileRequest
         * @static
         * @param {protos.IGetRepoFileRequest} message GetRepoFileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoFileRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.repoUrl != null && Object.hasOwnProperty.call(message, "repoUrl"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.repoUrl);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
            if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.filePath);
            if (message.fileSha != null && Object.hasOwnProperty.call(message, "fileSha"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileSha);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRepoFileRequest message, length delimited. Does not implicitly {@link protos.GetRepoFileRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRepoFileRequest
         * @static
         * @param {protos.IGetRepoFileRequest} message GetRepoFileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRepoFileRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRepoFileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRepoFileRequest} GetRepoFileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoFileRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRepoFileRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.repoUrl = reader.string();
                    break;
                case 2:
                    message.fileName = reader.string();
                    break;
                case 3:
                    message.filePath = reader.string();
                    break;
                case 4:
                    message.fileSha = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRepoFileRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRepoFileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRepoFileRequest} GetRepoFileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoFileRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRepoFileRequest message.
         * @function verify
         * @memberof protos.GetRepoFileRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRepoFileRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.repoUrl != null && message.hasOwnProperty("repoUrl"))
                if (!$util.isString(message.repoUrl))
                    return "repoUrl: string expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.filePath != null && message.hasOwnProperty("filePath"))
                if (!$util.isString(message.filePath))
                    return "filePath: string expected";
            if (message.fileSha != null && message.hasOwnProperty("fileSha"))
                if (!$util.isString(message.fileSha))
                    return "fileSha: string expected";
            return null;
        };

        /**
         * Creates a GetRepoFileRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRepoFileRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRepoFileRequest} GetRepoFileRequest
         */
        GetRepoFileRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRepoFileRequest)
                return object;
            var message = new $root.protos.GetRepoFileRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetRepoFileRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.repoUrl != null)
                message.repoUrl = String(object.repoUrl);
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.filePath != null)
                message.filePath = String(object.filePath);
            if (object.fileSha != null)
                message.fileSha = String(object.fileSha);
            return message;
        };

        /**
         * Creates a plain object from a GetRepoFileRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRepoFileRequest
         * @static
         * @param {protos.GetRepoFileRequest} message GetRepoFileRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRepoFileRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.repoUrl = "";
                object.fileName = "";
                object.filePath = "";
                object.fileSha = "";
                object.auth = null;
            }
            if (message.repoUrl != null && message.hasOwnProperty("repoUrl"))
                object.repoUrl = message.repoUrl;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.filePath != null && message.hasOwnProperty("filePath"))
                object.filePath = message.filePath;
            if (message.fileSha != null && message.hasOwnProperty("fileSha"))
                object.fileSha = message.fileSha;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetRepoFileRequest to JSON.
         * @function toJSON
         * @memberof protos.GetRepoFileRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRepoFileRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRepoFileRequest;
    })();

    protos.GetRepoFileResponse = (function() {

        /**
         * Properties of a GetRepoFileResponse.
         * @memberof protos
         * @interface IGetRepoFileResponse
         * @property {Uint8Array|null} [content] GetRepoFileResponse content
         */

        /**
         * Constructs a new GetRepoFileResponse.
         * @memberof protos
         * @classdesc Represents a GetRepoFileResponse.
         * @implements IGetRepoFileResponse
         * @constructor
         * @param {protos.IGetRepoFileResponse=} [properties] Properties to set
         */
        function GetRepoFileResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRepoFileResponse content.
         * @member {Uint8Array} content
         * @memberof protos.GetRepoFileResponse
         * @instance
         */
        GetRepoFileResponse.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new GetRepoFileResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetRepoFileResponse
         * @static
         * @param {protos.IGetRepoFileResponse=} [properties] Properties to set
         * @returns {protos.GetRepoFileResponse} GetRepoFileResponse instance
         */
        GetRepoFileResponse.create = function create(properties) {
            return new GetRepoFileResponse(properties);
        };

        /**
         * Encodes the specified GetRepoFileResponse message. Does not implicitly {@link protos.GetRepoFileResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRepoFileResponse
         * @static
         * @param {protos.IGetRepoFileResponse} message GetRepoFileResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoFileResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified GetRepoFileResponse message, length delimited. Does not implicitly {@link protos.GetRepoFileResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRepoFileResponse
         * @static
         * @param {protos.IGetRepoFileResponse} message GetRepoFileResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRepoFileResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRepoFileResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRepoFileResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRepoFileResponse} GetRepoFileResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoFileResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRepoFileResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRepoFileResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRepoFileResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRepoFileResponse} GetRepoFileResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRepoFileResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRepoFileResponse message.
         * @function verify
         * @memberof protos.GetRepoFileResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRepoFileResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a GetRepoFileResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRepoFileResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRepoFileResponse} GetRepoFileResponse
         */
        GetRepoFileResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRepoFileResponse)
                return object;
            var message = new $root.protos.GetRepoFileResponse();
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a GetRepoFileResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRepoFileResponse
         * @static
         * @param {protos.GetRepoFileResponse} message GetRepoFileResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRepoFileResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this GetRepoFileResponse to JSON.
         * @function toJSON
         * @memberof protos.GetRepoFileResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRepoFileResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRepoFileResponse;
    })();

    protos.CreatePRRequest = (function() {

        /**
         * Properties of a CreatePRRequest.
         * @memberof protos
         * @interface ICreatePRRequest
         * @property {protos.common.IAuth|null} [auth] CreatePRRequest auth
         * @property {string|null} [repoUrl] CreatePRRequest repoUrl
         * @property {string|null} [prName] CreatePRRequest prName
         * @property {string|null} [prBody] CreatePRRequest prBody
         * @property {string|null} [branchName] CreatePRRequest branchName
         * @property {Array.<protos.CreatePRRequest.IPRFile>|null} [files] CreatePRRequest files
         */

        /**
         * Constructs a new CreatePRRequest.
         * @memberof protos
         * @classdesc Represents a CreatePRRequest.
         * @implements ICreatePRRequest
         * @constructor
         * @param {protos.ICreatePRRequest=} [properties] Properties to set
         */
        function CreatePRRequest(properties) {
            this.files = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreatePRRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreatePRRequest
         * @instance
         */
        CreatePRRequest.prototype.auth = null;

        /**
         * CreatePRRequest repoUrl.
         * @member {string} repoUrl
         * @memberof protos.CreatePRRequest
         * @instance
         */
        CreatePRRequest.prototype.repoUrl = "";

        /**
         * CreatePRRequest prName.
         * @member {string} prName
         * @memberof protos.CreatePRRequest
         * @instance
         */
        CreatePRRequest.prototype.prName = "";

        /**
         * CreatePRRequest prBody.
         * @member {string} prBody
         * @memberof protos.CreatePRRequest
         * @instance
         */
        CreatePRRequest.prototype.prBody = "";

        /**
         * CreatePRRequest branchName.
         * @member {string} branchName
         * @memberof protos.CreatePRRequest
         * @instance
         */
        CreatePRRequest.prototype.branchName = "";

        /**
         * CreatePRRequest files.
         * @member {Array.<protos.CreatePRRequest.IPRFile>} files
         * @memberof protos.CreatePRRequest
         * @instance
         */
        CreatePRRequest.prototype.files = $util.emptyArray;

        /**
         * Creates a new CreatePRRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreatePRRequest
         * @static
         * @param {protos.ICreatePRRequest=} [properties] Properties to set
         * @returns {protos.CreatePRRequest} CreatePRRequest instance
         */
        CreatePRRequest.create = function create(properties) {
            return new CreatePRRequest(properties);
        };

        /**
         * Encodes the specified CreatePRRequest message. Does not implicitly {@link protos.CreatePRRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreatePRRequest
         * @static
         * @param {protos.ICreatePRRequest} message CreatePRRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePRRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.repoUrl != null && Object.hasOwnProperty.call(message, "repoUrl"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.repoUrl);
            if (message.prName != null && Object.hasOwnProperty.call(message, "prName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.prName);
            if (message.prBody != null && Object.hasOwnProperty.call(message, "prBody"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.prBody);
            if (message.branchName != null && Object.hasOwnProperty.call(message, "branchName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.branchName);
            if (message.files != null && message.files.length)
                for (var i = 0; i < message.files.length; ++i)
                    $root.protos.CreatePRRequest.PRFile.encode(message.files[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreatePRRequest message, length delimited. Does not implicitly {@link protos.CreatePRRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreatePRRequest
         * @static
         * @param {protos.ICreatePRRequest} message CreatePRRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePRRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreatePRRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreatePRRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreatePRRequest} CreatePRRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePRRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreatePRRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.repoUrl = reader.string();
                    break;
                case 2:
                    message.prName = reader.string();
                    break;
                case 3:
                    message.prBody = reader.string();
                    break;
                case 4:
                    message.branchName = reader.string();
                    break;
                case 5:
                    if (!(message.files && message.files.length))
                        message.files = [];
                    message.files.push($root.protos.CreatePRRequest.PRFile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreatePRRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreatePRRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreatePRRequest} CreatePRRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePRRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreatePRRequest message.
         * @function verify
         * @memberof protos.CreatePRRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreatePRRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.repoUrl != null && message.hasOwnProperty("repoUrl"))
                if (!$util.isString(message.repoUrl))
                    return "repoUrl: string expected";
            if (message.prName != null && message.hasOwnProperty("prName"))
                if (!$util.isString(message.prName))
                    return "prName: string expected";
            if (message.prBody != null && message.hasOwnProperty("prBody"))
                if (!$util.isString(message.prBody))
                    return "prBody: string expected";
            if (message.branchName != null && message.hasOwnProperty("branchName"))
                if (!$util.isString(message.branchName))
                    return "branchName: string expected";
            if (message.files != null && message.hasOwnProperty("files")) {
                if (!Array.isArray(message.files))
                    return "files: array expected";
                for (var i = 0; i < message.files.length; ++i) {
                    var error = $root.protos.CreatePRRequest.PRFile.verify(message.files[i]);
                    if (error)
                        return "files." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreatePRRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreatePRRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreatePRRequest} CreatePRRequest
         */
        CreatePRRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreatePRRequest)
                return object;
            var message = new $root.protos.CreatePRRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreatePRRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.repoUrl != null)
                message.repoUrl = String(object.repoUrl);
            if (object.prName != null)
                message.prName = String(object.prName);
            if (object.prBody != null)
                message.prBody = String(object.prBody);
            if (object.branchName != null)
                message.branchName = String(object.branchName);
            if (object.files) {
                if (!Array.isArray(object.files))
                    throw TypeError(".protos.CreatePRRequest.files: array expected");
                message.files = [];
                for (var i = 0; i < object.files.length; ++i) {
                    if (typeof object.files[i] !== "object")
                        throw TypeError(".protos.CreatePRRequest.files: object expected");
                    message.files[i] = $root.protos.CreatePRRequest.PRFile.fromObject(object.files[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreatePRRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreatePRRequest
         * @static
         * @param {protos.CreatePRRequest} message CreatePRRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreatePRRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.files = [];
            if (options.defaults) {
                object.repoUrl = "";
                object.prName = "";
                object.prBody = "";
                object.branchName = "";
                object.auth = null;
            }
            if (message.repoUrl != null && message.hasOwnProperty("repoUrl"))
                object.repoUrl = message.repoUrl;
            if (message.prName != null && message.hasOwnProperty("prName"))
                object.prName = message.prName;
            if (message.prBody != null && message.hasOwnProperty("prBody"))
                object.prBody = message.prBody;
            if (message.branchName != null && message.hasOwnProperty("branchName"))
                object.branchName = message.branchName;
            if (message.files && message.files.length) {
                object.files = [];
                for (var j = 0; j < message.files.length; ++j)
                    object.files[j] = $root.protos.CreatePRRequest.PRFile.toObject(message.files[j], options);
            }
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreatePRRequest to JSON.
         * @function toJSON
         * @memberof protos.CreatePRRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreatePRRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        CreatePRRequest.PRFile = (function() {

            /**
             * Properties of a PRFile.
             * @memberof protos.CreatePRRequest
             * @interface IPRFile
             * @property {string|null} [path] PRFile path
             * @property {Uint8Array|null} [contents] PRFile contents
             */

            /**
             * Constructs a new PRFile.
             * @memberof protos.CreatePRRequest
             * @classdesc Represents a PRFile.
             * @implements IPRFile
             * @constructor
             * @param {protos.CreatePRRequest.IPRFile=} [properties] Properties to set
             */
            function PRFile(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PRFile path.
             * @member {string} path
             * @memberof protos.CreatePRRequest.PRFile
             * @instance
             */
            PRFile.prototype.path = "";

            /**
             * PRFile contents.
             * @member {Uint8Array} contents
             * @memberof protos.CreatePRRequest.PRFile
             * @instance
             */
            PRFile.prototype.contents = $util.newBuffer([]);

            /**
             * Creates a new PRFile instance using the specified properties.
             * @function create
             * @memberof protos.CreatePRRequest.PRFile
             * @static
             * @param {protos.CreatePRRequest.IPRFile=} [properties] Properties to set
             * @returns {protos.CreatePRRequest.PRFile} PRFile instance
             */
            PRFile.create = function create(properties) {
                return new PRFile(properties);
            };

            /**
             * Encodes the specified PRFile message. Does not implicitly {@link protos.CreatePRRequest.PRFile.verify|verify} messages.
             * @function encode
             * @memberof protos.CreatePRRequest.PRFile
             * @static
             * @param {protos.CreatePRRequest.IPRFile} message PRFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PRFile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.contents != null && Object.hasOwnProperty.call(message, "contents"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contents);
                return writer;
            };

            /**
             * Encodes the specified PRFile message, length delimited. Does not implicitly {@link protos.CreatePRRequest.PRFile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.CreatePRRequest.PRFile
             * @static
             * @param {protos.CreatePRRequest.IPRFile} message PRFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PRFile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PRFile message from the specified reader or buffer.
             * @function decode
             * @memberof protos.CreatePRRequest.PRFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.CreatePRRequest.PRFile} PRFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PRFile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreatePRRequest.PRFile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.contents = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PRFile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.CreatePRRequest.PRFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.CreatePRRequest.PRFile} PRFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PRFile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PRFile message.
             * @function verify
             * @memberof protos.CreatePRRequest.PRFile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PRFile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.contents != null && message.hasOwnProperty("contents"))
                    if (!(message.contents && typeof message.contents.length === "number" || $util.isString(message.contents)))
                        return "contents: buffer expected";
                return null;
            };

            /**
             * Creates a PRFile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.CreatePRRequest.PRFile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.CreatePRRequest.PRFile} PRFile
             */
            PRFile.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.CreatePRRequest.PRFile)
                    return object;
                var message = new $root.protos.CreatePRRequest.PRFile();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.contents != null)
                    if (typeof object.contents === "string")
                        $util.base64.decode(object.contents, message.contents = $util.newBuffer($util.base64.length(object.contents)), 0);
                    else if (object.contents.length)
                        message.contents = object.contents;
                return message;
            };

            /**
             * Creates a plain object from a PRFile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.CreatePRRequest.PRFile
             * @static
             * @param {protos.CreatePRRequest.PRFile} message PRFile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PRFile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    if (options.bytes === String)
                        object.contents = "";
                    else {
                        object.contents = [];
                        if (options.bytes !== Array)
                            object.contents = $util.newBuffer(object.contents);
                    }
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.contents != null && message.hasOwnProperty("contents"))
                    object.contents = options.bytes === String ? $util.base64.encode(message.contents, 0, message.contents.length) : options.bytes === Array ? Array.prototype.slice.call(message.contents) : message.contents;
                return object;
            };

            /**
             * Converts this PRFile to JSON.
             * @function toJSON
             * @memberof protos.CreatePRRequest.PRFile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PRFile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PRFile;
        })();

        return CreatePRRequest;
    })();

    protos.CreatePRResponse = (function() {

        /**
         * Properties of a CreatePRResponse.
         * @memberof protos
         * @interface ICreatePRResponse
         * @property {string|null} [url] CreatePRResponse url
         * @property {string|null} [fullPath] CreatePRResponse fullPath
         */

        /**
         * Constructs a new CreatePRResponse.
         * @memberof protos
         * @classdesc Represents a CreatePRResponse.
         * @implements ICreatePRResponse
         * @constructor
         * @param {protos.ICreatePRResponse=} [properties] Properties to set
         */
        function CreatePRResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreatePRResponse url.
         * @member {string} url
         * @memberof protos.CreatePRResponse
         * @instance
         */
        CreatePRResponse.prototype.url = "";

        /**
         * CreatePRResponse fullPath.
         * @member {string} fullPath
         * @memberof protos.CreatePRResponse
         * @instance
         */
        CreatePRResponse.prototype.fullPath = "";

        /**
         * Creates a new CreatePRResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreatePRResponse
         * @static
         * @param {protos.ICreatePRResponse=} [properties] Properties to set
         * @returns {protos.CreatePRResponse} CreatePRResponse instance
         */
        CreatePRResponse.create = function create(properties) {
            return new CreatePRResponse(properties);
        };

        /**
         * Encodes the specified CreatePRResponse message. Does not implicitly {@link protos.CreatePRResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreatePRResponse
         * @static
         * @param {protos.ICreatePRResponse} message CreatePRResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePRResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.fullPath != null && Object.hasOwnProperty.call(message, "fullPath"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fullPath);
            return writer;
        };

        /**
         * Encodes the specified CreatePRResponse message, length delimited. Does not implicitly {@link protos.CreatePRResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreatePRResponse
         * @static
         * @param {protos.ICreatePRResponse} message CreatePRResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePRResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreatePRResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreatePRResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreatePRResponse} CreatePRResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePRResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreatePRResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.fullPath = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreatePRResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreatePRResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreatePRResponse} CreatePRResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePRResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreatePRResponse message.
         * @function verify
         * @memberof protos.CreatePRResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreatePRResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.fullPath != null && message.hasOwnProperty("fullPath"))
                if (!$util.isString(message.fullPath))
                    return "fullPath: string expected";
            return null;
        };

        /**
         * Creates a CreatePRResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreatePRResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreatePRResponse} CreatePRResponse
         */
        CreatePRResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreatePRResponse)
                return object;
            var message = new $root.protos.CreatePRResponse();
            if (object.url != null)
                message.url = String(object.url);
            if (object.fullPath != null)
                message.fullPath = String(object.fullPath);
            return message;
        };

        /**
         * Creates a plain object from a CreatePRResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreatePRResponse
         * @static
         * @param {protos.CreatePRResponse} message CreatePRResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreatePRResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.url = "";
                object.fullPath = "";
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.fullPath != null && message.hasOwnProperty("fullPath"))
                object.fullPath = message.fullPath;
            return object;
        };

        /**
         * Converts this CreatePRResponse to JSON.
         * @function toJSON
         * @memberof protos.CreatePRResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreatePRResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreatePRResponse;
    })();

    protos.Directory = (function() {

        /**
         * Properties of a Directory.
         * @memberof protos
         * @interface IDirectory
         * @property {string|null} [name] Directory name
         * @property {string|null} [fullPath] Directory fullPath
         * @property {Array.<protos.IFile>|null} [files] Directory files
         * @property {Object.<string,protos.IDirectory>|null} [dirs] Directory dirs
         */

        /**
         * Constructs a new Directory.
         * @memberof protos
         * @classdesc Represents a Directory.
         * @implements IDirectory
         * @constructor
         * @param {protos.IDirectory=} [properties] Properties to set
         */
        function Directory(properties) {
            this.files = [];
            this.dirs = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Directory name.
         * @member {string} name
         * @memberof protos.Directory
         * @instance
         */
        Directory.prototype.name = "";

        /**
         * Directory fullPath.
         * @member {string} fullPath
         * @memberof protos.Directory
         * @instance
         */
        Directory.prototype.fullPath = "";

        /**
         * Directory files.
         * @member {Array.<protos.IFile>} files
         * @memberof protos.Directory
         * @instance
         */
        Directory.prototype.files = $util.emptyArray;

        /**
         * Directory dirs.
         * @member {Object.<string,protos.IDirectory>} dirs
         * @memberof protos.Directory
         * @instance
         */
        Directory.prototype.dirs = $util.emptyObject;

        /**
         * Creates a new Directory instance using the specified properties.
         * @function create
         * @memberof protos.Directory
         * @static
         * @param {protos.IDirectory=} [properties] Properties to set
         * @returns {protos.Directory} Directory instance
         */
        Directory.create = function create(properties) {
            return new Directory(properties);
        };

        /**
         * Encodes the specified Directory message. Does not implicitly {@link protos.Directory.verify|verify} messages.
         * @function encode
         * @memberof protos.Directory
         * @static
         * @param {protos.IDirectory} message Directory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Directory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.fullPath != null && Object.hasOwnProperty.call(message, "fullPath"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fullPath);
            if (message.files != null && message.files.length)
                for (var i = 0; i < message.files.length; ++i)
                    $root.protos.File.encode(message.files[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.dirs != null && Object.hasOwnProperty.call(message, "dirs"))
                for (var keys = Object.keys(message.dirs), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.protos.Directory.encode(message.dirs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified Directory message, length delimited. Does not implicitly {@link protos.Directory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.Directory
         * @static
         * @param {protos.IDirectory} message Directory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Directory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Directory message from the specified reader or buffer.
         * @function decode
         * @memberof protos.Directory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.Directory} Directory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Directory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Directory(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.fullPath = reader.string();
                    break;
                case 3:
                    if (!(message.files && message.files.length))
                        message.files = [];
                    message.files.push($root.protos.File.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (message.dirs === $util.emptyObject)
                        message.dirs = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.protos.Directory.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.dirs[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Directory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.Directory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.Directory} Directory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Directory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Directory message.
         * @function verify
         * @memberof protos.Directory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Directory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.fullPath != null && message.hasOwnProperty("fullPath"))
                if (!$util.isString(message.fullPath))
                    return "fullPath: string expected";
            if (message.files != null && message.hasOwnProperty("files")) {
                if (!Array.isArray(message.files))
                    return "files: array expected";
                for (var i = 0; i < message.files.length; ++i) {
                    var error = $root.protos.File.verify(message.files[i]);
                    if (error)
                        return "files." + error;
                }
            }
            if (message.dirs != null && message.hasOwnProperty("dirs")) {
                if (!$util.isObject(message.dirs))
                    return "dirs: object expected";
                var key = Object.keys(message.dirs);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.protos.Directory.verify(message.dirs[key[i]]);
                    if (error)
                        return "dirs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Directory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.Directory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.Directory} Directory
         */
        Directory.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.Directory)
                return object;
            var message = new $root.protos.Directory();
            if (object.name != null)
                message.name = String(object.name);
            if (object.fullPath != null)
                message.fullPath = String(object.fullPath);
            if (object.files) {
                if (!Array.isArray(object.files))
                    throw TypeError(".protos.Directory.files: array expected");
                message.files = [];
                for (var i = 0; i < object.files.length; ++i) {
                    if (typeof object.files[i] !== "object")
                        throw TypeError(".protos.Directory.files: object expected");
                    message.files[i] = $root.protos.File.fromObject(object.files[i]);
                }
            }
            if (object.dirs) {
                if (typeof object.dirs !== "object")
                    throw TypeError(".protos.Directory.dirs: object expected");
                message.dirs = {};
                for (var keys = Object.keys(object.dirs), i = 0; i < keys.length; ++i) {
                    if (typeof object.dirs[keys[i]] !== "object")
                        throw TypeError(".protos.Directory.dirs: object expected");
                    message.dirs[keys[i]] = $root.protos.Directory.fromObject(object.dirs[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Directory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.Directory
         * @static
         * @param {protos.Directory} message Directory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Directory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.files = [];
            if (options.objects || options.defaults)
                object.dirs = {};
            if (options.defaults) {
                object.name = "";
                object.fullPath = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.fullPath != null && message.hasOwnProperty("fullPath"))
                object.fullPath = message.fullPath;
            if (message.files && message.files.length) {
                object.files = [];
                for (var j = 0; j < message.files.length; ++j)
                    object.files[j] = $root.protos.File.toObject(message.files[j], options);
            }
            var keys2;
            if (message.dirs && (keys2 = Object.keys(message.dirs)).length) {
                object.dirs = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.dirs[keys2[j]] = $root.protos.Directory.toObject(message.dirs[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this Directory to JSON.
         * @function toJSON
         * @memberof protos.Directory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Directory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Directory;
    })();

    protos.File = (function() {

        /**
         * Properties of a File.
         * @memberof protos
         * @interface IFile
         * @property {string|null} [name] File name
         * @property {string|null} [path] File path
         * @property {string|null} [sha] File sha
         * @property {number|Long|null} [size] File size
         */

        /**
         * Constructs a new File.
         * @memberof protos
         * @classdesc Represents a File.
         * @implements IFile
         * @constructor
         * @param {protos.IFile=} [properties] Properties to set
         */
        function File(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * File name.
         * @member {string} name
         * @memberof protos.File
         * @instance
         */
        File.prototype.name = "";

        /**
         * File path.
         * @member {string} path
         * @memberof protos.File
         * @instance
         */
        File.prototype.path = "";

        /**
         * File sha.
         * @member {string} sha
         * @memberof protos.File
         * @instance
         */
        File.prototype.sha = "";

        /**
         * File size.
         * @member {number|Long} size
         * @memberof protos.File
         * @instance
         */
        File.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new File instance using the specified properties.
         * @function create
         * @memberof protos.File
         * @static
         * @param {protos.IFile=} [properties] Properties to set
         * @returns {protos.File} File instance
         */
        File.create = function create(properties) {
            return new File(properties);
        };

        /**
         * Encodes the specified File message. Does not implicitly {@link protos.File.verify|verify} messages.
         * @function encode
         * @memberof protos.File
         * @static
         * @param {protos.IFile} message File message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        File.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
            if (message.sha != null && Object.hasOwnProperty.call(message, "sha"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.sha);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.size);
            return writer;
        };

        /**
         * Encodes the specified File message, length delimited. Does not implicitly {@link protos.File.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.File
         * @static
         * @param {protos.IFile} message File message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        File.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a File message from the specified reader or buffer.
         * @function decode
         * @memberof protos.File
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.File} File
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        File.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.File();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.path = reader.string();
                    break;
                case 3:
                    message.sha = reader.string();
                    break;
                case 4:
                    message.size = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a File message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.File
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.File} File
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        File.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a File message.
         * @function verify
         * @memberof protos.File
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        File.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.path != null && message.hasOwnProperty("path"))
                if (!$util.isString(message.path))
                    return "path: string expected";
            if (message.sha != null && message.hasOwnProperty("sha"))
                if (!$util.isString(message.sha))
                    return "sha: string expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                    return "size: integer|Long expected";
            return null;
        };

        /**
         * Creates a File message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.File
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.File} File
         */
        File.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.File)
                return object;
            var message = new $root.protos.File();
            if (object.name != null)
                message.name = String(object.name);
            if (object.path != null)
                message.path = String(object.path);
            if (object.sha != null)
                message.sha = String(object.sha);
            if (object.size != null)
                if ($util.Long)
                    (message.size = $util.Long.fromValue(object.size)).unsigned = false;
                else if (typeof object.size === "string")
                    message.size = parseInt(object.size, 10);
                else if (typeof object.size === "number")
                    message.size = object.size;
                else if (typeof object.size === "object")
                    message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a File message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.File
         * @static
         * @param {protos.File} message File
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        File.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.path = "";
                object.sha = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.size = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.sha != null && message.hasOwnProperty("sha"))
                object.sha = message.sha;
            if (message.size != null && message.hasOwnProperty("size"))
                if (typeof message.size === "number")
                    object.size = options.longs === String ? String(message.size) : message.size;
                else
                    object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
            return object;
        };

        /**
         * Converts this File to JSON.
         * @function toJSON
         * @memberof protos.File
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        File.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return File;
    })();

    protos.Service = (function() {

        /**
         * Properties of a Service.
         * @memberof protos
         * @interface IService
         * @property {string|null} [id] Service id
         * @property {string|null} [name] Service name
         * @property {Array.<protos.IRepository>|null} [repositories] Service repositories
         * @property {string|null} [notes] Service notes
         * @property {string|null} [ownerId] Service ownerId
         * @property {Array.<string>|null} [usedSchemas] Service usedSchemas
         */

        /**
         * Constructs a new Service.
         * @memberof protos
         * @classdesc Represents a Service.
         * @implements IService
         * @constructor
         * @param {protos.IService=} [properties] Properties to set
         */
        function Service(properties) {
            this.repositories = [];
            this.usedSchemas = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Service id.
         * @member {string} id
         * @memberof protos.Service
         * @instance
         */
        Service.prototype.id = "";

        /**
         * Service name.
         * @member {string} name
         * @memberof protos.Service
         * @instance
         */
        Service.prototype.name = "";

        /**
         * Service repositories.
         * @member {Array.<protos.IRepository>} repositories
         * @memberof protos.Service
         * @instance
         */
        Service.prototype.repositories = $util.emptyArray;

        /**
         * Service notes.
         * @member {string} notes
         * @memberof protos.Service
         * @instance
         */
        Service.prototype.notes = "";

        /**
         * Service ownerId.
         * @member {string} ownerId
         * @memberof protos.Service
         * @instance
         */
        Service.prototype.ownerId = "";

        /**
         * Service usedSchemas.
         * @member {Array.<string>} usedSchemas
         * @memberof protos.Service
         * @instance
         */
        Service.prototype.usedSchemas = $util.emptyArray;

        /**
         * Creates a new Service instance using the specified properties.
         * @function create
         * @memberof protos.Service
         * @static
         * @param {protos.IService=} [properties] Properties to set
         * @returns {protos.Service} Service instance
         */
        Service.create = function create(properties) {
            return new Service(properties);
        };

        /**
         * Encodes the specified Service message. Does not implicitly {@link protos.Service.verify|verify} messages.
         * @function encode
         * @memberof protos.Service
         * @static
         * @param {protos.IService} message Service message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Service.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.repositories != null && message.repositories.length)
                for (var i = 0; i < message.repositories.length; ++i)
                    $root.protos.Repository.encode(message.repositories[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.notes);
            if (message.ownerId != null && Object.hasOwnProperty.call(message, "ownerId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.ownerId);
            if (message.usedSchemas != null && message.usedSchemas.length)
                for (var i = 0; i < message.usedSchemas.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.usedSchemas[i]);
            return writer;
        };

        /**
         * Encodes the specified Service message, length delimited. Does not implicitly {@link protos.Service.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.Service
         * @static
         * @param {protos.IService} message Service message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Service.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Service message from the specified reader or buffer.
         * @function decode
         * @memberof protos.Service
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.Service} Service
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Service.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Service();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    if (!(message.repositories && message.repositories.length))
                        message.repositories = [];
                    message.repositories.push($root.protos.Repository.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.notes = reader.string();
                    break;
                case 5:
                    message.ownerId = reader.string();
                    break;
                case 6:
                    if (!(message.usedSchemas && message.usedSchemas.length))
                        message.usedSchemas = [];
                    message.usedSchemas.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Service message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.Service
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.Service} Service
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Service.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Service message.
         * @function verify
         * @memberof protos.Service
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Service.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.repositories != null && message.hasOwnProperty("repositories")) {
                if (!Array.isArray(message.repositories))
                    return "repositories: array expected";
                for (var i = 0; i < message.repositories.length; ++i) {
                    var error = $root.protos.Repository.verify(message.repositories[i]);
                    if (error)
                        return "repositories." + error;
                }
            }
            if (message.notes != null && message.hasOwnProperty("notes"))
                if (!$util.isString(message.notes))
                    return "notes: string expected";
            if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                if (!$util.isString(message.ownerId))
                    return "ownerId: string expected";
            if (message.usedSchemas != null && message.hasOwnProperty("usedSchemas")) {
                if (!Array.isArray(message.usedSchemas))
                    return "usedSchemas: array expected";
                for (var i = 0; i < message.usedSchemas.length; ++i)
                    if (!$util.isString(message.usedSchemas[i]))
                        return "usedSchemas: string[] expected";
            }
            return null;
        };

        /**
         * Creates a Service message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.Service
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.Service} Service
         */
        Service.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.Service)
                return object;
            var message = new $root.protos.Service();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.repositories) {
                if (!Array.isArray(object.repositories))
                    throw TypeError(".protos.Service.repositories: array expected");
                message.repositories = [];
                for (var i = 0; i < object.repositories.length; ++i) {
                    if (typeof object.repositories[i] !== "object")
                        throw TypeError(".protos.Service.repositories: object expected");
                    message.repositories[i] = $root.protos.Repository.fromObject(object.repositories[i]);
                }
            }
            if (object.notes != null)
                message.notes = String(object.notes);
            if (object.ownerId != null)
                message.ownerId = String(object.ownerId);
            if (object.usedSchemas) {
                if (!Array.isArray(object.usedSchemas))
                    throw TypeError(".protos.Service.usedSchemas: array expected");
                message.usedSchemas = [];
                for (var i = 0; i < object.usedSchemas.length; ++i)
                    message.usedSchemas[i] = String(object.usedSchemas[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a Service message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.Service
         * @static
         * @param {protos.Service} message Service
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Service.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.repositories = [];
                object.usedSchemas = [];
            }
            if (options.defaults) {
                object.id = "";
                object.name = "";
                object.notes = "";
                object.ownerId = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.repositories && message.repositories.length) {
                object.repositories = [];
                for (var j = 0; j < message.repositories.length; ++j)
                    object.repositories[j] = $root.protos.Repository.toObject(message.repositories[j], options);
            }
            if (message.notes != null && message.hasOwnProperty("notes"))
                object.notes = message.notes;
            if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                object.ownerId = message.ownerId;
            if (message.usedSchemas && message.usedSchemas.length) {
                object.usedSchemas = [];
                for (var j = 0; j < message.usedSchemas.length; ++j)
                    object.usedSchemas[j] = message.usedSchemas[j];
            }
            return object;
        };

        /**
         * Converts this Service to JSON.
         * @function toJSON
         * @memberof protos.Service
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Service.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Service;
    })();

    protos.Repository = (function() {

        /**
         * Properties of a Repository.
         * @memberof protos
         * @interface IRepository
         * @property {string|null} [_id] Repository _id
         * @property {protos.Repository.Type|null} [type] Repository type
         * @property {string|null} [organization] Repository organization
         * @property {string|null} [name] Repository name
         */

        /**
         * Constructs a new Repository.
         * @memberof protos
         * @classdesc Represents a Repository.
         * @implements IRepository
         * @constructor
         * @param {protos.IRepository=} [properties] Properties to set
         */
        function Repository(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Repository _id.
         * @member {string} _id
         * @memberof protos.Repository
         * @instance
         */
        Repository.prototype._id = "";

        /**
         * Repository type.
         * @member {protos.Repository.Type} type
         * @memberof protos.Repository
         * @instance
         */
        Repository.prototype.type = 0;

        /**
         * Repository organization.
         * @member {string} organization
         * @memberof protos.Repository
         * @instance
         */
        Repository.prototype.organization = "";

        /**
         * Repository name.
         * @member {string} name
         * @memberof protos.Repository
         * @instance
         */
        Repository.prototype.name = "";

        /**
         * Creates a new Repository instance using the specified properties.
         * @function create
         * @memberof protos.Repository
         * @static
         * @param {protos.IRepository=} [properties] Properties to set
         * @returns {protos.Repository} Repository instance
         */
        Repository.create = function create(properties) {
            return new Repository(properties);
        };

        /**
         * Encodes the specified Repository message. Does not implicitly {@link protos.Repository.verify|verify} messages.
         * @function encode
         * @memberof protos.Repository
         * @static
         * @param {protos.IRepository} message Repository message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Repository.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message._id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.organization != null && Object.hasOwnProperty.call(message, "organization"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.organization);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Repository message, length delimited. Does not implicitly {@link protos.Repository.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.Repository
         * @static
         * @param {protos.IRepository} message Repository message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Repository.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Repository message from the specified reader or buffer.
         * @function decode
         * @memberof protos.Repository
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.Repository} Repository
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Repository.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Repository();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message._id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.organization = reader.string();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Repository message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.Repository
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.Repository} Repository
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Repository.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Repository message.
         * @function verify
         * @memberof protos.Repository
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Repository.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message._id != null && message.hasOwnProperty("_id"))
                if (!$util.isString(message._id))
                    return "_id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.organization != null && message.hasOwnProperty("organization"))
                if (!$util.isString(message.organization))
                    return "organization: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Repository message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.Repository
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.Repository} Repository
         */
        Repository.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.Repository)
                return object;
            var message = new $root.protos.Repository();
            if (object._id != null)
                message._id = String(object._id);
            switch (object.type) {
            case "UNSET":
            case 0:
                message.type = 0;
                break;
            case "GITHUB":
            case 1:
                message.type = 1;
                break;
            case "GITLAB":
            case 2:
                message.type = 2;
                break;
            case "BITBUCKET":
            case 3:
                message.type = 3;
                break;
            }
            if (object.organization != null)
                message.organization = String(object.organization);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Repository message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.Repository
         * @static
         * @param {protos.Repository} message Repository
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Repository.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object._id = "";
                object.type = options.enums === String ? "UNSET" : 0;
                object.organization = "";
                object.name = "";
            }
            if (message._id != null && message.hasOwnProperty("_id"))
                object._id = message._id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protos.Repository.Type[message.type] : message.type;
            if (message.organization != null && message.hasOwnProperty("organization"))
                object.organization = message.organization;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Repository to JSON.
         * @function toJSON
         * @memberof protos.Repository
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Repository.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name protos.Repository.Type
         * @enum {number}
         * @property {number} UNSET=0 UNSET value
         * @property {number} GITHUB=1 GITHUB value
         * @property {number} GITLAB=2 GITLAB value
         * @property {number} BITBUCKET=3 BITBUCKET value
         */
        Repository.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSET"] = 0;
            values[valuesById[1] = "GITHUB"] = 1;
            values[valuesById[2] = "GITLAB"] = 2;
            values[valuesById[3] = "BITBUCKET"] = 3;
            return values;
        })();

        return Repository;
    })();

    protos.GetServiceRequest = (function() {

        /**
         * Properties of a GetServiceRequest.
         * @memberof protos
         * @interface IGetServiceRequest
         * @property {protos.common.IAuth|null} [auth] GetServiceRequest auth
         * @property {string|null} [id] GetServiceRequest id
         */

        /**
         * Constructs a new GetServiceRequest.
         * @memberof protos
         * @classdesc Represents a GetServiceRequest.
         * @implements IGetServiceRequest
         * @constructor
         * @param {protos.IGetServiceRequest=} [properties] Properties to set
         */
        function GetServiceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetServiceRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetServiceRequest
         * @instance
         */
        GetServiceRequest.prototype.auth = null;

        /**
         * GetServiceRequest id.
         * @member {string} id
         * @memberof protos.GetServiceRequest
         * @instance
         */
        GetServiceRequest.prototype.id = "";

        /**
         * Creates a new GetServiceRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetServiceRequest
         * @static
         * @param {protos.IGetServiceRequest=} [properties] Properties to set
         * @returns {protos.GetServiceRequest} GetServiceRequest instance
         */
        GetServiceRequest.create = function create(properties) {
            return new GetServiceRequest(properties);
        };

        /**
         * Encodes the specified GetServiceRequest message. Does not implicitly {@link protos.GetServiceRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetServiceRequest
         * @static
         * @param {protos.IGetServiceRequest} message GetServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetServiceRequest message, length delimited. Does not implicitly {@link protos.GetServiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetServiceRequest
         * @static
         * @param {protos.IGetServiceRequest} message GetServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetServiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetServiceRequest} GetServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetServiceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetServiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetServiceRequest} GetServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetServiceRequest message.
         * @function verify
         * @memberof protos.GetServiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetServiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a GetServiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetServiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetServiceRequest} GetServiceRequest
         */
        GetServiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetServiceRequest)
                return object;
            var message = new $root.protos.GetServiceRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetServiceRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a GetServiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetServiceRequest
         * @static
         * @param {protos.GetServiceRequest} message GetServiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetServiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetServiceRequest to JSON.
         * @function toJSON
         * @memberof protos.GetServiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetServiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetServiceRequest;
    })();

    protos.GetServiceResponse = (function() {

        /**
         * Properties of a GetServiceResponse.
         * @memberof protos
         * @interface IGetServiceResponse
         * @property {protos.IService|null} [service] GetServiceResponse service
         * @property {protos.common.IStatus|null} [status] GetServiceResponse status
         */

        /**
         * Constructs a new GetServiceResponse.
         * @memberof protos
         * @classdesc Represents a GetServiceResponse.
         * @implements IGetServiceResponse
         * @constructor
         * @param {protos.IGetServiceResponse=} [properties] Properties to set
         */
        function GetServiceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetServiceResponse service.
         * @member {protos.IService|null|undefined} service
         * @memberof protos.GetServiceResponse
         * @instance
         */
        GetServiceResponse.prototype.service = null;

        /**
         * GetServiceResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetServiceResponse
         * @instance
         */
        GetServiceResponse.prototype.status = null;

        /**
         * Creates a new GetServiceResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetServiceResponse
         * @static
         * @param {protos.IGetServiceResponse=} [properties] Properties to set
         * @returns {protos.GetServiceResponse} GetServiceResponse instance
         */
        GetServiceResponse.create = function create(properties) {
            return new GetServiceResponse(properties);
        };

        /**
         * Encodes the specified GetServiceResponse message. Does not implicitly {@link protos.GetServiceResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetServiceResponse
         * @static
         * @param {protos.IGetServiceResponse} message GetServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.service != null && Object.hasOwnProperty.call(message, "service"))
                $root.protos.Service.encode(message.service, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetServiceResponse message, length delimited. Does not implicitly {@link protos.GetServiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetServiceResponse
         * @static
         * @param {protos.IGetServiceResponse} message GetServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetServiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetServiceResponse} GetServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetServiceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.service = $root.protos.Service.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetServiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetServiceResponse} GetServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetServiceResponse message.
         * @function verify
         * @memberof protos.GetServiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetServiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.service != null && message.hasOwnProperty("service")) {
                var error = $root.protos.Service.verify(message.service);
                if (error)
                    return "service." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a GetServiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetServiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetServiceResponse} GetServiceResponse
         */
        GetServiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetServiceResponse)
                return object;
            var message = new $root.protos.GetServiceResponse();
            if (object.service != null) {
                if (typeof object.service !== "object")
                    throw TypeError(".protos.GetServiceResponse.service: object expected");
                message.service = $root.protos.Service.fromObject(object.service);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetServiceResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetServiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetServiceResponse
         * @static
         * @param {protos.GetServiceResponse} message GetServiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetServiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.service = null;
                object.status = null;
            }
            if (message.service != null && message.hasOwnProperty("service"))
                object.service = $root.protos.Service.toObject(message.service, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetServiceResponse to JSON.
         * @function toJSON
         * @memberof protos.GetServiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetServiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetServiceResponse;
    })();

    protos.GetAllServicesRequest = (function() {

        /**
         * Properties of a GetAllServicesRequest.
         * @memberof protos
         * @interface IGetAllServicesRequest
         * @property {protos.common.IAuth|null} [auth] GetAllServicesRequest auth
         */

        /**
         * Constructs a new GetAllServicesRequest.
         * @memberof protos
         * @classdesc Represents a GetAllServicesRequest.
         * @implements IGetAllServicesRequest
         * @constructor
         * @param {protos.IGetAllServicesRequest=} [properties] Properties to set
         */
        function GetAllServicesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllServicesRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllServicesRequest
         * @instance
         */
        GetAllServicesRequest.prototype.auth = null;

        /**
         * Creates a new GetAllServicesRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllServicesRequest
         * @static
         * @param {protos.IGetAllServicesRequest=} [properties] Properties to set
         * @returns {protos.GetAllServicesRequest} GetAllServicesRequest instance
         */
        GetAllServicesRequest.create = function create(properties) {
            return new GetAllServicesRequest(properties);
        };

        /**
         * Encodes the specified GetAllServicesRequest message. Does not implicitly {@link protos.GetAllServicesRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllServicesRequest
         * @static
         * @param {protos.IGetAllServicesRequest} message GetAllServicesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllServicesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllServicesRequest message, length delimited. Does not implicitly {@link protos.GetAllServicesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllServicesRequest
         * @static
         * @param {protos.IGetAllServicesRequest} message GetAllServicesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllServicesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllServicesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllServicesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllServicesRequest} GetAllServicesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllServicesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllServicesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllServicesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllServicesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllServicesRequest} GetAllServicesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllServicesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllServicesRequest message.
         * @function verify
         * @memberof protos.GetAllServicesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllServicesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllServicesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllServicesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllServicesRequest} GetAllServicesRequest
         */
        GetAllServicesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllServicesRequest)
                return object;
            var message = new $root.protos.GetAllServicesRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllServicesRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllServicesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllServicesRequest
         * @static
         * @param {protos.GetAllServicesRequest} message GetAllServicesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllServicesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllServicesRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllServicesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllServicesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllServicesRequest;
    })();

    protos.GetAllServicesResponse = (function() {

        /**
         * Properties of a GetAllServicesResponse.
         * @memberof protos
         * @interface IGetAllServicesResponse
         * @property {Array.<protos.IService>|null} [services] GetAllServicesResponse services
         * @property {protos.common.IStatus|null} [status] GetAllServicesResponse status
         */

        /**
         * Constructs a new GetAllServicesResponse.
         * @memberof protos
         * @classdesc Represents a GetAllServicesResponse.
         * @implements IGetAllServicesResponse
         * @constructor
         * @param {protos.IGetAllServicesResponse=} [properties] Properties to set
         */
        function GetAllServicesResponse(properties) {
            this.services = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllServicesResponse services.
         * @member {Array.<protos.IService>} services
         * @memberof protos.GetAllServicesResponse
         * @instance
         */
        GetAllServicesResponse.prototype.services = $util.emptyArray;

        /**
         * GetAllServicesResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetAllServicesResponse
         * @instance
         */
        GetAllServicesResponse.prototype.status = null;

        /**
         * Creates a new GetAllServicesResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllServicesResponse
         * @static
         * @param {protos.IGetAllServicesResponse=} [properties] Properties to set
         * @returns {protos.GetAllServicesResponse} GetAllServicesResponse instance
         */
        GetAllServicesResponse.create = function create(properties) {
            return new GetAllServicesResponse(properties);
        };

        /**
         * Encodes the specified GetAllServicesResponse message. Does not implicitly {@link protos.GetAllServicesResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllServicesResponse
         * @static
         * @param {protos.IGetAllServicesResponse} message GetAllServicesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllServicesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.services != null && message.services.length)
                for (var i = 0; i < message.services.length; ++i)
                    $root.protos.Service.encode(message.services[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllServicesResponse message, length delimited. Does not implicitly {@link protos.GetAllServicesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllServicesResponse
         * @static
         * @param {protos.IGetAllServicesResponse} message GetAllServicesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllServicesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllServicesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllServicesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllServicesResponse} GetAllServicesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllServicesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllServicesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.services && message.services.length))
                        message.services = [];
                    message.services.push($root.protos.Service.decode(reader, reader.uint32()));
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllServicesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllServicesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllServicesResponse} GetAllServicesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllServicesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllServicesResponse message.
         * @function verify
         * @memberof protos.GetAllServicesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllServicesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.services != null && message.hasOwnProperty("services")) {
                if (!Array.isArray(message.services))
                    return "services: array expected";
                for (var i = 0; i < message.services.length; ++i) {
                    var error = $root.protos.Service.verify(message.services[i]);
                    if (error)
                        return "services." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllServicesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllServicesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllServicesResponse} GetAllServicesResponse
         */
        GetAllServicesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllServicesResponse)
                return object;
            var message = new $root.protos.GetAllServicesResponse();
            if (object.services) {
                if (!Array.isArray(object.services))
                    throw TypeError(".protos.GetAllServicesResponse.services: array expected");
                message.services = [];
                for (var i = 0; i < object.services.length; ++i) {
                    if (typeof object.services[i] !== "object")
                        throw TypeError(".protos.GetAllServicesResponse.services: object expected");
                    message.services[i] = $root.protos.Service.fromObject(object.services[i]);
                }
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetAllServicesResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllServicesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllServicesResponse
         * @static
         * @param {protos.GetAllServicesResponse} message GetAllServicesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllServicesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.services = [];
            if (options.defaults)
                object.status = null;
            if (message.services && message.services.length) {
                object.services = [];
                for (var j = 0; j < message.services.length; ++j)
                    object.services[j] = $root.protos.Service.toObject(message.services[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetAllServicesResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllServicesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllServicesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllServicesResponse;
    })();

    protos.CreateServiceRequest = (function() {

        /**
         * Properties of a CreateServiceRequest.
         * @memberof protos
         * @interface ICreateServiceRequest
         * @property {protos.common.IAuth|null} [auth] CreateServiceRequest auth
         * @property {protos.IService|null} [service] CreateServiceRequest service
         */

        /**
         * Constructs a new CreateServiceRequest.
         * @memberof protos
         * @classdesc Represents a CreateServiceRequest.
         * @implements ICreateServiceRequest
         * @constructor
         * @param {protos.ICreateServiceRequest=} [properties] Properties to set
         */
        function CreateServiceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateServiceRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateServiceRequest
         * @instance
         */
        CreateServiceRequest.prototype.auth = null;

        /**
         * CreateServiceRequest service.
         * @member {protos.IService|null|undefined} service
         * @memberof protos.CreateServiceRequest
         * @instance
         */
        CreateServiceRequest.prototype.service = null;

        /**
         * Creates a new CreateServiceRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateServiceRequest
         * @static
         * @param {protos.ICreateServiceRequest=} [properties] Properties to set
         * @returns {protos.CreateServiceRequest} CreateServiceRequest instance
         */
        CreateServiceRequest.create = function create(properties) {
            return new CreateServiceRequest(properties);
        };

        /**
         * Encodes the specified CreateServiceRequest message. Does not implicitly {@link protos.CreateServiceRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateServiceRequest
         * @static
         * @param {protos.ICreateServiceRequest} message CreateServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateServiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.service != null && Object.hasOwnProperty.call(message, "service"))
                $root.protos.Service.encode(message.service, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateServiceRequest message, length delimited. Does not implicitly {@link protos.CreateServiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateServiceRequest
         * @static
         * @param {protos.ICreateServiceRequest} message CreateServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateServiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateServiceRequest} CreateServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateServiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateServiceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.service = $root.protos.Service.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateServiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateServiceRequest} CreateServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateServiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateServiceRequest message.
         * @function verify
         * @memberof protos.CreateServiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateServiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.service != null && message.hasOwnProperty("service")) {
                var error = $root.protos.Service.verify(message.service);
                if (error)
                    return "service." + error;
            }
            return null;
        };

        /**
         * Creates a CreateServiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateServiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateServiceRequest} CreateServiceRequest
         */
        CreateServiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateServiceRequest)
                return object;
            var message = new $root.protos.CreateServiceRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateServiceRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.service != null) {
                if (typeof object.service !== "object")
                    throw TypeError(".protos.CreateServiceRequest.service: object expected");
                message.service = $root.protos.Service.fromObject(object.service);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateServiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateServiceRequest
         * @static
         * @param {protos.CreateServiceRequest} message CreateServiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateServiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.service = null;
                object.auth = null;
            }
            if (message.service != null && message.hasOwnProperty("service"))
                object.service = $root.protos.Service.toObject(message.service, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateServiceRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateServiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateServiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateServiceRequest;
    })();

    protos.CreateServiceResponse = (function() {

        /**
         * Properties of a CreateServiceResponse.
         * @memberof protos
         * @interface ICreateServiceResponse
         * @property {protos.IService|null} [service] CreateServiceResponse service
         * @property {protos.common.IStatus|null} [status] CreateServiceResponse status
         */

        /**
         * Constructs a new CreateServiceResponse.
         * @memberof protos
         * @classdesc Represents a CreateServiceResponse.
         * @implements ICreateServiceResponse
         * @constructor
         * @param {protos.ICreateServiceResponse=} [properties] Properties to set
         */
        function CreateServiceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateServiceResponse service.
         * @member {protos.IService|null|undefined} service
         * @memberof protos.CreateServiceResponse
         * @instance
         */
        CreateServiceResponse.prototype.service = null;

        /**
         * CreateServiceResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.CreateServiceResponse
         * @instance
         */
        CreateServiceResponse.prototype.status = null;

        /**
         * Creates a new CreateServiceResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateServiceResponse
         * @static
         * @param {protos.ICreateServiceResponse=} [properties] Properties to set
         * @returns {protos.CreateServiceResponse} CreateServiceResponse instance
         */
        CreateServiceResponse.create = function create(properties) {
            return new CreateServiceResponse(properties);
        };

        /**
         * Encodes the specified CreateServiceResponse message. Does not implicitly {@link protos.CreateServiceResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateServiceResponse
         * @static
         * @param {protos.ICreateServiceResponse} message CreateServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateServiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.service != null && Object.hasOwnProperty.call(message, "service"))
                $root.protos.Service.encode(message.service, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateServiceResponse message, length delimited. Does not implicitly {@link protos.CreateServiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateServiceResponse
         * @static
         * @param {protos.ICreateServiceResponse} message CreateServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateServiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateServiceResponse} CreateServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateServiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateServiceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.service = $root.protos.Service.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateServiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateServiceResponse} CreateServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateServiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateServiceResponse message.
         * @function verify
         * @memberof protos.CreateServiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateServiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.service != null && message.hasOwnProperty("service")) {
                var error = $root.protos.Service.verify(message.service);
                if (error)
                    return "service." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a CreateServiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateServiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateServiceResponse} CreateServiceResponse
         */
        CreateServiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateServiceResponse)
                return object;
            var message = new $root.protos.CreateServiceResponse();
            if (object.service != null) {
                if (typeof object.service !== "object")
                    throw TypeError(".protos.CreateServiceResponse.service: object expected");
                message.service = $root.protos.Service.fromObject(object.service);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.CreateServiceResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateServiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateServiceResponse
         * @static
         * @param {protos.CreateServiceResponse} message CreateServiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateServiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.service = null;
                object.status = null;
            }
            if (message.service != null && message.hasOwnProperty("service"))
                object.service = $root.protos.Service.toObject(message.service, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this CreateServiceResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateServiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateServiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateServiceResponse;
    })();

    protos.UpdateServiceRequest = (function() {

        /**
         * Properties of an UpdateServiceRequest.
         * @memberof protos
         * @interface IUpdateServiceRequest
         * @property {protos.common.IAuth|null} [auth] UpdateServiceRequest auth
         * @property {protos.IService|null} [service] UpdateServiceRequest service
         */

        /**
         * Constructs a new UpdateServiceRequest.
         * @memberof protos
         * @classdesc Represents an UpdateServiceRequest.
         * @implements IUpdateServiceRequest
         * @constructor
         * @param {protos.IUpdateServiceRequest=} [properties] Properties to set
         */
        function UpdateServiceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateServiceRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateServiceRequest
         * @instance
         */
        UpdateServiceRequest.prototype.auth = null;

        /**
         * UpdateServiceRequest service.
         * @member {protos.IService|null|undefined} service
         * @memberof protos.UpdateServiceRequest
         * @instance
         */
        UpdateServiceRequest.prototype.service = null;

        /**
         * Creates a new UpdateServiceRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateServiceRequest
         * @static
         * @param {protos.IUpdateServiceRequest=} [properties] Properties to set
         * @returns {protos.UpdateServiceRequest} UpdateServiceRequest instance
         */
        UpdateServiceRequest.create = function create(properties) {
            return new UpdateServiceRequest(properties);
        };

        /**
         * Encodes the specified UpdateServiceRequest message. Does not implicitly {@link protos.UpdateServiceRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateServiceRequest
         * @static
         * @param {protos.IUpdateServiceRequest} message UpdateServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateServiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.service != null && Object.hasOwnProperty.call(message, "service"))
                $root.protos.Service.encode(message.service, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateServiceRequest message, length delimited. Does not implicitly {@link protos.UpdateServiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateServiceRequest
         * @static
         * @param {protos.IUpdateServiceRequest} message UpdateServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateServiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateServiceRequest} UpdateServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateServiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateServiceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.service = $root.protos.Service.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateServiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateServiceRequest} UpdateServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateServiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateServiceRequest message.
         * @function verify
         * @memberof protos.UpdateServiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateServiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.service != null && message.hasOwnProperty("service")) {
                var error = $root.protos.Service.verify(message.service);
                if (error)
                    return "service." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateServiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateServiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateServiceRequest} UpdateServiceRequest
         */
        UpdateServiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateServiceRequest)
                return object;
            var message = new $root.protos.UpdateServiceRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateServiceRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.service != null) {
                if (typeof object.service !== "object")
                    throw TypeError(".protos.UpdateServiceRequest.service: object expected");
                message.service = $root.protos.Service.fromObject(object.service);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateServiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateServiceRequest
         * @static
         * @param {protos.UpdateServiceRequest} message UpdateServiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateServiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.service = null;
                object.auth = null;
            }
            if (message.service != null && message.hasOwnProperty("service"))
                object.service = $root.protos.Service.toObject(message.service, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateServiceRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateServiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateServiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateServiceRequest;
    })();

    protos.UpdateServiceResponse = (function() {

        /**
         * Properties of an UpdateServiceResponse.
         * @memberof protos
         * @interface IUpdateServiceResponse
         * @property {protos.IService|null} [service] UpdateServiceResponse service
         * @property {protos.common.IStatus|null} [status] UpdateServiceResponse status
         */

        /**
         * Constructs a new UpdateServiceResponse.
         * @memberof protos
         * @classdesc Represents an UpdateServiceResponse.
         * @implements IUpdateServiceResponse
         * @constructor
         * @param {protos.IUpdateServiceResponse=} [properties] Properties to set
         */
        function UpdateServiceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateServiceResponse service.
         * @member {protos.IService|null|undefined} service
         * @memberof protos.UpdateServiceResponse
         * @instance
         */
        UpdateServiceResponse.prototype.service = null;

        /**
         * UpdateServiceResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateServiceResponse
         * @instance
         */
        UpdateServiceResponse.prototype.status = null;

        /**
         * Creates a new UpdateServiceResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateServiceResponse
         * @static
         * @param {protos.IUpdateServiceResponse=} [properties] Properties to set
         * @returns {protos.UpdateServiceResponse} UpdateServiceResponse instance
         */
        UpdateServiceResponse.create = function create(properties) {
            return new UpdateServiceResponse(properties);
        };

        /**
         * Encodes the specified UpdateServiceResponse message. Does not implicitly {@link protos.UpdateServiceResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateServiceResponse
         * @static
         * @param {protos.IUpdateServiceResponse} message UpdateServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateServiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.service != null && Object.hasOwnProperty.call(message, "service"))
                $root.protos.Service.encode(message.service, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateServiceResponse message, length delimited. Does not implicitly {@link protos.UpdateServiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateServiceResponse
         * @static
         * @param {protos.IUpdateServiceResponse} message UpdateServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateServiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateServiceResponse} UpdateServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateServiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateServiceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.service = $root.protos.Service.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateServiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateServiceResponse} UpdateServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateServiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateServiceResponse message.
         * @function verify
         * @memberof protos.UpdateServiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateServiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.service != null && message.hasOwnProperty("service")) {
                var error = $root.protos.Service.verify(message.service);
                if (error)
                    return "service." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateServiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateServiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateServiceResponse} UpdateServiceResponse
         */
        UpdateServiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateServiceResponse)
                return object;
            var message = new $root.protos.UpdateServiceResponse();
            if (object.service != null) {
                if (typeof object.service !== "object")
                    throw TypeError(".protos.UpdateServiceResponse.service: object expected");
                message.service = $root.protos.Service.fromObject(object.service);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateServiceResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateServiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateServiceResponse
         * @static
         * @param {protos.UpdateServiceResponse} message UpdateServiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateServiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.service = null;
                object.status = null;
            }
            if (message.service != null && message.hasOwnProperty("service"))
                object.service = $root.protos.Service.toObject(message.service, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateServiceResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateServiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateServiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateServiceResponse;
    })();

    protos.DeleteServiceRequest = (function() {

        /**
         * Properties of a DeleteServiceRequest.
         * @memberof protos
         * @interface IDeleteServiceRequest
         * @property {string|null} [id] DeleteServiceRequest id
         * @property {protos.common.IAuth|null} [auth] DeleteServiceRequest auth
         */

        /**
         * Constructs a new DeleteServiceRequest.
         * @memberof protos
         * @classdesc Represents a DeleteServiceRequest.
         * @implements IDeleteServiceRequest
         * @constructor
         * @param {protos.IDeleteServiceRequest=} [properties] Properties to set
         */
        function DeleteServiceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteServiceRequest id.
         * @member {string} id
         * @memberof protos.DeleteServiceRequest
         * @instance
         */
        DeleteServiceRequest.prototype.id = "";

        /**
         * DeleteServiceRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteServiceRequest
         * @instance
         */
        DeleteServiceRequest.prototype.auth = null;

        /**
         * Creates a new DeleteServiceRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteServiceRequest
         * @static
         * @param {protos.IDeleteServiceRequest=} [properties] Properties to set
         * @returns {protos.DeleteServiceRequest} DeleteServiceRequest instance
         */
        DeleteServiceRequest.create = function create(properties) {
            return new DeleteServiceRequest(properties);
        };

        /**
         * Encodes the specified DeleteServiceRequest message. Does not implicitly {@link protos.DeleteServiceRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteServiceRequest
         * @static
         * @param {protos.IDeleteServiceRequest} message DeleteServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteServiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteServiceRequest message, length delimited. Does not implicitly {@link protos.DeleteServiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteServiceRequest
         * @static
         * @param {protos.IDeleteServiceRequest} message DeleteServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteServiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteServiceRequest} DeleteServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteServiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteServiceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteServiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteServiceRequest} DeleteServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteServiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteServiceRequest message.
         * @function verify
         * @memberof protos.DeleteServiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteServiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteServiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteServiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteServiceRequest} DeleteServiceRequest
         */
        DeleteServiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteServiceRequest)
                return object;
            var message = new $root.protos.DeleteServiceRequest();
            if (object.id != null)
                message.id = String(object.id);
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteServiceRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteServiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteServiceRequest
         * @static
         * @param {protos.DeleteServiceRequest} message DeleteServiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteServiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteServiceRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteServiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteServiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteServiceRequest;
    })();

    protos.DeleteServiceResponse = (function() {

        /**
         * Properties of a DeleteServiceResponse.
         * @memberof protos
         * @interface IDeleteServiceResponse
         * @property {protos.common.IStatus|null} [status] DeleteServiceResponse status
         */

        /**
         * Constructs a new DeleteServiceResponse.
         * @memberof protos
         * @classdesc Represents a DeleteServiceResponse.
         * @implements IDeleteServiceResponse
         * @constructor
         * @param {protos.IDeleteServiceResponse=} [properties] Properties to set
         */
        function DeleteServiceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteServiceResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteServiceResponse
         * @instance
         */
        DeleteServiceResponse.prototype.status = null;

        /**
         * Creates a new DeleteServiceResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteServiceResponse
         * @static
         * @param {protos.IDeleteServiceResponse=} [properties] Properties to set
         * @returns {protos.DeleteServiceResponse} DeleteServiceResponse instance
         */
        DeleteServiceResponse.create = function create(properties) {
            return new DeleteServiceResponse(properties);
        };

        /**
         * Encodes the specified DeleteServiceResponse message. Does not implicitly {@link protos.DeleteServiceResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteServiceResponse
         * @static
         * @param {protos.IDeleteServiceResponse} message DeleteServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteServiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteServiceResponse message, length delimited. Does not implicitly {@link protos.DeleteServiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteServiceResponse
         * @static
         * @param {protos.IDeleteServiceResponse} message DeleteServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteServiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteServiceResponse} DeleteServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteServiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteServiceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteServiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteServiceResponse} DeleteServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteServiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteServiceResponse message.
         * @function verify
         * @memberof protos.DeleteServiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteServiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteServiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteServiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteServiceResponse} DeleteServiceResponse
         */
        DeleteServiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteServiceResponse)
                return object;
            var message = new $root.protos.DeleteServiceResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteServiceResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteServiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteServiceResponse
         * @static
         * @param {protos.DeleteServiceResponse} message DeleteServiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteServiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteServiceResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteServiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteServiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteServiceResponse;
    })();

    protos.LinkSchemaToServiceRequest = (function() {

        /**
         * Properties of a LinkSchemaToServiceRequest.
         * @memberof protos
         * @interface ILinkSchemaToServiceRequest
         * @property {protos.common.IAuth|null} [auth] LinkSchemaToServiceRequest auth
         * @property {string|null} [serviceId] LinkSchemaToServiceRequest serviceId
         * @property {string|null} [schemaId] LinkSchemaToServiceRequest schemaId
         */

        /**
         * Constructs a new LinkSchemaToServiceRequest.
         * @memberof protos
         * @classdesc Represents a LinkSchemaToServiceRequest.
         * @implements ILinkSchemaToServiceRequest
         * @constructor
         * @param {protos.ILinkSchemaToServiceRequest=} [properties] Properties to set
         */
        function LinkSchemaToServiceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinkSchemaToServiceRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.LinkSchemaToServiceRequest
         * @instance
         */
        LinkSchemaToServiceRequest.prototype.auth = null;

        /**
         * LinkSchemaToServiceRequest serviceId.
         * @member {string} serviceId
         * @memberof protos.LinkSchemaToServiceRequest
         * @instance
         */
        LinkSchemaToServiceRequest.prototype.serviceId = "";

        /**
         * LinkSchemaToServiceRequest schemaId.
         * @member {string} schemaId
         * @memberof protos.LinkSchemaToServiceRequest
         * @instance
         */
        LinkSchemaToServiceRequest.prototype.schemaId = "";

        /**
         * Creates a new LinkSchemaToServiceRequest instance using the specified properties.
         * @function create
         * @memberof protos.LinkSchemaToServiceRequest
         * @static
         * @param {protos.ILinkSchemaToServiceRequest=} [properties] Properties to set
         * @returns {protos.LinkSchemaToServiceRequest} LinkSchemaToServiceRequest instance
         */
        LinkSchemaToServiceRequest.create = function create(properties) {
            return new LinkSchemaToServiceRequest(properties);
        };

        /**
         * Encodes the specified LinkSchemaToServiceRequest message. Does not implicitly {@link protos.LinkSchemaToServiceRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.LinkSchemaToServiceRequest
         * @static
         * @param {protos.ILinkSchemaToServiceRequest} message LinkSchemaToServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkSchemaToServiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceId != null && Object.hasOwnProperty.call(message, "serviceId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serviceId);
            if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LinkSchemaToServiceRequest message, length delimited. Does not implicitly {@link protos.LinkSchemaToServiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.LinkSchemaToServiceRequest
         * @static
         * @param {protos.ILinkSchemaToServiceRequest} message LinkSchemaToServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkSchemaToServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinkSchemaToServiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.LinkSchemaToServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.LinkSchemaToServiceRequest} LinkSchemaToServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkSchemaToServiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.LinkSchemaToServiceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.serviceId = reader.string();
                    break;
                case 2:
                    message.schemaId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinkSchemaToServiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.LinkSchemaToServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.LinkSchemaToServiceRequest} LinkSchemaToServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkSchemaToServiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinkSchemaToServiceRequest message.
         * @function verify
         * @memberof protos.LinkSchemaToServiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinkSchemaToServiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                if (!$util.isString(message.serviceId))
                    return "serviceId: string expected";
            if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                if (!$util.isString(message.schemaId))
                    return "schemaId: string expected";
            return null;
        };

        /**
         * Creates a LinkSchemaToServiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.LinkSchemaToServiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.LinkSchemaToServiceRequest} LinkSchemaToServiceRequest
         */
        LinkSchemaToServiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.LinkSchemaToServiceRequest)
                return object;
            var message = new $root.protos.LinkSchemaToServiceRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.LinkSchemaToServiceRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.serviceId != null)
                message.serviceId = String(object.serviceId);
            if (object.schemaId != null)
                message.schemaId = String(object.schemaId);
            return message;
        };

        /**
         * Creates a plain object from a LinkSchemaToServiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.LinkSchemaToServiceRequest
         * @static
         * @param {protos.LinkSchemaToServiceRequest} message LinkSchemaToServiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinkSchemaToServiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serviceId = "";
                object.schemaId = "";
                object.auth = null;
            }
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                object.serviceId = message.serviceId;
            if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                object.schemaId = message.schemaId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this LinkSchemaToServiceRequest to JSON.
         * @function toJSON
         * @memberof protos.LinkSchemaToServiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinkSchemaToServiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinkSchemaToServiceRequest;
    })();

    protos.LinkSchemaToServiceResponse = (function() {

        /**
         * Properties of a LinkSchemaToServiceResponse.
         * @memberof protos
         * @interface ILinkSchemaToServiceResponse
         * @property {protos.common.IStatus|null} [status] LinkSchemaToServiceResponse status
         */

        /**
         * Constructs a new LinkSchemaToServiceResponse.
         * @memberof protos
         * @classdesc Represents a LinkSchemaToServiceResponse.
         * @implements ILinkSchemaToServiceResponse
         * @constructor
         * @param {protos.ILinkSchemaToServiceResponse=} [properties] Properties to set
         */
        function LinkSchemaToServiceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinkSchemaToServiceResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.LinkSchemaToServiceResponse
         * @instance
         */
        LinkSchemaToServiceResponse.prototype.status = null;

        /**
         * Creates a new LinkSchemaToServiceResponse instance using the specified properties.
         * @function create
         * @memberof protos.LinkSchemaToServiceResponse
         * @static
         * @param {protos.ILinkSchemaToServiceResponse=} [properties] Properties to set
         * @returns {protos.LinkSchemaToServiceResponse} LinkSchemaToServiceResponse instance
         */
        LinkSchemaToServiceResponse.create = function create(properties) {
            return new LinkSchemaToServiceResponse(properties);
        };

        /**
         * Encodes the specified LinkSchemaToServiceResponse message. Does not implicitly {@link protos.LinkSchemaToServiceResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.LinkSchemaToServiceResponse
         * @static
         * @param {protos.ILinkSchemaToServiceResponse} message LinkSchemaToServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkSchemaToServiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LinkSchemaToServiceResponse message, length delimited. Does not implicitly {@link protos.LinkSchemaToServiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.LinkSchemaToServiceResponse
         * @static
         * @param {protos.ILinkSchemaToServiceResponse} message LinkSchemaToServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkSchemaToServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinkSchemaToServiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.LinkSchemaToServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.LinkSchemaToServiceResponse} LinkSchemaToServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkSchemaToServiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.LinkSchemaToServiceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinkSchemaToServiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.LinkSchemaToServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.LinkSchemaToServiceResponse} LinkSchemaToServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkSchemaToServiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinkSchemaToServiceResponse message.
         * @function verify
         * @memberof protos.LinkSchemaToServiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinkSchemaToServiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a LinkSchemaToServiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.LinkSchemaToServiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.LinkSchemaToServiceResponse} LinkSchemaToServiceResponse
         */
        LinkSchemaToServiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.LinkSchemaToServiceResponse)
                return object;
            var message = new $root.protos.LinkSchemaToServiceResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.LinkSchemaToServiceResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a LinkSchemaToServiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.LinkSchemaToServiceResponse
         * @static
         * @param {protos.LinkSchemaToServiceResponse} message LinkSchemaToServiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinkSchemaToServiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this LinkSchemaToServiceResponse to JSON.
         * @function toJSON
         * @memberof protos.LinkSchemaToServiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinkSchemaToServiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinkSchemaToServiceResponse;
    })();

    protos.UnlinkSchemaFromServiceRequest = (function() {

        /**
         * Properties of an UnlinkSchemaFromServiceRequest.
         * @memberof protos
         * @interface IUnlinkSchemaFromServiceRequest
         * @property {protos.common.IAuth|null} [auth] UnlinkSchemaFromServiceRequest auth
         * @property {string|null} [serviceId] UnlinkSchemaFromServiceRequest serviceId
         * @property {string|null} [schemaId] UnlinkSchemaFromServiceRequest schemaId
         */

        /**
         * Constructs a new UnlinkSchemaFromServiceRequest.
         * @memberof protos
         * @classdesc Represents an UnlinkSchemaFromServiceRequest.
         * @implements IUnlinkSchemaFromServiceRequest
         * @constructor
         * @param {protos.IUnlinkSchemaFromServiceRequest=} [properties] Properties to set
         */
        function UnlinkSchemaFromServiceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnlinkSchemaFromServiceRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @instance
         */
        UnlinkSchemaFromServiceRequest.prototype.auth = null;

        /**
         * UnlinkSchemaFromServiceRequest serviceId.
         * @member {string} serviceId
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @instance
         */
        UnlinkSchemaFromServiceRequest.prototype.serviceId = "";

        /**
         * UnlinkSchemaFromServiceRequest schemaId.
         * @member {string} schemaId
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @instance
         */
        UnlinkSchemaFromServiceRequest.prototype.schemaId = "";

        /**
         * Creates a new UnlinkSchemaFromServiceRequest instance using the specified properties.
         * @function create
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @static
         * @param {protos.IUnlinkSchemaFromServiceRequest=} [properties] Properties to set
         * @returns {protos.UnlinkSchemaFromServiceRequest} UnlinkSchemaFromServiceRequest instance
         */
        UnlinkSchemaFromServiceRequest.create = function create(properties) {
            return new UnlinkSchemaFromServiceRequest(properties);
        };

        /**
         * Encodes the specified UnlinkSchemaFromServiceRequest message. Does not implicitly {@link protos.UnlinkSchemaFromServiceRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @static
         * @param {protos.IUnlinkSchemaFromServiceRequest} message UnlinkSchemaFromServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlinkSchemaFromServiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceId != null && Object.hasOwnProperty.call(message, "serviceId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serviceId);
            if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnlinkSchemaFromServiceRequest message, length delimited. Does not implicitly {@link protos.UnlinkSchemaFromServiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @static
         * @param {protos.IUnlinkSchemaFromServiceRequest} message UnlinkSchemaFromServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlinkSchemaFromServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlinkSchemaFromServiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UnlinkSchemaFromServiceRequest} UnlinkSchemaFromServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlinkSchemaFromServiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UnlinkSchemaFromServiceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.serviceId = reader.string();
                    break;
                case 2:
                    message.schemaId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlinkSchemaFromServiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UnlinkSchemaFromServiceRequest} UnlinkSchemaFromServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlinkSchemaFromServiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlinkSchemaFromServiceRequest message.
         * @function verify
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlinkSchemaFromServiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                if (!$util.isString(message.serviceId))
                    return "serviceId: string expected";
            if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                if (!$util.isString(message.schemaId))
                    return "schemaId: string expected";
            return null;
        };

        /**
         * Creates an UnlinkSchemaFromServiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UnlinkSchemaFromServiceRequest} UnlinkSchemaFromServiceRequest
         */
        UnlinkSchemaFromServiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UnlinkSchemaFromServiceRequest)
                return object;
            var message = new $root.protos.UnlinkSchemaFromServiceRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UnlinkSchemaFromServiceRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.serviceId != null)
                message.serviceId = String(object.serviceId);
            if (object.schemaId != null)
                message.schemaId = String(object.schemaId);
            return message;
        };

        /**
         * Creates a plain object from an UnlinkSchemaFromServiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @static
         * @param {protos.UnlinkSchemaFromServiceRequest} message UnlinkSchemaFromServiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlinkSchemaFromServiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serviceId = "";
                object.schemaId = "";
                object.auth = null;
            }
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                object.serviceId = message.serviceId;
            if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                object.schemaId = message.schemaId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UnlinkSchemaFromServiceRequest to JSON.
         * @function toJSON
         * @memberof protos.UnlinkSchemaFromServiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlinkSchemaFromServiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnlinkSchemaFromServiceRequest;
    })();

    protos.UnlinkSchemaFromServiceResponse = (function() {

        /**
         * Properties of an UnlinkSchemaFromServiceResponse.
         * @memberof protos
         * @interface IUnlinkSchemaFromServiceResponse
         * @property {protos.common.IStatus|null} [status] UnlinkSchemaFromServiceResponse status
         */

        /**
         * Constructs a new UnlinkSchemaFromServiceResponse.
         * @memberof protos
         * @classdesc Represents an UnlinkSchemaFromServiceResponse.
         * @implements IUnlinkSchemaFromServiceResponse
         * @constructor
         * @param {protos.IUnlinkSchemaFromServiceResponse=} [properties] Properties to set
         */
        function UnlinkSchemaFromServiceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnlinkSchemaFromServiceResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UnlinkSchemaFromServiceResponse
         * @instance
         */
        UnlinkSchemaFromServiceResponse.prototype.status = null;

        /**
         * Creates a new UnlinkSchemaFromServiceResponse instance using the specified properties.
         * @function create
         * @memberof protos.UnlinkSchemaFromServiceResponse
         * @static
         * @param {protos.IUnlinkSchemaFromServiceResponse=} [properties] Properties to set
         * @returns {protos.UnlinkSchemaFromServiceResponse} UnlinkSchemaFromServiceResponse instance
         */
        UnlinkSchemaFromServiceResponse.create = function create(properties) {
            return new UnlinkSchemaFromServiceResponse(properties);
        };

        /**
         * Encodes the specified UnlinkSchemaFromServiceResponse message. Does not implicitly {@link protos.UnlinkSchemaFromServiceResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UnlinkSchemaFromServiceResponse
         * @static
         * @param {protos.IUnlinkSchemaFromServiceResponse} message UnlinkSchemaFromServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlinkSchemaFromServiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnlinkSchemaFromServiceResponse message, length delimited. Does not implicitly {@link protos.UnlinkSchemaFromServiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UnlinkSchemaFromServiceResponse
         * @static
         * @param {protos.IUnlinkSchemaFromServiceResponse} message UnlinkSchemaFromServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlinkSchemaFromServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlinkSchemaFromServiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UnlinkSchemaFromServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UnlinkSchemaFromServiceResponse} UnlinkSchemaFromServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlinkSchemaFromServiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UnlinkSchemaFromServiceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlinkSchemaFromServiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UnlinkSchemaFromServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UnlinkSchemaFromServiceResponse} UnlinkSchemaFromServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlinkSchemaFromServiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlinkSchemaFromServiceResponse message.
         * @function verify
         * @memberof protos.UnlinkSchemaFromServiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlinkSchemaFromServiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UnlinkSchemaFromServiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UnlinkSchemaFromServiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UnlinkSchemaFromServiceResponse} UnlinkSchemaFromServiceResponse
         */
        UnlinkSchemaFromServiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UnlinkSchemaFromServiceResponse)
                return object;
            var message = new $root.protos.UnlinkSchemaFromServiceResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UnlinkSchemaFromServiceResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UnlinkSchemaFromServiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UnlinkSchemaFromServiceResponse
         * @static
         * @param {protos.UnlinkSchemaFromServiceResponse} message UnlinkSchemaFromServiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlinkSchemaFromServiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UnlinkSchemaFromServiceResponse to JSON.
         * @function toJSON
         * @memberof protos.UnlinkSchemaFromServiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlinkSchemaFromServiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnlinkSchemaFromServiceResponse;
    })();

    protos.LinkRepoToServiceRequest = (function() {

        /**
         * Properties of a LinkRepoToServiceRequest.
         * @memberof protos
         * @interface ILinkRepoToServiceRequest
         * @property {protos.common.IAuth|null} [auth] LinkRepoToServiceRequest auth
         * @property {string|null} [serviceId] LinkRepoToServiceRequest serviceId
         * @property {string|null} [repoUrl] LinkRepoToServiceRequest repoUrl
         */

        /**
         * Constructs a new LinkRepoToServiceRequest.
         * @memberof protos
         * @classdesc Represents a LinkRepoToServiceRequest.
         * @implements ILinkRepoToServiceRequest
         * @constructor
         * @param {protos.ILinkRepoToServiceRequest=} [properties] Properties to set
         */
        function LinkRepoToServiceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinkRepoToServiceRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.LinkRepoToServiceRequest
         * @instance
         */
        LinkRepoToServiceRequest.prototype.auth = null;

        /**
         * LinkRepoToServiceRequest serviceId.
         * @member {string} serviceId
         * @memberof protos.LinkRepoToServiceRequest
         * @instance
         */
        LinkRepoToServiceRequest.prototype.serviceId = "";

        /**
         * LinkRepoToServiceRequest repoUrl.
         * @member {string} repoUrl
         * @memberof protos.LinkRepoToServiceRequest
         * @instance
         */
        LinkRepoToServiceRequest.prototype.repoUrl = "";

        /**
         * Creates a new LinkRepoToServiceRequest instance using the specified properties.
         * @function create
         * @memberof protos.LinkRepoToServiceRequest
         * @static
         * @param {protos.ILinkRepoToServiceRequest=} [properties] Properties to set
         * @returns {protos.LinkRepoToServiceRequest} LinkRepoToServiceRequest instance
         */
        LinkRepoToServiceRequest.create = function create(properties) {
            return new LinkRepoToServiceRequest(properties);
        };

        /**
         * Encodes the specified LinkRepoToServiceRequest message. Does not implicitly {@link protos.LinkRepoToServiceRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.LinkRepoToServiceRequest
         * @static
         * @param {protos.ILinkRepoToServiceRequest} message LinkRepoToServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkRepoToServiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceId != null && Object.hasOwnProperty.call(message, "serviceId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serviceId);
            if (message.repoUrl != null && Object.hasOwnProperty.call(message, "repoUrl"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.repoUrl);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LinkRepoToServiceRequest message, length delimited. Does not implicitly {@link protos.LinkRepoToServiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.LinkRepoToServiceRequest
         * @static
         * @param {protos.ILinkRepoToServiceRequest} message LinkRepoToServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkRepoToServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinkRepoToServiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.LinkRepoToServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.LinkRepoToServiceRequest} LinkRepoToServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkRepoToServiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.LinkRepoToServiceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.serviceId = reader.string();
                    break;
                case 2:
                    message.repoUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinkRepoToServiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.LinkRepoToServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.LinkRepoToServiceRequest} LinkRepoToServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkRepoToServiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinkRepoToServiceRequest message.
         * @function verify
         * @memberof protos.LinkRepoToServiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinkRepoToServiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                if (!$util.isString(message.serviceId))
                    return "serviceId: string expected";
            if (message.repoUrl != null && message.hasOwnProperty("repoUrl"))
                if (!$util.isString(message.repoUrl))
                    return "repoUrl: string expected";
            return null;
        };

        /**
         * Creates a LinkRepoToServiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.LinkRepoToServiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.LinkRepoToServiceRequest} LinkRepoToServiceRequest
         */
        LinkRepoToServiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.LinkRepoToServiceRequest)
                return object;
            var message = new $root.protos.LinkRepoToServiceRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.LinkRepoToServiceRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.serviceId != null)
                message.serviceId = String(object.serviceId);
            if (object.repoUrl != null)
                message.repoUrl = String(object.repoUrl);
            return message;
        };

        /**
         * Creates a plain object from a LinkRepoToServiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.LinkRepoToServiceRequest
         * @static
         * @param {protos.LinkRepoToServiceRequest} message LinkRepoToServiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinkRepoToServiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serviceId = "";
                object.repoUrl = "";
                object.auth = null;
            }
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                object.serviceId = message.serviceId;
            if (message.repoUrl != null && message.hasOwnProperty("repoUrl"))
                object.repoUrl = message.repoUrl;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this LinkRepoToServiceRequest to JSON.
         * @function toJSON
         * @memberof protos.LinkRepoToServiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinkRepoToServiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinkRepoToServiceRequest;
    })();

    protos.LinkRepoToServiceResponse = (function() {

        /**
         * Properties of a LinkRepoToServiceResponse.
         * @memberof protos
         * @interface ILinkRepoToServiceResponse
         * @property {protos.common.IStatus|null} [status] LinkRepoToServiceResponse status
         */

        /**
         * Constructs a new LinkRepoToServiceResponse.
         * @memberof protos
         * @classdesc Represents a LinkRepoToServiceResponse.
         * @implements ILinkRepoToServiceResponse
         * @constructor
         * @param {protos.ILinkRepoToServiceResponse=} [properties] Properties to set
         */
        function LinkRepoToServiceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinkRepoToServiceResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.LinkRepoToServiceResponse
         * @instance
         */
        LinkRepoToServiceResponse.prototype.status = null;

        /**
         * Creates a new LinkRepoToServiceResponse instance using the specified properties.
         * @function create
         * @memberof protos.LinkRepoToServiceResponse
         * @static
         * @param {protos.ILinkRepoToServiceResponse=} [properties] Properties to set
         * @returns {protos.LinkRepoToServiceResponse} LinkRepoToServiceResponse instance
         */
        LinkRepoToServiceResponse.create = function create(properties) {
            return new LinkRepoToServiceResponse(properties);
        };

        /**
         * Encodes the specified LinkRepoToServiceResponse message. Does not implicitly {@link protos.LinkRepoToServiceResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.LinkRepoToServiceResponse
         * @static
         * @param {protos.ILinkRepoToServiceResponse} message LinkRepoToServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkRepoToServiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LinkRepoToServiceResponse message, length delimited. Does not implicitly {@link protos.LinkRepoToServiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.LinkRepoToServiceResponse
         * @static
         * @param {protos.ILinkRepoToServiceResponse} message LinkRepoToServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinkRepoToServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinkRepoToServiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.LinkRepoToServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.LinkRepoToServiceResponse} LinkRepoToServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkRepoToServiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.LinkRepoToServiceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinkRepoToServiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.LinkRepoToServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.LinkRepoToServiceResponse} LinkRepoToServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinkRepoToServiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinkRepoToServiceResponse message.
         * @function verify
         * @memberof protos.LinkRepoToServiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinkRepoToServiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a LinkRepoToServiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.LinkRepoToServiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.LinkRepoToServiceResponse} LinkRepoToServiceResponse
         */
        LinkRepoToServiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.LinkRepoToServiceResponse)
                return object;
            var message = new $root.protos.LinkRepoToServiceResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.LinkRepoToServiceResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a LinkRepoToServiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.LinkRepoToServiceResponse
         * @static
         * @param {protos.LinkRepoToServiceResponse} message LinkRepoToServiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinkRepoToServiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this LinkRepoToServiceResponse to JSON.
         * @function toJSON
         * @memberof protos.LinkRepoToServiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinkRepoToServiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinkRepoToServiceResponse;
    })();

    protos.UnlinkRepoFromServiceRequest = (function() {

        /**
         * Properties of an UnlinkRepoFromServiceRequest.
         * @memberof protos
         * @interface IUnlinkRepoFromServiceRequest
         * @property {protos.common.IAuth|null} [auth] UnlinkRepoFromServiceRequest auth
         * @property {string|null} [serviceId] UnlinkRepoFromServiceRequest serviceId
         * @property {string|null} [repoId] UnlinkRepoFromServiceRequest repoId
         */

        /**
         * Constructs a new UnlinkRepoFromServiceRequest.
         * @memberof protos
         * @classdesc Represents an UnlinkRepoFromServiceRequest.
         * @implements IUnlinkRepoFromServiceRequest
         * @constructor
         * @param {protos.IUnlinkRepoFromServiceRequest=} [properties] Properties to set
         */
        function UnlinkRepoFromServiceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnlinkRepoFromServiceRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @instance
         */
        UnlinkRepoFromServiceRequest.prototype.auth = null;

        /**
         * UnlinkRepoFromServiceRequest serviceId.
         * @member {string} serviceId
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @instance
         */
        UnlinkRepoFromServiceRequest.prototype.serviceId = "";

        /**
         * UnlinkRepoFromServiceRequest repoId.
         * @member {string} repoId
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @instance
         */
        UnlinkRepoFromServiceRequest.prototype.repoId = "";

        /**
         * Creates a new UnlinkRepoFromServiceRequest instance using the specified properties.
         * @function create
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @static
         * @param {protos.IUnlinkRepoFromServiceRequest=} [properties] Properties to set
         * @returns {protos.UnlinkRepoFromServiceRequest} UnlinkRepoFromServiceRequest instance
         */
        UnlinkRepoFromServiceRequest.create = function create(properties) {
            return new UnlinkRepoFromServiceRequest(properties);
        };

        /**
         * Encodes the specified UnlinkRepoFromServiceRequest message. Does not implicitly {@link protos.UnlinkRepoFromServiceRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @static
         * @param {protos.IUnlinkRepoFromServiceRequest} message UnlinkRepoFromServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlinkRepoFromServiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceId != null && Object.hasOwnProperty.call(message, "serviceId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serviceId);
            if (message.repoId != null && Object.hasOwnProperty.call(message, "repoId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.repoId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnlinkRepoFromServiceRequest message, length delimited. Does not implicitly {@link protos.UnlinkRepoFromServiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @static
         * @param {protos.IUnlinkRepoFromServiceRequest} message UnlinkRepoFromServiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlinkRepoFromServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlinkRepoFromServiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UnlinkRepoFromServiceRequest} UnlinkRepoFromServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlinkRepoFromServiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UnlinkRepoFromServiceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.serviceId = reader.string();
                    break;
                case 2:
                    message.repoId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlinkRepoFromServiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UnlinkRepoFromServiceRequest} UnlinkRepoFromServiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlinkRepoFromServiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlinkRepoFromServiceRequest message.
         * @function verify
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlinkRepoFromServiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                if (!$util.isString(message.serviceId))
                    return "serviceId: string expected";
            if (message.repoId != null && message.hasOwnProperty("repoId"))
                if (!$util.isString(message.repoId))
                    return "repoId: string expected";
            return null;
        };

        /**
         * Creates an UnlinkRepoFromServiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UnlinkRepoFromServiceRequest} UnlinkRepoFromServiceRequest
         */
        UnlinkRepoFromServiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UnlinkRepoFromServiceRequest)
                return object;
            var message = new $root.protos.UnlinkRepoFromServiceRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UnlinkRepoFromServiceRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.serviceId != null)
                message.serviceId = String(object.serviceId);
            if (object.repoId != null)
                message.repoId = String(object.repoId);
            return message;
        };

        /**
         * Creates a plain object from an UnlinkRepoFromServiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @static
         * @param {protos.UnlinkRepoFromServiceRequest} message UnlinkRepoFromServiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlinkRepoFromServiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serviceId = "";
                object.repoId = "";
                object.auth = null;
            }
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                object.serviceId = message.serviceId;
            if (message.repoId != null && message.hasOwnProperty("repoId"))
                object.repoId = message.repoId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UnlinkRepoFromServiceRequest to JSON.
         * @function toJSON
         * @memberof protos.UnlinkRepoFromServiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlinkRepoFromServiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnlinkRepoFromServiceRequest;
    })();

    protos.UnlinkRepoFromServiceResponse = (function() {

        /**
         * Properties of an UnlinkRepoFromServiceResponse.
         * @memberof protos
         * @interface IUnlinkRepoFromServiceResponse
         * @property {protos.common.IStatus|null} [status] UnlinkRepoFromServiceResponse status
         */

        /**
         * Constructs a new UnlinkRepoFromServiceResponse.
         * @memberof protos
         * @classdesc Represents an UnlinkRepoFromServiceResponse.
         * @implements IUnlinkRepoFromServiceResponse
         * @constructor
         * @param {protos.IUnlinkRepoFromServiceResponse=} [properties] Properties to set
         */
        function UnlinkRepoFromServiceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnlinkRepoFromServiceResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UnlinkRepoFromServiceResponse
         * @instance
         */
        UnlinkRepoFromServiceResponse.prototype.status = null;

        /**
         * Creates a new UnlinkRepoFromServiceResponse instance using the specified properties.
         * @function create
         * @memberof protos.UnlinkRepoFromServiceResponse
         * @static
         * @param {protos.IUnlinkRepoFromServiceResponse=} [properties] Properties to set
         * @returns {protos.UnlinkRepoFromServiceResponse} UnlinkRepoFromServiceResponse instance
         */
        UnlinkRepoFromServiceResponse.create = function create(properties) {
            return new UnlinkRepoFromServiceResponse(properties);
        };

        /**
         * Encodes the specified UnlinkRepoFromServiceResponse message. Does not implicitly {@link protos.UnlinkRepoFromServiceResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UnlinkRepoFromServiceResponse
         * @static
         * @param {protos.IUnlinkRepoFromServiceResponse} message UnlinkRepoFromServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlinkRepoFromServiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnlinkRepoFromServiceResponse message, length delimited. Does not implicitly {@link protos.UnlinkRepoFromServiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UnlinkRepoFromServiceResponse
         * @static
         * @param {protos.IUnlinkRepoFromServiceResponse} message UnlinkRepoFromServiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlinkRepoFromServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlinkRepoFromServiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UnlinkRepoFromServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UnlinkRepoFromServiceResponse} UnlinkRepoFromServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlinkRepoFromServiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UnlinkRepoFromServiceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlinkRepoFromServiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UnlinkRepoFromServiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UnlinkRepoFromServiceResponse} UnlinkRepoFromServiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlinkRepoFromServiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlinkRepoFromServiceResponse message.
         * @function verify
         * @memberof protos.UnlinkRepoFromServiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlinkRepoFromServiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UnlinkRepoFromServiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UnlinkRepoFromServiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UnlinkRepoFromServiceResponse} UnlinkRepoFromServiceResponse
         */
        UnlinkRepoFromServiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UnlinkRepoFromServiceResponse)
                return object;
            var message = new $root.protos.UnlinkRepoFromServiceResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UnlinkRepoFromServiceResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UnlinkRepoFromServiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UnlinkRepoFromServiceResponse
         * @static
         * @param {protos.UnlinkRepoFromServiceResponse} message UnlinkRepoFromServiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlinkRepoFromServiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UnlinkRepoFromServiceResponse to JSON.
         * @function toJSON
         * @memberof protos.UnlinkRepoFromServiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlinkRepoFromServiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnlinkRepoFromServiceResponse;
    })();

    protos.GetServerOptionsRequest = (function() {

        /**
         * Properties of a GetServerOptionsRequest.
         * @memberof protos
         * @interface IGetServerOptionsRequest
         * @property {protos.common.IAuth|null} [auth] GetServerOptionsRequest auth
         */

        /**
         * Constructs a new GetServerOptionsRequest.
         * @memberof protos
         * @classdesc Represents a GetServerOptionsRequest.
         * @implements IGetServerOptionsRequest
         * @constructor
         * @param {protos.IGetServerOptionsRequest=} [properties] Properties to set
         */
        function GetServerOptionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetServerOptionsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetServerOptionsRequest
         * @instance
         */
        GetServerOptionsRequest.prototype.auth = null;

        /**
         * Creates a new GetServerOptionsRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.IGetServerOptionsRequest=} [properties] Properties to set
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest instance
         */
        GetServerOptionsRequest.create = function create(properties) {
            return new GetServerOptionsRequest(properties);
        };

        /**
         * Encodes the specified GetServerOptionsRequest message. Does not implicitly {@link protos.GetServerOptionsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.IGetServerOptionsRequest} message GetServerOptionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetServerOptionsRequest message, length delimited. Does not implicitly {@link protos.GetServerOptionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.IGetServerOptionsRequest} message GetServerOptionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetServerOptionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetServerOptionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetServerOptionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetServerOptionsRequest message.
         * @function verify
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetServerOptionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetServerOptionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest
         */
        GetServerOptionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetServerOptionsRequest)
                return object;
            var message = new $root.protos.GetServerOptionsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetServerOptionsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetServerOptionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.GetServerOptionsRequest} message GetServerOptionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetServerOptionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetServerOptionsRequest to JSON.
         * @function toJSON
         * @memberof protos.GetServerOptionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetServerOptionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetServerOptionsRequest;
    })();

    protos.GetServerOptionsResponse = (function() {

        /**
         * Properties of a GetServerOptionsResponse.
         * @memberof protos
         * @interface IGetServerOptionsResponse
         * @property {protos.opts.IServerOptions|null} [serverOptions] GetServerOptionsResponse serverOptions
         */

        /**
         * Constructs a new GetServerOptionsResponse.
         * @memberof protos
         * @classdesc Represents a GetServerOptionsResponse.
         * @implements IGetServerOptionsResponse
         * @constructor
         * @param {protos.IGetServerOptionsResponse=} [properties] Properties to set
         */
        function GetServerOptionsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetServerOptionsResponse serverOptions.
         * @member {protos.opts.IServerOptions|null|undefined} serverOptions
         * @memberof protos.GetServerOptionsResponse
         * @instance
         */
        GetServerOptionsResponse.prototype.serverOptions = null;

        /**
         * Creates a new GetServerOptionsResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.IGetServerOptionsResponse=} [properties] Properties to set
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse instance
         */
        GetServerOptionsResponse.create = function create(properties) {
            return new GetServerOptionsResponse(properties);
        };

        /**
         * Encodes the specified GetServerOptionsResponse message. Does not implicitly {@link protos.GetServerOptionsResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.IGetServerOptionsResponse} message GetServerOptionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverOptions != null && Object.hasOwnProperty.call(message, "serverOptions"))
                $root.protos.opts.ServerOptions.encode(message.serverOptions, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetServerOptionsResponse message, length delimited. Does not implicitly {@link protos.GetServerOptionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.IGetServerOptionsResponse} message GetServerOptionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetServerOptionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetServerOptionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverOptions = $root.protos.opts.ServerOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetServerOptionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetServerOptionsResponse message.
         * @function verify
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetServerOptionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverOptions != null && message.hasOwnProperty("serverOptions")) {
                var error = $root.protos.opts.ServerOptions.verify(message.serverOptions);
                if (error)
                    return "serverOptions." + error;
            }
            return null;
        };

        /**
         * Creates a GetServerOptionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse
         */
        GetServerOptionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetServerOptionsResponse)
                return object;
            var message = new $root.protos.GetServerOptionsResponse();
            if (object.serverOptions != null) {
                if (typeof object.serverOptions !== "object")
                    throw TypeError(".protos.GetServerOptionsResponse.serverOptions: object expected");
                message.serverOptions = $root.protos.opts.ServerOptions.fromObject(object.serverOptions);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetServerOptionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.GetServerOptionsResponse} message GetServerOptionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetServerOptionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.serverOptions = null;
            if (message.serverOptions != null && message.hasOwnProperty("serverOptions"))
                object.serverOptions = $root.protos.opts.ServerOptions.toObject(message.serverOptions, options);
            return object;
        };

        /**
         * Converts this GetServerOptionsResponse to JSON.
         * @function toJSON
         * @memberof protos.GetServerOptionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetServerOptionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetServerOptionsResponse;
    })();

    protos.SetServerOptionsRequest = (function() {

        /**
         * Properties of a SetServerOptionsRequest.
         * @memberof protos
         * @interface ISetServerOptionsRequest
         * @property {protos.common.IAuth|null} [auth] SetServerOptionsRequest auth
         * @property {string|null} [vcserviceToken] SetServerOptionsRequest vcserviceToken
         */

        /**
         * Constructs a new SetServerOptionsRequest.
         * @memberof protos
         * @classdesc Represents a SetServerOptionsRequest.
         * @implements ISetServerOptionsRequest
         * @constructor
         * @param {protos.ISetServerOptionsRequest=} [properties] Properties to set
         */
        function SetServerOptionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetServerOptionsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.SetServerOptionsRequest
         * @instance
         */
        SetServerOptionsRequest.prototype.auth = null;

        /**
         * SetServerOptionsRequest vcserviceToken.
         * @member {string} vcserviceToken
         * @memberof protos.SetServerOptionsRequest
         * @instance
         */
        SetServerOptionsRequest.prototype.vcserviceToken = "";

        /**
         * Creates a new SetServerOptionsRequest instance using the specified properties.
         * @function create
         * @memberof protos.SetServerOptionsRequest
         * @static
         * @param {protos.ISetServerOptionsRequest=} [properties] Properties to set
         * @returns {protos.SetServerOptionsRequest} SetServerOptionsRequest instance
         */
        SetServerOptionsRequest.create = function create(properties) {
            return new SetServerOptionsRequest(properties);
        };

        /**
         * Encodes the specified SetServerOptionsRequest message. Does not implicitly {@link protos.SetServerOptionsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.SetServerOptionsRequest
         * @static
         * @param {protos.ISetServerOptionsRequest} message SetServerOptionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetServerOptionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vcserviceToken != null && Object.hasOwnProperty.call(message, "vcserviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.vcserviceToken);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetServerOptionsRequest message, length delimited. Does not implicitly {@link protos.SetServerOptionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.SetServerOptionsRequest
         * @static
         * @param {protos.ISetServerOptionsRequest} message SetServerOptionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetServerOptionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetServerOptionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.SetServerOptionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.SetServerOptionsRequest} SetServerOptionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetServerOptionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.SetServerOptionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.vcserviceToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetServerOptionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.SetServerOptionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.SetServerOptionsRequest} SetServerOptionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetServerOptionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetServerOptionsRequest message.
         * @function verify
         * @memberof protos.SetServerOptionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetServerOptionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.vcserviceToken != null && message.hasOwnProperty("vcserviceToken"))
                if (!$util.isString(message.vcserviceToken))
                    return "vcserviceToken: string expected";
            return null;
        };

        /**
         * Creates a SetServerOptionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.SetServerOptionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.SetServerOptionsRequest} SetServerOptionsRequest
         */
        SetServerOptionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.SetServerOptionsRequest)
                return object;
            var message = new $root.protos.SetServerOptionsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.SetServerOptionsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.vcserviceToken != null)
                message.vcserviceToken = String(object.vcserviceToken);
            return message;
        };

        /**
         * Creates a plain object from a SetServerOptionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.SetServerOptionsRequest
         * @static
         * @param {protos.SetServerOptionsRequest} message SetServerOptionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetServerOptionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.vcserviceToken = "";
                object.auth = null;
            }
            if (message.vcserviceToken != null && message.hasOwnProperty("vcserviceToken"))
                object.vcserviceToken = message.vcserviceToken;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this SetServerOptionsRequest to JSON.
         * @function toJSON
         * @memberof protos.SetServerOptionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetServerOptionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetServerOptionsRequest;
    })();

    protos.SetServerOptionsResponse = (function() {

        /**
         * Properties of a SetServerOptionsResponse.
         * @memberof protos
         * @interface ISetServerOptionsResponse
         * @property {protos.opts.IServerOptions|null} [serverOptions] SetServerOptionsResponse serverOptions
         * @property {protos.common.IStatus|null} [status] SetServerOptionsResponse status
         */

        /**
         * Constructs a new SetServerOptionsResponse.
         * @memberof protos
         * @classdesc Represents a SetServerOptionsResponse.
         * @implements ISetServerOptionsResponse
         * @constructor
         * @param {protos.ISetServerOptionsResponse=} [properties] Properties to set
         */
        function SetServerOptionsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetServerOptionsResponse serverOptions.
         * @member {protos.opts.IServerOptions|null|undefined} serverOptions
         * @memberof protos.SetServerOptionsResponse
         * @instance
         */
        SetServerOptionsResponse.prototype.serverOptions = null;

        /**
         * SetServerOptionsResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.SetServerOptionsResponse
         * @instance
         */
        SetServerOptionsResponse.prototype.status = null;

        /**
         * Creates a new SetServerOptionsResponse instance using the specified properties.
         * @function create
         * @memberof protos.SetServerOptionsResponse
         * @static
         * @param {protos.ISetServerOptionsResponse=} [properties] Properties to set
         * @returns {protos.SetServerOptionsResponse} SetServerOptionsResponse instance
         */
        SetServerOptionsResponse.create = function create(properties) {
            return new SetServerOptionsResponse(properties);
        };

        /**
         * Encodes the specified SetServerOptionsResponse message. Does not implicitly {@link protos.SetServerOptionsResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.SetServerOptionsResponse
         * @static
         * @param {protos.ISetServerOptionsResponse} message SetServerOptionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetServerOptionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverOptions != null && Object.hasOwnProperty.call(message, "serverOptions"))
                $root.protos.opts.ServerOptions.encode(message.serverOptions, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetServerOptionsResponse message, length delimited. Does not implicitly {@link protos.SetServerOptionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.SetServerOptionsResponse
         * @static
         * @param {protos.ISetServerOptionsResponse} message SetServerOptionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetServerOptionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetServerOptionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.SetServerOptionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.SetServerOptionsResponse} SetServerOptionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetServerOptionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.SetServerOptionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverOptions = $root.protos.opts.ServerOptions.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetServerOptionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.SetServerOptionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.SetServerOptionsResponse} SetServerOptionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetServerOptionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetServerOptionsResponse message.
         * @function verify
         * @memberof protos.SetServerOptionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetServerOptionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverOptions != null && message.hasOwnProperty("serverOptions")) {
                var error = $root.protos.opts.ServerOptions.verify(message.serverOptions);
                if (error)
                    return "serverOptions." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a SetServerOptionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.SetServerOptionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.SetServerOptionsResponse} SetServerOptionsResponse
         */
        SetServerOptionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.SetServerOptionsResponse)
                return object;
            var message = new $root.protos.SetServerOptionsResponse();
            if (object.serverOptions != null) {
                if (typeof object.serverOptions !== "object")
                    throw TypeError(".protos.SetServerOptionsResponse.serverOptions: object expected");
                message.serverOptions = $root.protos.opts.ServerOptions.fromObject(object.serverOptions);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.SetServerOptionsResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a SetServerOptionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.SetServerOptionsResponse
         * @static
         * @param {protos.SetServerOptionsResponse} message SetServerOptionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetServerOptionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverOptions = null;
                object.status = null;
            }
            if (message.serverOptions != null && message.hasOwnProperty("serverOptions"))
                object.serverOptions = $root.protos.opts.ServerOptions.toObject(message.serverOptions, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this SetServerOptionsResponse to JSON.
         * @function toJSON
         * @memberof protos.SetServerOptionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetServerOptionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetServerOptionsResponse;
    })();

    protos.VCService = (function() {

        /**
         * Constructs a new VCService service.
         * @memberof protos
         * @classdesc Represents a VCService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function VCService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (VCService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = VCService;

        /**
         * Creates new VCService service using the specified rpc implementation.
         * @function create
         * @memberof protos.VCService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {VCService} RPC service. Useful where requests and/or responses are streamed.
         */
        VCService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link protos.VCService#connect}.
         * @memberof protos.VCService
         * @typedef ConnectCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.VCEvent} [response] VCEvent
         */

        /**
         * Calls Connect.
         * @function connect
         * @memberof protos.VCService
         * @instance
         * @param {protos.IConnectAuthRequest} request ConnectAuthRequest message or plain object
         * @param {protos.VCService.ConnectCallback} callback Node-style callback called with the error, if any, and VCEvent
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VCService.prototype.connect = function connect(request, callback) {
            return this.rpcCall(connect, $root.protos.ConnectAuthRequest, $root.protos.VCEvent, request, callback);
        }, "name", { value: "Connect" });

        /**
         * Calls Connect.
         * @function connect
         * @memberof protos.VCService
         * @instance
         * @param {protos.IConnectAuthRequest} request ConnectAuthRequest message or plain object
         * @returns {Promise<protos.VCEvent>} Promise
         * @variation 2
         */

        return VCService;
    })();

    protos.VCEvent = (function() {

        /**
         * Properties of a VCEvent.
         * @memberof protos
         * @interface IVCEvent
         * @property {protos.VCEvent.Type|null} [type] VCEvent type
         * @property {protos.IAuthResponse|null} [authResponse] VCEvent authResponse
         * @property {protos.IGithubEvent|null} [githubEvent] VCEvent githubEvent
         * @property {protos.IGitlabEvent|null} [gitlabEvent] VCEvent gitlabEvent
         * @property {protos.IBitbucketEvent|null} [bitbucketEvent] VCEvent bitbucketEvent
         * @property {protos.INewJwtToken|null} [newJwtToken] VCEvent newJwtToken
         */

        /**
         * Constructs a new VCEvent.
         * @memberof protos
         * @classdesc Represents a VCEvent.
         * @implements IVCEvent
         * @constructor
         * @param {protos.IVCEvent=} [properties] Properties to set
         */
        function VCEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VCEvent type.
         * @member {protos.VCEvent.Type} type
         * @memberof protos.VCEvent
         * @instance
         */
        VCEvent.prototype.type = 0;

        /**
         * VCEvent authResponse.
         * @member {protos.IAuthResponse|null|undefined} authResponse
         * @memberof protos.VCEvent
         * @instance
         */
        VCEvent.prototype.authResponse = null;

        /**
         * VCEvent githubEvent.
         * @member {protos.IGithubEvent|null|undefined} githubEvent
         * @memberof protos.VCEvent
         * @instance
         */
        VCEvent.prototype.githubEvent = null;

        /**
         * VCEvent gitlabEvent.
         * @member {protos.IGitlabEvent|null|undefined} gitlabEvent
         * @memberof protos.VCEvent
         * @instance
         */
        VCEvent.prototype.gitlabEvent = null;

        /**
         * VCEvent bitbucketEvent.
         * @member {protos.IBitbucketEvent|null|undefined} bitbucketEvent
         * @memberof protos.VCEvent
         * @instance
         */
        VCEvent.prototype.bitbucketEvent = null;

        /**
         * VCEvent newJwtToken.
         * @member {protos.INewJwtToken|null|undefined} newJwtToken
         * @memberof protos.VCEvent
         * @instance
         */
        VCEvent.prototype.newJwtToken = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * VCEvent vcEvent.
         * @member {"authResponse"|"githubEvent"|"gitlabEvent"|"bitbucketEvent"|"newJwtToken"|undefined} vcEvent
         * @memberof protos.VCEvent
         * @instance
         */
        Object.defineProperty(VCEvent.prototype, "vcEvent", {
            get: $util.oneOfGetter($oneOfFields = ["authResponse", "githubEvent", "gitlabEvent", "bitbucketEvent", "newJwtToken"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new VCEvent instance using the specified properties.
         * @function create
         * @memberof protos.VCEvent
         * @static
         * @param {protos.IVCEvent=} [properties] Properties to set
         * @returns {protos.VCEvent} VCEvent instance
         */
        VCEvent.create = function create(properties) {
            return new VCEvent(properties);
        };

        /**
         * Encodes the specified VCEvent message. Does not implicitly {@link protos.VCEvent.verify|verify} messages.
         * @function encode
         * @memberof protos.VCEvent
         * @static
         * @param {protos.IVCEvent} message VCEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VCEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.authResponse != null && Object.hasOwnProperty.call(message, "authResponse"))
                $root.protos.AuthResponse.encode(message.authResponse, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
            if (message.githubEvent != null && Object.hasOwnProperty.call(message, "githubEvent"))
                $root.protos.GithubEvent.encode(message.githubEvent, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.gitlabEvent != null && Object.hasOwnProperty.call(message, "gitlabEvent"))
                $root.protos.GitlabEvent.encode(message.gitlabEvent, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            if (message.bitbucketEvent != null && Object.hasOwnProperty.call(message, "bitbucketEvent"))
                $root.protos.BitbucketEvent.encode(message.bitbucketEvent, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
            if (message.newJwtToken != null && Object.hasOwnProperty.call(message, "newJwtToken"))
                $root.protos.NewJwtToken.encode(message.newJwtToken, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VCEvent message, length delimited. Does not implicitly {@link protos.VCEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.VCEvent
         * @static
         * @param {protos.IVCEvent} message VCEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VCEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VCEvent message from the specified reader or buffer.
         * @function decode
         * @memberof protos.VCEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.VCEvent} VCEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VCEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.VCEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 100:
                    message.authResponse = $root.protos.AuthResponse.decode(reader, reader.uint32());
                    break;
                case 101:
                    message.githubEvent = $root.protos.GithubEvent.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.gitlabEvent = $root.protos.GitlabEvent.decode(reader, reader.uint32());
                    break;
                case 103:
                    message.bitbucketEvent = $root.protos.BitbucketEvent.decode(reader, reader.uint32());
                    break;
                case 104:
                    message.newJwtToken = $root.protos.NewJwtToken.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VCEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.VCEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.VCEvent} VCEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VCEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VCEvent message.
         * @function verify
         * @memberof protos.VCEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VCEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.authResponse != null && message.hasOwnProperty("authResponse")) {
                properties.vcEvent = 1;
                {
                    var error = $root.protos.AuthResponse.verify(message.authResponse);
                    if (error)
                        return "authResponse." + error;
                }
            }
            if (message.githubEvent != null && message.hasOwnProperty("githubEvent")) {
                if (properties.vcEvent === 1)
                    return "vcEvent: multiple values";
                properties.vcEvent = 1;
                {
                    var error = $root.protos.GithubEvent.verify(message.githubEvent);
                    if (error)
                        return "githubEvent." + error;
                }
            }
            if (message.gitlabEvent != null && message.hasOwnProperty("gitlabEvent")) {
                if (properties.vcEvent === 1)
                    return "vcEvent: multiple values";
                properties.vcEvent = 1;
                {
                    var error = $root.protos.GitlabEvent.verify(message.gitlabEvent);
                    if (error)
                        return "gitlabEvent." + error;
                }
            }
            if (message.bitbucketEvent != null && message.hasOwnProperty("bitbucketEvent")) {
                if (properties.vcEvent === 1)
                    return "vcEvent: multiple values";
                properties.vcEvent = 1;
                {
                    var error = $root.protos.BitbucketEvent.verify(message.bitbucketEvent);
                    if (error)
                        return "bitbucketEvent." + error;
                }
            }
            if (message.newJwtToken != null && message.hasOwnProperty("newJwtToken")) {
                if (properties.vcEvent === 1)
                    return "vcEvent: multiple values";
                properties.vcEvent = 1;
                {
                    var error = $root.protos.NewJwtToken.verify(message.newJwtToken);
                    if (error)
                        return "newJwtToken." + error;
                }
            }
            return null;
        };

        /**
         * Creates a VCEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.VCEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.VCEvent} VCEvent
         */
        VCEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.VCEvent)
                return object;
            var message = new $root.protos.VCEvent();
            switch (object.type) {
            case "UNSET":
            case 0:
                message.type = 0;
                break;
            case "AUTH_RESPONSE":
            case 1:
                message.type = 1;
                break;
            case "NEW_JWT_TOKEN":
            case 2:
                message.type = 2;
                break;
            case "GITHUB":
            case 3:
                message.type = 3;
                break;
            case "GITLAB":
            case 4:
                message.type = 4;
                break;
            case "BITBUCKET":
            case 5:
                message.type = 5;
                break;
            }
            if (object.authResponse != null) {
                if (typeof object.authResponse !== "object")
                    throw TypeError(".protos.VCEvent.authResponse: object expected");
                message.authResponse = $root.protos.AuthResponse.fromObject(object.authResponse);
            }
            if (object.githubEvent != null) {
                if (typeof object.githubEvent !== "object")
                    throw TypeError(".protos.VCEvent.githubEvent: object expected");
                message.githubEvent = $root.protos.GithubEvent.fromObject(object.githubEvent);
            }
            if (object.gitlabEvent != null) {
                if (typeof object.gitlabEvent !== "object")
                    throw TypeError(".protos.VCEvent.gitlabEvent: object expected");
                message.gitlabEvent = $root.protos.GitlabEvent.fromObject(object.gitlabEvent);
            }
            if (object.bitbucketEvent != null) {
                if (typeof object.bitbucketEvent !== "object")
                    throw TypeError(".protos.VCEvent.bitbucketEvent: object expected");
                message.bitbucketEvent = $root.protos.BitbucketEvent.fromObject(object.bitbucketEvent);
            }
            if (object.newJwtToken != null) {
                if (typeof object.newJwtToken !== "object")
                    throw TypeError(".protos.VCEvent.newJwtToken: object expected");
                message.newJwtToken = $root.protos.NewJwtToken.fromObject(object.newJwtToken);
            }
            return message;
        };

        /**
         * Creates a plain object from a VCEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.VCEvent
         * @static
         * @param {protos.VCEvent} message VCEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VCEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = options.enums === String ? "UNSET" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protos.VCEvent.Type[message.type] : message.type;
            if (message.authResponse != null && message.hasOwnProperty("authResponse")) {
                object.authResponse = $root.protos.AuthResponse.toObject(message.authResponse, options);
                if (options.oneofs)
                    object.vcEvent = "authResponse";
            }
            if (message.githubEvent != null && message.hasOwnProperty("githubEvent")) {
                object.githubEvent = $root.protos.GithubEvent.toObject(message.githubEvent, options);
                if (options.oneofs)
                    object.vcEvent = "githubEvent";
            }
            if (message.gitlabEvent != null && message.hasOwnProperty("gitlabEvent")) {
                object.gitlabEvent = $root.protos.GitlabEvent.toObject(message.gitlabEvent, options);
                if (options.oneofs)
                    object.vcEvent = "gitlabEvent";
            }
            if (message.bitbucketEvent != null && message.hasOwnProperty("bitbucketEvent")) {
                object.bitbucketEvent = $root.protos.BitbucketEvent.toObject(message.bitbucketEvent, options);
                if (options.oneofs)
                    object.vcEvent = "bitbucketEvent";
            }
            if (message.newJwtToken != null && message.hasOwnProperty("newJwtToken")) {
                object.newJwtToken = $root.protos.NewJwtToken.toObject(message.newJwtToken, options);
                if (options.oneofs)
                    object.vcEvent = "newJwtToken";
            }
            return object;
        };

        /**
         * Converts this VCEvent to JSON.
         * @function toJSON
         * @memberof protos.VCEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VCEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name protos.VCEvent.Type
         * @enum {number}
         * @property {number} UNSET=0 UNSET value
         * @property {number} AUTH_RESPONSE=1 AUTH_RESPONSE value
         * @property {number} NEW_JWT_TOKEN=2 NEW_JWT_TOKEN value
         * @property {number} GITHUB=3 GITHUB value
         * @property {number} GITLAB=4 GITLAB value
         * @property {number} BITBUCKET=5 BITBUCKET value
         */
        VCEvent.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSET"] = 0;
            values[valuesById[1] = "AUTH_RESPONSE"] = 1;
            values[valuesById[2] = "NEW_JWT_TOKEN"] = 2;
            values[valuesById[3] = "GITHUB"] = 3;
            values[valuesById[4] = "GITLAB"] = 4;
            values[valuesById[5] = "BITBUCKET"] = 5;
            return values;
        })();

        return VCEvent;
    })();

    protos.GitlabEvent = (function() {

        /**
         * Properties of a GitlabEvent.
         * @memberof protos
         * @interface IGitlabEvent
         */

        /**
         * Constructs a new GitlabEvent.
         * @memberof protos
         * @classdesc Represents a GitlabEvent.
         * @implements IGitlabEvent
         * @constructor
         * @param {protos.IGitlabEvent=} [properties] Properties to set
         */
        function GitlabEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GitlabEvent instance using the specified properties.
         * @function create
         * @memberof protos.GitlabEvent
         * @static
         * @param {protos.IGitlabEvent=} [properties] Properties to set
         * @returns {protos.GitlabEvent} GitlabEvent instance
         */
        GitlabEvent.create = function create(properties) {
            return new GitlabEvent(properties);
        };

        /**
         * Encodes the specified GitlabEvent message. Does not implicitly {@link protos.GitlabEvent.verify|verify} messages.
         * @function encode
         * @memberof protos.GitlabEvent
         * @static
         * @param {protos.IGitlabEvent} message GitlabEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GitlabEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GitlabEvent message, length delimited. Does not implicitly {@link protos.GitlabEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GitlabEvent
         * @static
         * @param {protos.IGitlabEvent} message GitlabEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GitlabEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GitlabEvent message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GitlabEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GitlabEvent} GitlabEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GitlabEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GitlabEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GitlabEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GitlabEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GitlabEvent} GitlabEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GitlabEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GitlabEvent message.
         * @function verify
         * @memberof protos.GitlabEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GitlabEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GitlabEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GitlabEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GitlabEvent} GitlabEvent
         */
        GitlabEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GitlabEvent)
                return object;
            return new $root.protos.GitlabEvent();
        };

        /**
         * Creates a plain object from a GitlabEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GitlabEvent
         * @static
         * @param {protos.GitlabEvent} message GitlabEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GitlabEvent.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GitlabEvent to JSON.
         * @function toJSON
         * @memberof protos.GitlabEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GitlabEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GitlabEvent;
    })();

    protos.BitbucketEvent = (function() {

        /**
         * Properties of a BitbucketEvent.
         * @memberof protos
         * @interface IBitbucketEvent
         */

        /**
         * Constructs a new BitbucketEvent.
         * @memberof protos
         * @classdesc Represents a BitbucketEvent.
         * @implements IBitbucketEvent
         * @constructor
         * @param {protos.IBitbucketEvent=} [properties] Properties to set
         */
        function BitbucketEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BitbucketEvent instance using the specified properties.
         * @function create
         * @memberof protos.BitbucketEvent
         * @static
         * @param {protos.IBitbucketEvent=} [properties] Properties to set
         * @returns {protos.BitbucketEvent} BitbucketEvent instance
         */
        BitbucketEvent.create = function create(properties) {
            return new BitbucketEvent(properties);
        };

        /**
         * Encodes the specified BitbucketEvent message. Does not implicitly {@link protos.BitbucketEvent.verify|verify} messages.
         * @function encode
         * @memberof protos.BitbucketEvent
         * @static
         * @param {protos.IBitbucketEvent} message BitbucketEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BitbucketEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BitbucketEvent message, length delimited. Does not implicitly {@link protos.BitbucketEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.BitbucketEvent
         * @static
         * @param {protos.IBitbucketEvent} message BitbucketEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BitbucketEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BitbucketEvent message from the specified reader or buffer.
         * @function decode
         * @memberof protos.BitbucketEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.BitbucketEvent} BitbucketEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BitbucketEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.BitbucketEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BitbucketEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.BitbucketEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.BitbucketEvent} BitbucketEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BitbucketEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BitbucketEvent message.
         * @function verify
         * @memberof protos.BitbucketEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BitbucketEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a BitbucketEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.BitbucketEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.BitbucketEvent} BitbucketEvent
         */
        BitbucketEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.BitbucketEvent)
                return object;
            return new $root.protos.BitbucketEvent();
        };

        /**
         * Creates a plain object from a BitbucketEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.BitbucketEvent
         * @static
         * @param {protos.BitbucketEvent} message BitbucketEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BitbucketEvent.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this BitbucketEvent to JSON.
         * @function toJSON
         * @memberof protos.BitbucketEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BitbucketEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BitbucketEvent;
    })();

    protos.GithubEvent = (function() {

        /**
         * Properties of a GithubEvent.
         * @memberof protos
         * @interface IGithubEvent
         * @property {protos.GithubEvent.Type|null} [type] GithubEvent type
         * @property {protos.IInstallCreated|null} [installCreated] GithubEvent installCreated
         * @property {protos.IInstallUpdated|null} [installUpdated] GithubEvent installUpdated
         * @property {protos.IInstallDeleted|null} [installDeleted] GithubEvent installDeleted
         * @property {protos.IPullRequestCreated|null} [prCreated] GithubEvent prCreated
         * @property {protos.IPullRequestMerged|null} [prMerged] GithubEvent prMerged
         * @property {protos.IIssueCreated|null} [issueCreated] GithubEvent issueCreated
         * @property {protos.IIssueReopened|null} [issueReopened] GithubEvent issueReopened
         * @property {protos.IIssueClosed|null} [issueClosed] GithubEvent issueClosed
         */

        /**
         * Constructs a new GithubEvent.
         * @memberof protos
         * @classdesc Represents a GithubEvent.
         * @implements IGithubEvent
         * @constructor
         * @param {protos.IGithubEvent=} [properties] Properties to set
         */
        function GithubEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GithubEvent type.
         * @member {protos.GithubEvent.Type} type
         * @memberof protos.GithubEvent
         * @instance
         */
        GithubEvent.prototype.type = 0;

        /**
         * GithubEvent installCreated.
         * @member {protos.IInstallCreated|null|undefined} installCreated
         * @memberof protos.GithubEvent
         * @instance
         */
        GithubEvent.prototype.installCreated = null;

        /**
         * GithubEvent installUpdated.
         * @member {protos.IInstallUpdated|null|undefined} installUpdated
         * @memberof protos.GithubEvent
         * @instance
         */
        GithubEvent.prototype.installUpdated = null;

        /**
         * GithubEvent installDeleted.
         * @member {protos.IInstallDeleted|null|undefined} installDeleted
         * @memberof protos.GithubEvent
         * @instance
         */
        GithubEvent.prototype.installDeleted = null;

        /**
         * GithubEvent prCreated.
         * @member {protos.IPullRequestCreated|null|undefined} prCreated
         * @memberof protos.GithubEvent
         * @instance
         */
        GithubEvent.prototype.prCreated = null;

        /**
         * GithubEvent prMerged.
         * @member {protos.IPullRequestMerged|null|undefined} prMerged
         * @memberof protos.GithubEvent
         * @instance
         */
        GithubEvent.prototype.prMerged = null;

        /**
         * GithubEvent issueCreated.
         * @member {protos.IIssueCreated|null|undefined} issueCreated
         * @memberof protos.GithubEvent
         * @instance
         */
        GithubEvent.prototype.issueCreated = null;

        /**
         * GithubEvent issueReopened.
         * @member {protos.IIssueReopened|null|undefined} issueReopened
         * @memberof protos.GithubEvent
         * @instance
         */
        GithubEvent.prototype.issueReopened = null;

        /**
         * GithubEvent issueClosed.
         * @member {protos.IIssueClosed|null|undefined} issueClosed
         * @memberof protos.GithubEvent
         * @instance
         */
        GithubEvent.prototype.issueClosed = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * GithubEvent payload.
         * @member {"installCreated"|"installUpdated"|"installDeleted"|"prCreated"|"prMerged"|"issueCreated"|"issueReopened"|"issueClosed"|undefined} payload
         * @memberof protos.GithubEvent
         * @instance
         */
        Object.defineProperty(GithubEvent.prototype, "payload", {
            get: $util.oneOfGetter($oneOfFields = ["installCreated", "installUpdated", "installDeleted", "prCreated", "prMerged", "issueCreated", "issueReopened", "issueClosed"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new GithubEvent instance using the specified properties.
         * @function create
         * @memberof protos.GithubEvent
         * @static
         * @param {protos.IGithubEvent=} [properties] Properties to set
         * @returns {protos.GithubEvent} GithubEvent instance
         */
        GithubEvent.create = function create(properties) {
            return new GithubEvent(properties);
        };

        /**
         * Encodes the specified GithubEvent message. Does not implicitly {@link protos.GithubEvent.verify|verify} messages.
         * @function encode
         * @memberof protos.GithubEvent
         * @static
         * @param {protos.IGithubEvent} message GithubEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GithubEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.installCreated != null && Object.hasOwnProperty.call(message, "installCreated"))
                $root.protos.InstallCreated.encode(message.installCreated, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
            if (message.installUpdated != null && Object.hasOwnProperty.call(message, "installUpdated"))
                $root.protos.InstallUpdated.encode(message.installUpdated, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.installDeleted != null && Object.hasOwnProperty.call(message, "installDeleted"))
                $root.protos.InstallDeleted.encode(message.installDeleted, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            if (message.prCreated != null && Object.hasOwnProperty.call(message, "prCreated"))
                $root.protos.PullRequestCreated.encode(message.prCreated, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
            if (message.prMerged != null && Object.hasOwnProperty.call(message, "prMerged"))
                $root.protos.PullRequestMerged.encode(message.prMerged, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
            if (message.issueCreated != null && Object.hasOwnProperty.call(message, "issueCreated"))
                $root.protos.IssueCreated.encode(message.issueCreated, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
            if (message.issueReopened != null && Object.hasOwnProperty.call(message, "issueReopened"))
                $root.protos.IssueReopened.encode(message.issueReopened, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
            if (message.issueClosed != null && Object.hasOwnProperty.call(message, "issueClosed"))
                $root.protos.IssueClosed.encode(message.issueClosed, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GithubEvent message, length delimited. Does not implicitly {@link protos.GithubEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GithubEvent
         * @static
         * @param {protos.IGithubEvent} message GithubEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GithubEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GithubEvent message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GithubEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GithubEvent} GithubEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GithubEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GithubEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 100:
                    message.installCreated = $root.protos.InstallCreated.decode(reader, reader.uint32());
                    break;
                case 101:
                    message.installUpdated = $root.protos.InstallUpdated.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.installDeleted = $root.protos.InstallDeleted.decode(reader, reader.uint32());
                    break;
                case 103:
                    message.prCreated = $root.protos.PullRequestCreated.decode(reader, reader.uint32());
                    break;
                case 104:
                    message.prMerged = $root.protos.PullRequestMerged.decode(reader, reader.uint32());
                    break;
                case 105:
                    message.issueCreated = $root.protos.IssueCreated.decode(reader, reader.uint32());
                    break;
                case 106:
                    message.issueReopened = $root.protos.IssueReopened.decode(reader, reader.uint32());
                    break;
                case 107:
                    message.issueClosed = $root.protos.IssueClosed.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GithubEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GithubEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GithubEvent} GithubEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GithubEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GithubEvent message.
         * @function verify
         * @memberof protos.GithubEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GithubEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.installCreated != null && message.hasOwnProperty("installCreated")) {
                properties.payload = 1;
                {
                    var error = $root.protos.InstallCreated.verify(message.installCreated);
                    if (error)
                        return "installCreated." + error;
                }
            }
            if (message.installUpdated != null && message.hasOwnProperty("installUpdated")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.protos.InstallUpdated.verify(message.installUpdated);
                    if (error)
                        return "installUpdated." + error;
                }
            }
            if (message.installDeleted != null && message.hasOwnProperty("installDeleted")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.protos.InstallDeleted.verify(message.installDeleted);
                    if (error)
                        return "installDeleted." + error;
                }
            }
            if (message.prCreated != null && message.hasOwnProperty("prCreated")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.protos.PullRequestCreated.verify(message.prCreated);
                    if (error)
                        return "prCreated." + error;
                }
            }
            if (message.prMerged != null && message.hasOwnProperty("prMerged")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.protos.PullRequestMerged.verify(message.prMerged);
                    if (error)
                        return "prMerged." + error;
                }
            }
            if (message.issueCreated != null && message.hasOwnProperty("issueCreated")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.protos.IssueCreated.verify(message.issueCreated);
                    if (error)
                        return "issueCreated." + error;
                }
            }
            if (message.issueReopened != null && message.hasOwnProperty("issueReopened")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.protos.IssueReopened.verify(message.issueReopened);
                    if (error)
                        return "issueReopened." + error;
                }
            }
            if (message.issueClosed != null && message.hasOwnProperty("issueClosed")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.protos.IssueClosed.verify(message.issueClosed);
                    if (error)
                        return "issueClosed." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GithubEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GithubEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GithubEvent} GithubEvent
         */
        GithubEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GithubEvent)
                return object;
            var message = new $root.protos.GithubEvent();
            switch (object.type) {
            case "UNSET":
            case 0:
                message.type = 0;
                break;
            case "INSTALL_CREATED":
            case 1:
                message.type = 1;
                break;
            case "INSTALL_UPDATED":
            case 2:
                message.type = 2;
                break;
            case "INSTALL_DELETED":
            case 3:
                message.type = 3;
                break;
            case "PULL_CREATED":
            case 4:
                message.type = 4;
                break;
            case "PULL_MERGED":
            case 5:
                message.type = 5;
                break;
            case "ISSUE_CREATED":
            case 6:
                message.type = 6;
                break;
            case "ISSUE_REOPENED":
            case 7:
                message.type = 7;
                break;
            case "ISSUE_CLOSED":
            case 8:
                message.type = 8;
                break;
            }
            if (object.installCreated != null) {
                if (typeof object.installCreated !== "object")
                    throw TypeError(".protos.GithubEvent.installCreated: object expected");
                message.installCreated = $root.protos.InstallCreated.fromObject(object.installCreated);
            }
            if (object.installUpdated != null) {
                if (typeof object.installUpdated !== "object")
                    throw TypeError(".protos.GithubEvent.installUpdated: object expected");
                message.installUpdated = $root.protos.InstallUpdated.fromObject(object.installUpdated);
            }
            if (object.installDeleted != null) {
                if (typeof object.installDeleted !== "object")
                    throw TypeError(".protos.GithubEvent.installDeleted: object expected");
                message.installDeleted = $root.protos.InstallDeleted.fromObject(object.installDeleted);
            }
            if (object.prCreated != null) {
                if (typeof object.prCreated !== "object")
                    throw TypeError(".protos.GithubEvent.prCreated: object expected");
                message.prCreated = $root.protos.PullRequestCreated.fromObject(object.prCreated);
            }
            if (object.prMerged != null) {
                if (typeof object.prMerged !== "object")
                    throw TypeError(".protos.GithubEvent.prMerged: object expected");
                message.prMerged = $root.protos.PullRequestMerged.fromObject(object.prMerged);
            }
            if (object.issueCreated != null) {
                if (typeof object.issueCreated !== "object")
                    throw TypeError(".protos.GithubEvent.issueCreated: object expected");
                message.issueCreated = $root.protos.IssueCreated.fromObject(object.issueCreated);
            }
            if (object.issueReopened != null) {
                if (typeof object.issueReopened !== "object")
                    throw TypeError(".protos.GithubEvent.issueReopened: object expected");
                message.issueReopened = $root.protos.IssueReopened.fromObject(object.issueReopened);
            }
            if (object.issueClosed != null) {
                if (typeof object.issueClosed !== "object")
                    throw TypeError(".protos.GithubEvent.issueClosed: object expected");
                message.issueClosed = $root.protos.IssueClosed.fromObject(object.issueClosed);
            }
            return message;
        };

        /**
         * Creates a plain object from a GithubEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GithubEvent
         * @static
         * @param {protos.GithubEvent} message GithubEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GithubEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = options.enums === String ? "UNSET" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protos.GithubEvent.Type[message.type] : message.type;
            if (message.installCreated != null && message.hasOwnProperty("installCreated")) {
                object.installCreated = $root.protos.InstallCreated.toObject(message.installCreated, options);
                if (options.oneofs)
                    object.payload = "installCreated";
            }
            if (message.installUpdated != null && message.hasOwnProperty("installUpdated")) {
                object.installUpdated = $root.protos.InstallUpdated.toObject(message.installUpdated, options);
                if (options.oneofs)
                    object.payload = "installUpdated";
            }
            if (message.installDeleted != null && message.hasOwnProperty("installDeleted")) {
                object.installDeleted = $root.protos.InstallDeleted.toObject(message.installDeleted, options);
                if (options.oneofs)
                    object.payload = "installDeleted";
            }
            if (message.prCreated != null && message.hasOwnProperty("prCreated")) {
                object.prCreated = $root.protos.PullRequestCreated.toObject(message.prCreated, options);
                if (options.oneofs)
                    object.payload = "prCreated";
            }
            if (message.prMerged != null && message.hasOwnProperty("prMerged")) {
                object.prMerged = $root.protos.PullRequestMerged.toObject(message.prMerged, options);
                if (options.oneofs)
                    object.payload = "prMerged";
            }
            if (message.issueCreated != null && message.hasOwnProperty("issueCreated")) {
                object.issueCreated = $root.protos.IssueCreated.toObject(message.issueCreated, options);
                if (options.oneofs)
                    object.payload = "issueCreated";
            }
            if (message.issueReopened != null && message.hasOwnProperty("issueReopened")) {
                object.issueReopened = $root.protos.IssueReopened.toObject(message.issueReopened, options);
                if (options.oneofs)
                    object.payload = "issueReopened";
            }
            if (message.issueClosed != null && message.hasOwnProperty("issueClosed")) {
                object.issueClosed = $root.protos.IssueClosed.toObject(message.issueClosed, options);
                if (options.oneofs)
                    object.payload = "issueClosed";
            }
            return object;
        };

        /**
         * Converts this GithubEvent to JSON.
         * @function toJSON
         * @memberof protos.GithubEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GithubEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name protos.GithubEvent.Type
         * @enum {number}
         * @property {number} UNSET=0 UNSET value
         * @property {number} INSTALL_CREATED=1 INSTALL_CREATED value
         * @property {number} INSTALL_UPDATED=2 INSTALL_UPDATED value
         * @property {number} INSTALL_DELETED=3 INSTALL_DELETED value
         * @property {number} PULL_CREATED=4 PULL_CREATED value
         * @property {number} PULL_MERGED=5 PULL_MERGED value
         * @property {number} ISSUE_CREATED=6 ISSUE_CREATED value
         * @property {number} ISSUE_REOPENED=7 ISSUE_REOPENED value
         * @property {number} ISSUE_CLOSED=8 ISSUE_CLOSED value
         */
        GithubEvent.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSET"] = 0;
            values[valuesById[1] = "INSTALL_CREATED"] = 1;
            values[valuesById[2] = "INSTALL_UPDATED"] = 2;
            values[valuesById[3] = "INSTALL_DELETED"] = 3;
            values[valuesById[4] = "PULL_CREATED"] = 4;
            values[valuesById[5] = "PULL_MERGED"] = 5;
            values[valuesById[6] = "ISSUE_CREATED"] = 6;
            values[valuesById[7] = "ISSUE_REOPENED"] = 7;
            values[valuesById[8] = "ISSUE_CLOSED"] = 8;
            return values;
        })();

        return GithubEvent;
    })();

    protos.ConnectAuthRequest = (function() {

        /**
         * Properties of a ConnectAuthRequest.
         * @memberof protos
         * @interface IConnectAuthRequest
         * @property {string|null} [apiToken] ConnectAuthRequest apiToken
         */

        /**
         * Constructs a new ConnectAuthRequest.
         * @memberof protos
         * @classdesc Represents a ConnectAuthRequest.
         * @implements IConnectAuthRequest
         * @constructor
         * @param {protos.IConnectAuthRequest=} [properties] Properties to set
         */
        function ConnectAuthRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnectAuthRequest apiToken.
         * @member {string} apiToken
         * @memberof protos.ConnectAuthRequest
         * @instance
         */
        ConnectAuthRequest.prototype.apiToken = "";

        /**
         * Creates a new ConnectAuthRequest instance using the specified properties.
         * @function create
         * @memberof protos.ConnectAuthRequest
         * @static
         * @param {protos.IConnectAuthRequest=} [properties] Properties to set
         * @returns {protos.ConnectAuthRequest} ConnectAuthRequest instance
         */
        ConnectAuthRequest.create = function create(properties) {
            return new ConnectAuthRequest(properties);
        };

        /**
         * Encodes the specified ConnectAuthRequest message. Does not implicitly {@link protos.ConnectAuthRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ConnectAuthRequest
         * @static
         * @param {protos.IConnectAuthRequest} message ConnectAuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectAuthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.apiToken != null && Object.hasOwnProperty.call(message, "apiToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.apiToken);
            return writer;
        };

        /**
         * Encodes the specified ConnectAuthRequest message, length delimited. Does not implicitly {@link protos.ConnectAuthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ConnectAuthRequest
         * @static
         * @param {protos.IConnectAuthRequest} message ConnectAuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectAuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectAuthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ConnectAuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ConnectAuthRequest} ConnectAuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectAuthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ConnectAuthRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.apiToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectAuthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ConnectAuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ConnectAuthRequest} ConnectAuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectAuthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectAuthRequest message.
         * @function verify
         * @memberof protos.ConnectAuthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectAuthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                if (!$util.isString(message.apiToken))
                    return "apiToken: string expected";
            return null;
        };

        /**
         * Creates a ConnectAuthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ConnectAuthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ConnectAuthRequest} ConnectAuthRequest
         */
        ConnectAuthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ConnectAuthRequest)
                return object;
            var message = new $root.protos.ConnectAuthRequest();
            if (object.apiToken != null)
                message.apiToken = String(object.apiToken);
            return message;
        };

        /**
         * Creates a plain object from a ConnectAuthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ConnectAuthRequest
         * @static
         * @param {protos.ConnectAuthRequest} message ConnectAuthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectAuthRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.apiToken = "";
            if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                object.apiToken = message.apiToken;
            return object;
        };

        /**
         * Converts this ConnectAuthRequest to JSON.
         * @function toJSON
         * @memberof protos.ConnectAuthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectAuthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnectAuthRequest;
    })();

    protos.AuthResponse = (function() {

        /**
         * Properties of an AuthResponse.
         * @memberof protos
         * @interface IAuthResponse
         * @property {boolean|null} [authorized] AuthResponse authorized
         * @property {string|null} [message] AuthResponse message
         */

        /**
         * Constructs a new AuthResponse.
         * @memberof protos
         * @classdesc Represents an AuthResponse.
         * @implements IAuthResponse
         * @constructor
         * @param {protos.IAuthResponse=} [properties] Properties to set
         */
        function AuthResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthResponse authorized.
         * @member {boolean} authorized
         * @memberof protos.AuthResponse
         * @instance
         */
        AuthResponse.prototype.authorized = false;

        /**
         * AuthResponse message.
         * @member {string} message
         * @memberof protos.AuthResponse
         * @instance
         */
        AuthResponse.prototype.message = "";

        /**
         * Creates a new AuthResponse instance using the specified properties.
         * @function create
         * @memberof protos.AuthResponse
         * @static
         * @param {protos.IAuthResponse=} [properties] Properties to set
         * @returns {protos.AuthResponse} AuthResponse instance
         */
        AuthResponse.create = function create(properties) {
            return new AuthResponse(properties);
        };

        /**
         * Encodes the specified AuthResponse message. Does not implicitly {@link protos.AuthResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.AuthResponse
         * @static
         * @param {protos.IAuthResponse} message AuthResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authorized != null && Object.hasOwnProperty.call(message, "authorized"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.authorized);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified AuthResponse message, length delimited. Does not implicitly {@link protos.AuthResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.AuthResponse
         * @static
         * @param {protos.IAuthResponse} message AuthResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.AuthResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.AuthResponse} AuthResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.AuthResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authorized = reader.bool();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.AuthResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.AuthResponse} AuthResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthResponse message.
         * @function verify
         * @memberof protos.AuthResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.authorized != null && message.hasOwnProperty("authorized"))
                if (typeof message.authorized !== "boolean")
                    return "authorized: boolean expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates an AuthResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.AuthResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.AuthResponse} AuthResponse
         */
        AuthResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.AuthResponse)
                return object;
            var message = new $root.protos.AuthResponse();
            if (object.authorized != null)
                message.authorized = Boolean(object.authorized);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from an AuthResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.AuthResponse
         * @static
         * @param {protos.AuthResponse} message AuthResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.authorized = false;
                object.message = "";
            }
            if (message.authorized != null && message.hasOwnProperty("authorized"))
                object.authorized = message.authorized;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this AuthResponse to JSON.
         * @function toJSON
         * @memberof protos.AuthResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AuthResponse;
    })();

    protos.PullRequestCreated = (function() {

        /**
         * Properties of a PullRequestCreated.
         * @memberof protos
         * @interface IPullRequestCreated
         * @property {string|null} [owner] PullRequestCreated owner
         * @property {string|null} [repo] PullRequestCreated repo
         * @property {number|null} [number] PullRequestCreated number
         * @property {string|null} [url] PullRequestCreated url
         * @property {string|null} [description] PullRequestCreated description
         */

        /**
         * Constructs a new PullRequestCreated.
         * @memberof protos
         * @classdesc Represents a PullRequestCreated.
         * @implements IPullRequestCreated
         * @constructor
         * @param {protos.IPullRequestCreated=} [properties] Properties to set
         */
        function PullRequestCreated(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PullRequestCreated owner.
         * @member {string} owner
         * @memberof protos.PullRequestCreated
         * @instance
         */
        PullRequestCreated.prototype.owner = "";

        /**
         * PullRequestCreated repo.
         * @member {string} repo
         * @memberof protos.PullRequestCreated
         * @instance
         */
        PullRequestCreated.prototype.repo = "";

        /**
         * PullRequestCreated number.
         * @member {number} number
         * @memberof protos.PullRequestCreated
         * @instance
         */
        PullRequestCreated.prototype.number = 0;

        /**
         * PullRequestCreated url.
         * @member {string} url
         * @memberof protos.PullRequestCreated
         * @instance
         */
        PullRequestCreated.prototype.url = "";

        /**
         * PullRequestCreated description.
         * @member {string} description
         * @memberof protos.PullRequestCreated
         * @instance
         */
        PullRequestCreated.prototype.description = "";

        /**
         * Creates a new PullRequestCreated instance using the specified properties.
         * @function create
         * @memberof protos.PullRequestCreated
         * @static
         * @param {protos.IPullRequestCreated=} [properties] Properties to set
         * @returns {protos.PullRequestCreated} PullRequestCreated instance
         */
        PullRequestCreated.create = function create(properties) {
            return new PullRequestCreated(properties);
        };

        /**
         * Encodes the specified PullRequestCreated message. Does not implicitly {@link protos.PullRequestCreated.verify|verify} messages.
         * @function encode
         * @memberof protos.PullRequestCreated
         * @static
         * @param {protos.IPullRequestCreated} message PullRequestCreated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PullRequestCreated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
            if (message.repo != null && Object.hasOwnProperty.call(message, "repo"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.repo);
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.url);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified PullRequestCreated message, length delimited. Does not implicitly {@link protos.PullRequestCreated.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.PullRequestCreated
         * @static
         * @param {protos.IPullRequestCreated} message PullRequestCreated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PullRequestCreated.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PullRequestCreated message from the specified reader or buffer.
         * @function decode
         * @memberof protos.PullRequestCreated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.PullRequestCreated} PullRequestCreated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PullRequestCreated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.PullRequestCreated();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                case 2:
                    message.repo = reader.string();
                    break;
                case 3:
                    message.number = reader.int32();
                    break;
                case 4:
                    message.url = reader.string();
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PullRequestCreated message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.PullRequestCreated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.PullRequestCreated} PullRequestCreated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PullRequestCreated.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PullRequestCreated message.
         * @function verify
         * @memberof protos.PullRequestCreated
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PullRequestCreated.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isString(message.owner))
                    return "owner: string expected";
            if (message.repo != null && message.hasOwnProperty("repo"))
                if (!$util.isString(message.repo))
                    return "repo: string expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number))
                    return "number: integer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates a PullRequestCreated message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.PullRequestCreated
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.PullRequestCreated} PullRequestCreated
         */
        PullRequestCreated.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.PullRequestCreated)
                return object;
            var message = new $root.protos.PullRequestCreated();
            if (object.owner != null)
                message.owner = String(object.owner);
            if (object.repo != null)
                message.repo = String(object.repo);
            if (object.number != null)
                message.number = object.number | 0;
            if (object.url != null)
                message.url = String(object.url);
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from a PullRequestCreated message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.PullRequestCreated
         * @static
         * @param {protos.PullRequestCreated} message PullRequestCreated
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PullRequestCreated.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.owner = "";
                object.repo = "";
                object.number = 0;
                object.url = "";
                object.description = "";
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            if (message.repo != null && message.hasOwnProperty("repo"))
                object.repo = message.repo;
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this PullRequestCreated to JSON.
         * @function toJSON
         * @memberof protos.PullRequestCreated
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PullRequestCreated.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PullRequestCreated;
    })();

    protos.PullRequestMerged = (function() {

        /**
         * Properties of a PullRequestMerged.
         * @memberof protos
         * @interface IPullRequestMerged
         * @property {string|null} [owner] PullRequestMerged owner
         * @property {string|null} [repo] PullRequestMerged repo
         * @property {number|null} [number] PullRequestMerged number
         * @property {string|null} [url] PullRequestMerged url
         */

        /**
         * Constructs a new PullRequestMerged.
         * @memberof protos
         * @classdesc Represents a PullRequestMerged.
         * @implements IPullRequestMerged
         * @constructor
         * @param {protos.IPullRequestMerged=} [properties] Properties to set
         */
        function PullRequestMerged(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PullRequestMerged owner.
         * @member {string} owner
         * @memberof protos.PullRequestMerged
         * @instance
         */
        PullRequestMerged.prototype.owner = "";

        /**
         * PullRequestMerged repo.
         * @member {string} repo
         * @memberof protos.PullRequestMerged
         * @instance
         */
        PullRequestMerged.prototype.repo = "";

        /**
         * PullRequestMerged number.
         * @member {number} number
         * @memberof protos.PullRequestMerged
         * @instance
         */
        PullRequestMerged.prototype.number = 0;

        /**
         * PullRequestMerged url.
         * @member {string} url
         * @memberof protos.PullRequestMerged
         * @instance
         */
        PullRequestMerged.prototype.url = "";

        /**
         * Creates a new PullRequestMerged instance using the specified properties.
         * @function create
         * @memberof protos.PullRequestMerged
         * @static
         * @param {protos.IPullRequestMerged=} [properties] Properties to set
         * @returns {protos.PullRequestMerged} PullRequestMerged instance
         */
        PullRequestMerged.create = function create(properties) {
            return new PullRequestMerged(properties);
        };

        /**
         * Encodes the specified PullRequestMerged message. Does not implicitly {@link protos.PullRequestMerged.verify|verify} messages.
         * @function encode
         * @memberof protos.PullRequestMerged
         * @static
         * @param {protos.IPullRequestMerged} message PullRequestMerged message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PullRequestMerged.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
            if (message.repo != null && Object.hasOwnProperty.call(message, "repo"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.repo);
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.url);
            return writer;
        };

        /**
         * Encodes the specified PullRequestMerged message, length delimited. Does not implicitly {@link protos.PullRequestMerged.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.PullRequestMerged
         * @static
         * @param {protos.IPullRequestMerged} message PullRequestMerged message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PullRequestMerged.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PullRequestMerged message from the specified reader or buffer.
         * @function decode
         * @memberof protos.PullRequestMerged
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.PullRequestMerged} PullRequestMerged
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PullRequestMerged.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.PullRequestMerged();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                case 2:
                    message.repo = reader.string();
                    break;
                case 3:
                    message.number = reader.int32();
                    break;
                case 4:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PullRequestMerged message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.PullRequestMerged
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.PullRequestMerged} PullRequestMerged
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PullRequestMerged.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PullRequestMerged message.
         * @function verify
         * @memberof protos.PullRequestMerged
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PullRequestMerged.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isString(message.owner))
                    return "owner: string expected";
            if (message.repo != null && message.hasOwnProperty("repo"))
                if (!$util.isString(message.repo))
                    return "repo: string expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number))
                    return "number: integer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            return null;
        };

        /**
         * Creates a PullRequestMerged message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.PullRequestMerged
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.PullRequestMerged} PullRequestMerged
         */
        PullRequestMerged.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.PullRequestMerged)
                return object;
            var message = new $root.protos.PullRequestMerged();
            if (object.owner != null)
                message.owner = String(object.owner);
            if (object.repo != null)
                message.repo = String(object.repo);
            if (object.number != null)
                message.number = object.number | 0;
            if (object.url != null)
                message.url = String(object.url);
            return message;
        };

        /**
         * Creates a plain object from a PullRequestMerged message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.PullRequestMerged
         * @static
         * @param {protos.PullRequestMerged} message PullRequestMerged
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PullRequestMerged.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.owner = "";
                object.repo = "";
                object.number = 0;
                object.url = "";
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            if (message.repo != null && message.hasOwnProperty("repo"))
                object.repo = message.repo;
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };

        /**
         * Converts this PullRequestMerged to JSON.
         * @function toJSON
         * @memberof protos.PullRequestMerged
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PullRequestMerged.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PullRequestMerged;
    })();

    protos.InstallCreated = (function() {

        /**
         * Properties of an InstallCreated.
         * @memberof protos
         * @interface IInstallCreated
         * @property {number|Long|null} [installId] InstallCreated installId
         * @property {number|Long|null} [accountId] InstallCreated accountId
         */

        /**
         * Constructs a new InstallCreated.
         * @memberof protos
         * @classdesc Represents an InstallCreated.
         * @implements IInstallCreated
         * @constructor
         * @param {protos.IInstallCreated=} [properties] Properties to set
         */
        function InstallCreated(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstallCreated installId.
         * @member {number|Long} installId
         * @memberof protos.InstallCreated
         * @instance
         */
        InstallCreated.prototype.installId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * InstallCreated accountId.
         * @member {number|Long} accountId
         * @memberof protos.InstallCreated
         * @instance
         */
        InstallCreated.prototype.accountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new InstallCreated instance using the specified properties.
         * @function create
         * @memberof protos.InstallCreated
         * @static
         * @param {protos.IInstallCreated=} [properties] Properties to set
         * @returns {protos.InstallCreated} InstallCreated instance
         */
        InstallCreated.create = function create(properties) {
            return new InstallCreated(properties);
        };

        /**
         * Encodes the specified InstallCreated message. Does not implicitly {@link protos.InstallCreated.verify|verify} messages.
         * @function encode
         * @memberof protos.InstallCreated
         * @static
         * @param {protos.IInstallCreated} message InstallCreated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstallCreated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.installId != null && Object.hasOwnProperty.call(message, "installId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.installId);
            if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.accountId);
            return writer;
        };

        /**
         * Encodes the specified InstallCreated message, length delimited. Does not implicitly {@link protos.InstallCreated.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.InstallCreated
         * @static
         * @param {protos.IInstallCreated} message InstallCreated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstallCreated.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstallCreated message from the specified reader or buffer.
         * @function decode
         * @memberof protos.InstallCreated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.InstallCreated} InstallCreated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstallCreated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.InstallCreated();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.installId = reader.int64();
                    break;
                case 2:
                    message.accountId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstallCreated message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.InstallCreated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.InstallCreated} InstallCreated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstallCreated.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstallCreated message.
         * @function verify
         * @memberof protos.InstallCreated
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstallCreated.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.installId != null && message.hasOwnProperty("installId"))
                if (!$util.isInteger(message.installId) && !(message.installId && $util.isInteger(message.installId.low) && $util.isInteger(message.installId.high)))
                    return "installId: integer|Long expected";
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (!$util.isInteger(message.accountId) && !(message.accountId && $util.isInteger(message.accountId.low) && $util.isInteger(message.accountId.high)))
                    return "accountId: integer|Long expected";
            return null;
        };

        /**
         * Creates an InstallCreated message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.InstallCreated
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.InstallCreated} InstallCreated
         */
        InstallCreated.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.InstallCreated)
                return object;
            var message = new $root.protos.InstallCreated();
            if (object.installId != null)
                if ($util.Long)
                    (message.installId = $util.Long.fromValue(object.installId)).unsigned = false;
                else if (typeof object.installId === "string")
                    message.installId = parseInt(object.installId, 10);
                else if (typeof object.installId === "number")
                    message.installId = object.installId;
                else if (typeof object.installId === "object")
                    message.installId = new $util.LongBits(object.installId.low >>> 0, object.installId.high >>> 0).toNumber();
            if (object.accountId != null)
                if ($util.Long)
                    (message.accountId = $util.Long.fromValue(object.accountId)).unsigned = false;
                else if (typeof object.accountId === "string")
                    message.accountId = parseInt(object.accountId, 10);
                else if (typeof object.accountId === "number")
                    message.accountId = object.accountId;
                else if (typeof object.accountId === "object")
                    message.accountId = new $util.LongBits(object.accountId.low >>> 0, object.accountId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an InstallCreated message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.InstallCreated
         * @static
         * @param {protos.InstallCreated} message InstallCreated
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstallCreated.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.installId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.installId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.accountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accountId = options.longs === String ? "0" : 0;
            }
            if (message.installId != null && message.hasOwnProperty("installId"))
                if (typeof message.installId === "number")
                    object.installId = options.longs === String ? String(message.installId) : message.installId;
                else
                    object.installId = options.longs === String ? $util.Long.prototype.toString.call(message.installId) : options.longs === Number ? new $util.LongBits(message.installId.low >>> 0, message.installId.high >>> 0).toNumber() : message.installId;
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (typeof message.accountId === "number")
                    object.accountId = options.longs === String ? String(message.accountId) : message.accountId;
                else
                    object.accountId = options.longs === String ? $util.Long.prototype.toString.call(message.accountId) : options.longs === Number ? new $util.LongBits(message.accountId.low >>> 0, message.accountId.high >>> 0).toNumber() : message.accountId;
            return object;
        };

        /**
         * Converts this InstallCreated to JSON.
         * @function toJSON
         * @memberof protos.InstallCreated
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstallCreated.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstallCreated;
    })();

    protos.InstallUpdated = (function() {

        /**
         * Properties of an InstallUpdated.
         * @memberof protos
         * @interface IInstallUpdated
         * @property {number|Long|null} [installId] InstallUpdated installId
         * @property {number|Long|null} [accountId] InstallUpdated accountId
         */

        /**
         * Constructs a new InstallUpdated.
         * @memberof protos
         * @classdesc Represents an InstallUpdated.
         * @implements IInstallUpdated
         * @constructor
         * @param {protos.IInstallUpdated=} [properties] Properties to set
         */
        function InstallUpdated(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstallUpdated installId.
         * @member {number|Long} installId
         * @memberof protos.InstallUpdated
         * @instance
         */
        InstallUpdated.prototype.installId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * InstallUpdated accountId.
         * @member {number|Long} accountId
         * @memberof protos.InstallUpdated
         * @instance
         */
        InstallUpdated.prototype.accountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new InstallUpdated instance using the specified properties.
         * @function create
         * @memberof protos.InstallUpdated
         * @static
         * @param {protos.IInstallUpdated=} [properties] Properties to set
         * @returns {protos.InstallUpdated} InstallUpdated instance
         */
        InstallUpdated.create = function create(properties) {
            return new InstallUpdated(properties);
        };

        /**
         * Encodes the specified InstallUpdated message. Does not implicitly {@link protos.InstallUpdated.verify|verify} messages.
         * @function encode
         * @memberof protos.InstallUpdated
         * @static
         * @param {protos.IInstallUpdated} message InstallUpdated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstallUpdated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.installId != null && Object.hasOwnProperty.call(message, "installId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.installId);
            if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.accountId);
            return writer;
        };

        /**
         * Encodes the specified InstallUpdated message, length delimited. Does not implicitly {@link protos.InstallUpdated.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.InstallUpdated
         * @static
         * @param {protos.IInstallUpdated} message InstallUpdated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstallUpdated.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstallUpdated message from the specified reader or buffer.
         * @function decode
         * @memberof protos.InstallUpdated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.InstallUpdated} InstallUpdated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstallUpdated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.InstallUpdated();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.installId = reader.int64();
                    break;
                case 2:
                    message.accountId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstallUpdated message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.InstallUpdated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.InstallUpdated} InstallUpdated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstallUpdated.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstallUpdated message.
         * @function verify
         * @memberof protos.InstallUpdated
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstallUpdated.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.installId != null && message.hasOwnProperty("installId"))
                if (!$util.isInteger(message.installId) && !(message.installId && $util.isInteger(message.installId.low) && $util.isInteger(message.installId.high)))
                    return "installId: integer|Long expected";
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (!$util.isInteger(message.accountId) && !(message.accountId && $util.isInteger(message.accountId.low) && $util.isInteger(message.accountId.high)))
                    return "accountId: integer|Long expected";
            return null;
        };

        /**
         * Creates an InstallUpdated message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.InstallUpdated
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.InstallUpdated} InstallUpdated
         */
        InstallUpdated.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.InstallUpdated)
                return object;
            var message = new $root.protos.InstallUpdated();
            if (object.installId != null)
                if ($util.Long)
                    (message.installId = $util.Long.fromValue(object.installId)).unsigned = false;
                else if (typeof object.installId === "string")
                    message.installId = parseInt(object.installId, 10);
                else if (typeof object.installId === "number")
                    message.installId = object.installId;
                else if (typeof object.installId === "object")
                    message.installId = new $util.LongBits(object.installId.low >>> 0, object.installId.high >>> 0).toNumber();
            if (object.accountId != null)
                if ($util.Long)
                    (message.accountId = $util.Long.fromValue(object.accountId)).unsigned = false;
                else if (typeof object.accountId === "string")
                    message.accountId = parseInt(object.accountId, 10);
                else if (typeof object.accountId === "number")
                    message.accountId = object.accountId;
                else if (typeof object.accountId === "object")
                    message.accountId = new $util.LongBits(object.accountId.low >>> 0, object.accountId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an InstallUpdated message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.InstallUpdated
         * @static
         * @param {protos.InstallUpdated} message InstallUpdated
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstallUpdated.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.installId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.installId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.accountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accountId = options.longs === String ? "0" : 0;
            }
            if (message.installId != null && message.hasOwnProperty("installId"))
                if (typeof message.installId === "number")
                    object.installId = options.longs === String ? String(message.installId) : message.installId;
                else
                    object.installId = options.longs === String ? $util.Long.prototype.toString.call(message.installId) : options.longs === Number ? new $util.LongBits(message.installId.low >>> 0, message.installId.high >>> 0).toNumber() : message.installId;
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (typeof message.accountId === "number")
                    object.accountId = options.longs === String ? String(message.accountId) : message.accountId;
                else
                    object.accountId = options.longs === String ? $util.Long.prototype.toString.call(message.accountId) : options.longs === Number ? new $util.LongBits(message.accountId.low >>> 0, message.accountId.high >>> 0).toNumber() : message.accountId;
            return object;
        };

        /**
         * Converts this InstallUpdated to JSON.
         * @function toJSON
         * @memberof protos.InstallUpdated
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstallUpdated.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstallUpdated;
    })();

    protos.InstallDeleted = (function() {

        /**
         * Properties of an InstallDeleted.
         * @memberof protos
         * @interface IInstallDeleted
         * @property {number|Long|null} [installId] InstallDeleted installId
         * @property {number|Long|null} [accountId] InstallDeleted accountId
         */

        /**
         * Constructs a new InstallDeleted.
         * @memberof protos
         * @classdesc Represents an InstallDeleted.
         * @implements IInstallDeleted
         * @constructor
         * @param {protos.IInstallDeleted=} [properties] Properties to set
         */
        function InstallDeleted(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InstallDeleted installId.
         * @member {number|Long} installId
         * @memberof protos.InstallDeleted
         * @instance
         */
        InstallDeleted.prototype.installId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * InstallDeleted accountId.
         * @member {number|Long} accountId
         * @memberof protos.InstallDeleted
         * @instance
         */
        InstallDeleted.prototype.accountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new InstallDeleted instance using the specified properties.
         * @function create
         * @memberof protos.InstallDeleted
         * @static
         * @param {protos.IInstallDeleted=} [properties] Properties to set
         * @returns {protos.InstallDeleted} InstallDeleted instance
         */
        InstallDeleted.create = function create(properties) {
            return new InstallDeleted(properties);
        };

        /**
         * Encodes the specified InstallDeleted message. Does not implicitly {@link protos.InstallDeleted.verify|verify} messages.
         * @function encode
         * @memberof protos.InstallDeleted
         * @static
         * @param {protos.IInstallDeleted} message InstallDeleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstallDeleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.installId != null && Object.hasOwnProperty.call(message, "installId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.installId);
            if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.accountId);
            return writer;
        };

        /**
         * Encodes the specified InstallDeleted message, length delimited. Does not implicitly {@link protos.InstallDeleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.InstallDeleted
         * @static
         * @param {protos.IInstallDeleted} message InstallDeleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InstallDeleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InstallDeleted message from the specified reader or buffer.
         * @function decode
         * @memberof protos.InstallDeleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.InstallDeleted} InstallDeleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstallDeleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.InstallDeleted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.installId = reader.int64();
                    break;
                case 2:
                    message.accountId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InstallDeleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.InstallDeleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.InstallDeleted} InstallDeleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InstallDeleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InstallDeleted message.
         * @function verify
         * @memberof protos.InstallDeleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InstallDeleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.installId != null && message.hasOwnProperty("installId"))
                if (!$util.isInteger(message.installId) && !(message.installId && $util.isInteger(message.installId.low) && $util.isInteger(message.installId.high)))
                    return "installId: integer|Long expected";
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (!$util.isInteger(message.accountId) && !(message.accountId && $util.isInteger(message.accountId.low) && $util.isInteger(message.accountId.high)))
                    return "accountId: integer|Long expected";
            return null;
        };

        /**
         * Creates an InstallDeleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.InstallDeleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.InstallDeleted} InstallDeleted
         */
        InstallDeleted.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.InstallDeleted)
                return object;
            var message = new $root.protos.InstallDeleted();
            if (object.installId != null)
                if ($util.Long)
                    (message.installId = $util.Long.fromValue(object.installId)).unsigned = false;
                else if (typeof object.installId === "string")
                    message.installId = parseInt(object.installId, 10);
                else if (typeof object.installId === "number")
                    message.installId = object.installId;
                else if (typeof object.installId === "object")
                    message.installId = new $util.LongBits(object.installId.low >>> 0, object.installId.high >>> 0).toNumber();
            if (object.accountId != null)
                if ($util.Long)
                    (message.accountId = $util.Long.fromValue(object.accountId)).unsigned = false;
                else if (typeof object.accountId === "string")
                    message.accountId = parseInt(object.accountId, 10);
                else if (typeof object.accountId === "number")
                    message.accountId = object.accountId;
                else if (typeof object.accountId === "object")
                    message.accountId = new $util.LongBits(object.accountId.low >>> 0, object.accountId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an InstallDeleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.InstallDeleted
         * @static
         * @param {protos.InstallDeleted} message InstallDeleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InstallDeleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.installId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.installId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.accountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accountId = options.longs === String ? "0" : 0;
            }
            if (message.installId != null && message.hasOwnProperty("installId"))
                if (typeof message.installId === "number")
                    object.installId = options.longs === String ? String(message.installId) : message.installId;
                else
                    object.installId = options.longs === String ? $util.Long.prototype.toString.call(message.installId) : options.longs === Number ? new $util.LongBits(message.installId.low >>> 0, message.installId.high >>> 0).toNumber() : message.installId;
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (typeof message.accountId === "number")
                    object.accountId = options.longs === String ? String(message.accountId) : message.accountId;
                else
                    object.accountId = options.longs === String ? $util.Long.prototype.toString.call(message.accountId) : options.longs === Number ? new $util.LongBits(message.accountId.low >>> 0, message.accountId.high >>> 0).toNumber() : message.accountId;
            return object;
        };

        /**
         * Converts this InstallDeleted to JSON.
         * @function toJSON
         * @memberof protos.InstallDeleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InstallDeleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InstallDeleted;
    })();

    protos.NewJwtToken = (function() {

        /**
         * Properties of a NewJwtToken.
         * @memberof protos
         * @interface INewJwtToken
         * @property {string|null} [token] NewJwtToken token
         */

        /**
         * Constructs a new NewJwtToken.
         * @memberof protos
         * @classdesc Represents a NewJwtToken.
         * @implements INewJwtToken
         * @constructor
         * @param {protos.INewJwtToken=} [properties] Properties to set
         */
        function NewJwtToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewJwtToken token.
         * @member {string} token
         * @memberof protos.NewJwtToken
         * @instance
         */
        NewJwtToken.prototype.token = "";

        /**
         * Creates a new NewJwtToken instance using the specified properties.
         * @function create
         * @memberof protos.NewJwtToken
         * @static
         * @param {protos.INewJwtToken=} [properties] Properties to set
         * @returns {protos.NewJwtToken} NewJwtToken instance
         */
        NewJwtToken.create = function create(properties) {
            return new NewJwtToken(properties);
        };

        /**
         * Encodes the specified NewJwtToken message. Does not implicitly {@link protos.NewJwtToken.verify|verify} messages.
         * @function encode
         * @memberof protos.NewJwtToken
         * @static
         * @param {protos.INewJwtToken} message NewJwtToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewJwtToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
            return writer;
        };

        /**
         * Encodes the specified NewJwtToken message, length delimited. Does not implicitly {@link protos.NewJwtToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.NewJwtToken
         * @static
         * @param {protos.INewJwtToken} message NewJwtToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewJwtToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewJwtToken message from the specified reader or buffer.
         * @function decode
         * @memberof protos.NewJwtToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.NewJwtToken} NewJwtToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewJwtToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.NewJwtToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewJwtToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.NewJwtToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.NewJwtToken} NewJwtToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewJwtToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewJwtToken message.
         * @function verify
         * @memberof protos.NewJwtToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewJwtToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            return null;
        };

        /**
         * Creates a NewJwtToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.NewJwtToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.NewJwtToken} NewJwtToken
         */
        NewJwtToken.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.NewJwtToken)
                return object;
            var message = new $root.protos.NewJwtToken();
            if (object.token != null)
                message.token = String(object.token);
            return message;
        };

        /**
         * Creates a plain object from a NewJwtToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.NewJwtToken
         * @static
         * @param {protos.NewJwtToken} message NewJwtToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewJwtToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.token = "";
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            return object;
        };

        /**
         * Converts this NewJwtToken to JSON.
         * @function toJSON
         * @memberof protos.NewJwtToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewJwtToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewJwtToken;
    })();

    protos.IssueCreated = (function() {

        /**
         * Properties of an IssueCreated.
         * @memberof protos
         * @interface IIssueCreated
         * @property {string|null} [owner] IssueCreated owner
         * @property {string|null} [repo] IssueCreated repo
         * @property {number|null} [number] IssueCreated number
         * @property {string|null} [url] IssueCreated url
         * @property {string|null} [description] IssueCreated description
         */

        /**
         * Constructs a new IssueCreated.
         * @memberof protos
         * @classdesc Represents an IssueCreated.
         * @implements IIssueCreated
         * @constructor
         * @param {protos.IIssueCreated=} [properties] Properties to set
         */
        function IssueCreated(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IssueCreated owner.
         * @member {string} owner
         * @memberof protos.IssueCreated
         * @instance
         */
        IssueCreated.prototype.owner = "";

        /**
         * IssueCreated repo.
         * @member {string} repo
         * @memberof protos.IssueCreated
         * @instance
         */
        IssueCreated.prototype.repo = "";

        /**
         * IssueCreated number.
         * @member {number} number
         * @memberof protos.IssueCreated
         * @instance
         */
        IssueCreated.prototype.number = 0;

        /**
         * IssueCreated url.
         * @member {string} url
         * @memberof protos.IssueCreated
         * @instance
         */
        IssueCreated.prototype.url = "";

        /**
         * IssueCreated description.
         * @member {string} description
         * @memberof protos.IssueCreated
         * @instance
         */
        IssueCreated.prototype.description = "";

        /**
         * Creates a new IssueCreated instance using the specified properties.
         * @function create
         * @memberof protos.IssueCreated
         * @static
         * @param {protos.IIssueCreated=} [properties] Properties to set
         * @returns {protos.IssueCreated} IssueCreated instance
         */
        IssueCreated.create = function create(properties) {
            return new IssueCreated(properties);
        };

        /**
         * Encodes the specified IssueCreated message. Does not implicitly {@link protos.IssueCreated.verify|verify} messages.
         * @function encode
         * @memberof protos.IssueCreated
         * @static
         * @param {protos.IIssueCreated} message IssueCreated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueCreated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
            if (message.repo != null && Object.hasOwnProperty.call(message, "repo"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.repo);
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.url);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified IssueCreated message, length delimited. Does not implicitly {@link protos.IssueCreated.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.IssueCreated
         * @static
         * @param {protos.IIssueCreated} message IssueCreated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueCreated.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IssueCreated message from the specified reader or buffer.
         * @function decode
         * @memberof protos.IssueCreated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.IssueCreated} IssueCreated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueCreated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.IssueCreated();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                case 2:
                    message.repo = reader.string();
                    break;
                case 3:
                    message.number = reader.int32();
                    break;
                case 4:
                    message.url = reader.string();
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IssueCreated message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.IssueCreated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.IssueCreated} IssueCreated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueCreated.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IssueCreated message.
         * @function verify
         * @memberof protos.IssueCreated
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IssueCreated.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isString(message.owner))
                    return "owner: string expected";
            if (message.repo != null && message.hasOwnProperty("repo"))
                if (!$util.isString(message.repo))
                    return "repo: string expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number))
                    return "number: integer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates an IssueCreated message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.IssueCreated
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.IssueCreated} IssueCreated
         */
        IssueCreated.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.IssueCreated)
                return object;
            var message = new $root.protos.IssueCreated();
            if (object.owner != null)
                message.owner = String(object.owner);
            if (object.repo != null)
                message.repo = String(object.repo);
            if (object.number != null)
                message.number = object.number | 0;
            if (object.url != null)
                message.url = String(object.url);
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from an IssueCreated message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.IssueCreated
         * @static
         * @param {protos.IssueCreated} message IssueCreated
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IssueCreated.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.owner = "";
                object.repo = "";
                object.number = 0;
                object.url = "";
                object.description = "";
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            if (message.repo != null && message.hasOwnProperty("repo"))
                object.repo = message.repo;
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this IssueCreated to JSON.
         * @function toJSON
         * @memberof protos.IssueCreated
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IssueCreated.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IssueCreated;
    })();

    protos.IssueReopened = (function() {

        /**
         * Properties of an IssueReopened.
         * @memberof protos
         * @interface IIssueReopened
         * @property {string|null} [owner] IssueReopened owner
         * @property {string|null} [repo] IssueReopened repo
         * @property {number|null} [number] IssueReopened number
         * @property {string|null} [url] IssueReopened url
         * @property {string|null} [description] IssueReopened description
         */

        /**
         * Constructs a new IssueReopened.
         * @memberof protos
         * @classdesc Represents an IssueReopened.
         * @implements IIssueReopened
         * @constructor
         * @param {protos.IIssueReopened=} [properties] Properties to set
         */
        function IssueReopened(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IssueReopened owner.
         * @member {string} owner
         * @memberof protos.IssueReopened
         * @instance
         */
        IssueReopened.prototype.owner = "";

        /**
         * IssueReopened repo.
         * @member {string} repo
         * @memberof protos.IssueReopened
         * @instance
         */
        IssueReopened.prototype.repo = "";

        /**
         * IssueReopened number.
         * @member {number} number
         * @memberof protos.IssueReopened
         * @instance
         */
        IssueReopened.prototype.number = 0;

        /**
         * IssueReopened url.
         * @member {string} url
         * @memberof protos.IssueReopened
         * @instance
         */
        IssueReopened.prototype.url = "";

        /**
         * IssueReopened description.
         * @member {string} description
         * @memberof protos.IssueReopened
         * @instance
         */
        IssueReopened.prototype.description = "";

        /**
         * Creates a new IssueReopened instance using the specified properties.
         * @function create
         * @memberof protos.IssueReopened
         * @static
         * @param {protos.IIssueReopened=} [properties] Properties to set
         * @returns {protos.IssueReopened} IssueReopened instance
         */
        IssueReopened.create = function create(properties) {
            return new IssueReopened(properties);
        };

        /**
         * Encodes the specified IssueReopened message. Does not implicitly {@link protos.IssueReopened.verify|verify} messages.
         * @function encode
         * @memberof protos.IssueReopened
         * @static
         * @param {protos.IIssueReopened} message IssueReopened message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueReopened.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
            if (message.repo != null && Object.hasOwnProperty.call(message, "repo"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.repo);
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.url);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified IssueReopened message, length delimited. Does not implicitly {@link protos.IssueReopened.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.IssueReopened
         * @static
         * @param {protos.IIssueReopened} message IssueReopened message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueReopened.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IssueReopened message from the specified reader or buffer.
         * @function decode
         * @memberof protos.IssueReopened
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.IssueReopened} IssueReopened
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueReopened.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.IssueReopened();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                case 2:
                    message.repo = reader.string();
                    break;
                case 3:
                    message.number = reader.int32();
                    break;
                case 4:
                    message.url = reader.string();
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IssueReopened message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.IssueReopened
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.IssueReopened} IssueReopened
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueReopened.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IssueReopened message.
         * @function verify
         * @memberof protos.IssueReopened
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IssueReopened.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isString(message.owner))
                    return "owner: string expected";
            if (message.repo != null && message.hasOwnProperty("repo"))
                if (!$util.isString(message.repo))
                    return "repo: string expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number))
                    return "number: integer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates an IssueReopened message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.IssueReopened
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.IssueReopened} IssueReopened
         */
        IssueReopened.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.IssueReopened)
                return object;
            var message = new $root.protos.IssueReopened();
            if (object.owner != null)
                message.owner = String(object.owner);
            if (object.repo != null)
                message.repo = String(object.repo);
            if (object.number != null)
                message.number = object.number | 0;
            if (object.url != null)
                message.url = String(object.url);
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from an IssueReopened message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.IssueReopened
         * @static
         * @param {protos.IssueReopened} message IssueReopened
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IssueReopened.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.owner = "";
                object.repo = "";
                object.number = 0;
                object.url = "";
                object.description = "";
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            if (message.repo != null && message.hasOwnProperty("repo"))
                object.repo = message.repo;
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this IssueReopened to JSON.
         * @function toJSON
         * @memberof protos.IssueReopened
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IssueReopened.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IssueReopened;
    })();

    protos.IssueClosed = (function() {

        /**
         * Properties of an IssueClosed.
         * @memberof protos
         * @interface IIssueClosed
         * @property {string|null} [owner] IssueClosed owner
         * @property {string|null} [repo] IssueClosed repo
         * @property {number|null} [number] IssueClosed number
         * @property {string|null} [url] IssueClosed url
         * @property {string|null} [description] IssueClosed description
         */

        /**
         * Constructs a new IssueClosed.
         * @memberof protos
         * @classdesc Represents an IssueClosed.
         * @implements IIssueClosed
         * @constructor
         * @param {protos.IIssueClosed=} [properties] Properties to set
         */
        function IssueClosed(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IssueClosed owner.
         * @member {string} owner
         * @memberof protos.IssueClosed
         * @instance
         */
        IssueClosed.prototype.owner = "";

        /**
         * IssueClosed repo.
         * @member {string} repo
         * @memberof protos.IssueClosed
         * @instance
         */
        IssueClosed.prototype.repo = "";

        /**
         * IssueClosed number.
         * @member {number} number
         * @memberof protos.IssueClosed
         * @instance
         */
        IssueClosed.prototype.number = 0;

        /**
         * IssueClosed url.
         * @member {string} url
         * @memberof protos.IssueClosed
         * @instance
         */
        IssueClosed.prototype.url = "";

        /**
         * IssueClosed description.
         * @member {string} description
         * @memberof protos.IssueClosed
         * @instance
         */
        IssueClosed.prototype.description = "";

        /**
         * Creates a new IssueClosed instance using the specified properties.
         * @function create
         * @memberof protos.IssueClosed
         * @static
         * @param {protos.IIssueClosed=} [properties] Properties to set
         * @returns {protos.IssueClosed} IssueClosed instance
         */
        IssueClosed.create = function create(properties) {
            return new IssueClosed(properties);
        };

        /**
         * Encodes the specified IssueClosed message. Does not implicitly {@link protos.IssueClosed.verify|verify} messages.
         * @function encode
         * @memberof protos.IssueClosed
         * @static
         * @param {protos.IIssueClosed} message IssueClosed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueClosed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
            if (message.repo != null && Object.hasOwnProperty.call(message, "repo"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.repo);
            if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.url);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified IssueClosed message, length delimited. Does not implicitly {@link protos.IssueClosed.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.IssueClosed
         * @static
         * @param {protos.IIssueClosed} message IssueClosed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueClosed.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IssueClosed message from the specified reader or buffer.
         * @function decode
         * @memberof protos.IssueClosed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.IssueClosed} IssueClosed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueClosed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.IssueClosed();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                case 2:
                    message.repo = reader.string();
                    break;
                case 3:
                    message.number = reader.int32();
                    break;
                case 4:
                    message.url = reader.string();
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IssueClosed message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.IssueClosed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.IssueClosed} IssueClosed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueClosed.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IssueClosed message.
         * @function verify
         * @memberof protos.IssueClosed
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IssueClosed.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isString(message.owner))
                    return "owner: string expected";
            if (message.repo != null && message.hasOwnProperty("repo"))
                if (!$util.isString(message.repo))
                    return "repo: string expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number))
                    return "number: integer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates an IssueClosed message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.IssueClosed
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.IssueClosed} IssueClosed
         */
        IssueClosed.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.IssueClosed)
                return object;
            var message = new $root.protos.IssueClosed();
            if (object.owner != null)
                message.owner = String(object.owner);
            if (object.repo != null)
                message.repo = String(object.repo);
            if (object.number != null)
                message.number = object.number | 0;
            if (object.url != null)
                message.url = String(object.url);
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from an IssueClosed message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.IssueClosed
         * @static
         * @param {protos.IssueClosed} message IssueClosed
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IssueClosed.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.owner = "";
                object.repo = "";
                object.number = 0;
                object.url = "";
                object.description = "";
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            if (message.repo != null && message.hasOwnProperty("repo"))
                object.repo = message.repo;
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this IssueClosed to JSON.
         * @function toJSON
         * @memberof protos.IssueClosed
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IssueClosed.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IssueClosed;
    })();

    protos.GetVCEventsRequest = (function() {

        /**
         * Properties of a GetVCEventsRequest.
         * @memberof protos
         * @interface IGetVCEventsRequest
         * @property {protos.common.IAuth|null} [auth] GetVCEventsRequest auth
         */

        /**
         * Constructs a new GetVCEventsRequest.
         * @memberof protos
         * @classdesc Represents a GetVCEventsRequest.
         * @implements IGetVCEventsRequest
         * @constructor
         * @param {protos.IGetVCEventsRequest=} [properties] Properties to set
         */
        function GetVCEventsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetVCEventsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetVCEventsRequest
         * @instance
         */
        GetVCEventsRequest.prototype.auth = null;

        /**
         * Creates a new GetVCEventsRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetVCEventsRequest
         * @static
         * @param {protos.IGetVCEventsRequest=} [properties] Properties to set
         * @returns {protos.GetVCEventsRequest} GetVCEventsRequest instance
         */
        GetVCEventsRequest.create = function create(properties) {
            return new GetVCEventsRequest(properties);
        };

        /**
         * Encodes the specified GetVCEventsRequest message. Does not implicitly {@link protos.GetVCEventsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetVCEventsRequest
         * @static
         * @param {protos.IGetVCEventsRequest} message GetVCEventsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVCEventsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetVCEventsRequest message, length delimited. Does not implicitly {@link protos.GetVCEventsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetVCEventsRequest
         * @static
         * @param {protos.IGetVCEventsRequest} message GetVCEventsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVCEventsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetVCEventsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetVCEventsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetVCEventsRequest} GetVCEventsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVCEventsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetVCEventsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetVCEventsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetVCEventsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetVCEventsRequest} GetVCEventsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVCEventsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetVCEventsRequest message.
         * @function verify
         * @memberof protos.GetVCEventsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetVCEventsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetVCEventsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetVCEventsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetVCEventsRequest} GetVCEventsRequest
         */
        GetVCEventsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetVCEventsRequest)
                return object;
            var message = new $root.protos.GetVCEventsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetVCEventsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetVCEventsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetVCEventsRequest
         * @static
         * @param {protos.GetVCEventsRequest} message GetVCEventsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetVCEventsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetVCEventsRequest to JSON.
         * @function toJSON
         * @memberof protos.GetVCEventsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetVCEventsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetVCEventsRequest;
    })();

    protos.GetMonitorRequest = (function() {

        /**
         * Properties of a GetMonitorRequest.
         * @memberof protos
         * @interface IGetMonitorRequest
         * @property {protos.common.IAuth|null} [auth] GetMonitorRequest auth
         * @property {string|null} [monitorId] GetMonitorRequest monitorId
         */

        /**
         * Constructs a new GetMonitorRequest.
         * @memberof protos
         * @classdesc Represents a GetMonitorRequest.
         * @implements IGetMonitorRequest
         * @constructor
         * @param {protos.IGetMonitorRequest=} [properties] Properties to set
         */
        function GetMonitorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetMonitorRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetMonitorRequest
         * @instance
         */
        GetMonitorRequest.prototype.auth = null;

        /**
         * GetMonitorRequest monitorId.
         * @member {string} monitorId
         * @memberof protos.GetMonitorRequest
         * @instance
         */
        GetMonitorRequest.prototype.monitorId = "";

        /**
         * Creates a new GetMonitorRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetMonitorRequest
         * @static
         * @param {protos.IGetMonitorRequest=} [properties] Properties to set
         * @returns {protos.GetMonitorRequest} GetMonitorRequest instance
         */
        GetMonitorRequest.create = function create(properties) {
            return new GetMonitorRequest(properties);
        };

        /**
         * Encodes the specified GetMonitorRequest message. Does not implicitly {@link protos.GetMonitorRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetMonitorRequest
         * @static
         * @param {protos.IGetMonitorRequest} message GetMonitorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMonitorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.monitorId != null && Object.hasOwnProperty.call(message, "monitorId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.monitorId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetMonitorRequest message, length delimited. Does not implicitly {@link protos.GetMonitorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetMonitorRequest
         * @static
         * @param {protos.IGetMonitorRequest} message GetMonitorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMonitorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMonitorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetMonitorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetMonitorRequest} GetMonitorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMonitorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetMonitorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.monitorId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMonitorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetMonitorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetMonitorRequest} GetMonitorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMonitorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMonitorRequest message.
         * @function verify
         * @memberof protos.GetMonitorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMonitorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.monitorId != null && message.hasOwnProperty("monitorId"))
                if (!$util.isString(message.monitorId))
                    return "monitorId: string expected";
            return null;
        };

        /**
         * Creates a GetMonitorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetMonitorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetMonitorRequest} GetMonitorRequest
         */
        GetMonitorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetMonitorRequest)
                return object;
            var message = new $root.protos.GetMonitorRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetMonitorRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.monitorId != null)
                message.monitorId = String(object.monitorId);
            return message;
        };

        /**
         * Creates a plain object from a GetMonitorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetMonitorRequest
         * @static
         * @param {protos.GetMonitorRequest} message GetMonitorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMonitorRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.monitorId = "";
                object.auth = null;
            }
            if (message.monitorId != null && message.hasOwnProperty("monitorId"))
                object.monitorId = message.monitorId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetMonitorRequest to JSON.
         * @function toJSON
         * @memberof protos.GetMonitorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMonitorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetMonitorRequest;
    })();

    protos.GetMonitorResponse = (function() {

        /**
         * Properties of a GetMonitorResponse.
         * @memberof protos
         * @interface IGetMonitorResponse
         * @property {protos.opts.IMonitorOptions|null} [monitor] GetMonitorResponse monitor
         * @property {protos.common.IStatus|null} [status] GetMonitorResponse status
         */

        /**
         * Constructs a new GetMonitorResponse.
         * @memberof protos
         * @classdesc Represents a GetMonitorResponse.
         * @implements IGetMonitorResponse
         * @constructor
         * @param {protos.IGetMonitorResponse=} [properties] Properties to set
         */
        function GetMonitorResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetMonitorResponse monitor.
         * @member {protos.opts.IMonitorOptions|null|undefined} monitor
         * @memberof protos.GetMonitorResponse
         * @instance
         */
        GetMonitorResponse.prototype.monitor = null;

        /**
         * GetMonitorResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetMonitorResponse
         * @instance
         */
        GetMonitorResponse.prototype.status = null;

        /**
         * Creates a new GetMonitorResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetMonitorResponse
         * @static
         * @param {protos.IGetMonitorResponse=} [properties] Properties to set
         * @returns {protos.GetMonitorResponse} GetMonitorResponse instance
         */
        GetMonitorResponse.create = function create(properties) {
            return new GetMonitorResponse(properties);
        };

        /**
         * Encodes the specified GetMonitorResponse message. Does not implicitly {@link protos.GetMonitorResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetMonitorResponse
         * @static
         * @param {protos.IGetMonitorResponse} message GetMonitorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMonitorResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.monitor != null && Object.hasOwnProperty.call(message, "monitor"))
                $root.protos.opts.MonitorOptions.encode(message.monitor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetMonitorResponse message, length delimited. Does not implicitly {@link protos.GetMonitorResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetMonitorResponse
         * @static
         * @param {protos.IGetMonitorResponse} message GetMonitorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMonitorResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMonitorResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetMonitorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetMonitorResponse} GetMonitorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMonitorResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetMonitorResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.monitor = $root.protos.opts.MonitorOptions.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMonitorResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetMonitorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetMonitorResponse} GetMonitorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMonitorResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMonitorResponse message.
         * @function verify
         * @memberof protos.GetMonitorResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMonitorResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.monitor != null && message.hasOwnProperty("monitor")) {
                var error = $root.protos.opts.MonitorOptions.verify(message.monitor);
                if (error)
                    return "monitor." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a GetMonitorResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetMonitorResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetMonitorResponse} GetMonitorResponse
         */
        GetMonitorResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetMonitorResponse)
                return object;
            var message = new $root.protos.GetMonitorResponse();
            if (object.monitor != null) {
                if (typeof object.monitor !== "object")
                    throw TypeError(".protos.GetMonitorResponse.monitor: object expected");
                message.monitor = $root.protos.opts.MonitorOptions.fromObject(object.monitor);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetMonitorResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetMonitorResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetMonitorResponse
         * @static
         * @param {protos.GetMonitorResponse} message GetMonitorResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMonitorResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.monitor = null;
                object.status = null;
            }
            if (message.monitor != null && message.hasOwnProperty("monitor"))
                object.monitor = $root.protos.opts.MonitorOptions.toObject(message.monitor, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetMonitorResponse to JSON.
         * @function toJSON
         * @memberof protos.GetMonitorResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMonitorResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetMonitorResponse;
    })();

    protos.CreateMonitorRequest = (function() {

        /**
         * Properties of a CreateMonitorRequest.
         * @memberof protos
         * @interface ICreateMonitorRequest
         * @property {protos.common.IAuth|null} [auth] CreateMonitorRequest auth
         * @property {protos.opts.IMonitorOptions|null} [read] CreateMonitorRequest read
         */

        /**
         * Constructs a new CreateMonitorRequest.
         * @memberof protos
         * @classdesc Represents a CreateMonitorRequest.
         * @implements ICreateMonitorRequest
         * @constructor
         * @param {protos.ICreateMonitorRequest=} [properties] Properties to set
         */
        function CreateMonitorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateMonitorRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateMonitorRequest
         * @instance
         */
        CreateMonitorRequest.prototype.auth = null;

        /**
         * CreateMonitorRequest read.
         * @member {protos.opts.IMonitorOptions|null|undefined} read
         * @memberof protos.CreateMonitorRequest
         * @instance
         */
        CreateMonitorRequest.prototype.read = null;

        /**
         * Creates a new CreateMonitorRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateMonitorRequest
         * @static
         * @param {protos.ICreateMonitorRequest=} [properties] Properties to set
         * @returns {protos.CreateMonitorRequest} CreateMonitorRequest instance
         */
        CreateMonitorRequest.create = function create(properties) {
            return new CreateMonitorRequest(properties);
        };

        /**
         * Encodes the specified CreateMonitorRequest message. Does not implicitly {@link protos.CreateMonitorRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateMonitorRequest
         * @static
         * @param {protos.ICreateMonitorRequest} message CreateMonitorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMonitorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.read != null && Object.hasOwnProperty.call(message, "read"))
                $root.protos.opts.MonitorOptions.encode(message.read, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateMonitorRequest message, length delimited. Does not implicitly {@link protos.CreateMonitorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateMonitorRequest
         * @static
         * @param {protos.ICreateMonitorRequest} message CreateMonitorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMonitorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateMonitorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateMonitorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateMonitorRequest} CreateMonitorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMonitorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateMonitorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.read = $root.protos.opts.MonitorOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateMonitorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateMonitorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateMonitorRequest} CreateMonitorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMonitorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateMonitorRequest message.
         * @function verify
         * @memberof protos.CreateMonitorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateMonitorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.read != null && message.hasOwnProperty("read")) {
                var error = $root.protos.opts.MonitorOptions.verify(message.read);
                if (error)
                    return "read." + error;
            }
            return null;
        };

        /**
         * Creates a CreateMonitorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateMonitorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateMonitorRequest} CreateMonitorRequest
         */
        CreateMonitorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateMonitorRequest)
                return object;
            var message = new $root.protos.CreateMonitorRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateMonitorRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.read != null) {
                if (typeof object.read !== "object")
                    throw TypeError(".protos.CreateMonitorRequest.read: object expected");
                message.read = $root.protos.opts.MonitorOptions.fromObject(object.read);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateMonitorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateMonitorRequest
         * @static
         * @param {protos.CreateMonitorRequest} message CreateMonitorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateMonitorRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.read = null;
                object.auth = null;
            }
            if (message.read != null && message.hasOwnProperty("read"))
                object.read = $root.protos.opts.MonitorOptions.toObject(message.read, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateMonitorRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateMonitorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateMonitorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateMonitorRequest;
    })();

    protos.CreateMonitorResponse = (function() {

        /**
         * Properties of a CreateMonitorResponse.
         * @memberof protos
         * @interface ICreateMonitorResponse
         * @property {protos.opts.IMonitorOptions|null} [monitor] CreateMonitorResponse monitor
         * @property {protos.common.IStatus|null} [status] CreateMonitorResponse status
         */

        /**
         * Constructs a new CreateMonitorResponse.
         * @memberof protos
         * @classdesc Represents a CreateMonitorResponse.
         * @implements ICreateMonitorResponse
         * @constructor
         * @param {protos.ICreateMonitorResponse=} [properties] Properties to set
         */
        function CreateMonitorResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateMonitorResponse monitor.
         * @member {protos.opts.IMonitorOptions|null|undefined} monitor
         * @memberof protos.CreateMonitorResponse
         * @instance
         */
        CreateMonitorResponse.prototype.monitor = null;

        /**
         * CreateMonitorResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.CreateMonitorResponse
         * @instance
         */
        CreateMonitorResponse.prototype.status = null;

        /**
         * Creates a new CreateMonitorResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateMonitorResponse
         * @static
         * @param {protos.ICreateMonitorResponse=} [properties] Properties to set
         * @returns {protos.CreateMonitorResponse} CreateMonitorResponse instance
         */
        CreateMonitorResponse.create = function create(properties) {
            return new CreateMonitorResponse(properties);
        };

        /**
         * Encodes the specified CreateMonitorResponse message. Does not implicitly {@link protos.CreateMonitorResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateMonitorResponse
         * @static
         * @param {protos.ICreateMonitorResponse} message CreateMonitorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMonitorResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.monitor != null && Object.hasOwnProperty.call(message, "monitor"))
                $root.protos.opts.MonitorOptions.encode(message.monitor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateMonitorResponse message, length delimited. Does not implicitly {@link protos.CreateMonitorResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateMonitorResponse
         * @static
         * @param {protos.ICreateMonitorResponse} message CreateMonitorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMonitorResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateMonitorResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateMonitorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateMonitorResponse} CreateMonitorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMonitorResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateMonitorResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.monitor = $root.protos.opts.MonitorOptions.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateMonitorResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateMonitorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateMonitorResponse} CreateMonitorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMonitorResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateMonitorResponse message.
         * @function verify
         * @memberof protos.CreateMonitorResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateMonitorResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.monitor != null && message.hasOwnProperty("monitor")) {
                var error = $root.protos.opts.MonitorOptions.verify(message.monitor);
                if (error)
                    return "monitor." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a CreateMonitorResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateMonitorResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateMonitorResponse} CreateMonitorResponse
         */
        CreateMonitorResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateMonitorResponse)
                return object;
            var message = new $root.protos.CreateMonitorResponse();
            if (object.monitor != null) {
                if (typeof object.monitor !== "object")
                    throw TypeError(".protos.CreateMonitorResponse.monitor: object expected");
                message.monitor = $root.protos.opts.MonitorOptions.fromObject(object.monitor);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.CreateMonitorResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateMonitorResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateMonitorResponse
         * @static
         * @param {protos.CreateMonitorResponse} message CreateMonitorResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateMonitorResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.monitor = null;
                object.status = null;
            }
            if (message.monitor != null && message.hasOwnProperty("monitor"))
                object.monitor = $root.protos.opts.MonitorOptions.toObject(message.monitor, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this CreateMonitorResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateMonitorResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateMonitorResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateMonitorResponse;
    })();

    protos.DeleteMonitorRequest = (function() {

        /**
         * Properties of a DeleteMonitorRequest.
         * @memberof protos
         * @interface IDeleteMonitorRequest
         * @property {protos.common.IAuth|null} [auth] DeleteMonitorRequest auth
         * @property {string|null} [monitorId] DeleteMonitorRequest monitorId
         */

        /**
         * Constructs a new DeleteMonitorRequest.
         * @memberof protos
         * @classdesc Represents a DeleteMonitorRequest.
         * @implements IDeleteMonitorRequest
         * @constructor
         * @param {protos.IDeleteMonitorRequest=} [properties] Properties to set
         */
        function DeleteMonitorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteMonitorRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteMonitorRequest
         * @instance
         */
        DeleteMonitorRequest.prototype.auth = null;

        /**
         * DeleteMonitorRequest monitorId.
         * @member {string} monitorId
         * @memberof protos.DeleteMonitorRequest
         * @instance
         */
        DeleteMonitorRequest.prototype.monitorId = "";

        /**
         * Creates a new DeleteMonitorRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteMonitorRequest
         * @static
         * @param {protos.IDeleteMonitorRequest=} [properties] Properties to set
         * @returns {protos.DeleteMonitorRequest} DeleteMonitorRequest instance
         */
        DeleteMonitorRequest.create = function create(properties) {
            return new DeleteMonitorRequest(properties);
        };

        /**
         * Encodes the specified DeleteMonitorRequest message. Does not implicitly {@link protos.DeleteMonitorRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteMonitorRequest
         * @static
         * @param {protos.IDeleteMonitorRequest} message DeleteMonitorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteMonitorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.monitorId != null && Object.hasOwnProperty.call(message, "monitorId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.monitorId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteMonitorRequest message, length delimited. Does not implicitly {@link protos.DeleteMonitorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteMonitorRequest
         * @static
         * @param {protos.IDeleteMonitorRequest} message DeleteMonitorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteMonitorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteMonitorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteMonitorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteMonitorRequest} DeleteMonitorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteMonitorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteMonitorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.monitorId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteMonitorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteMonitorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteMonitorRequest} DeleteMonitorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteMonitorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteMonitorRequest message.
         * @function verify
         * @memberof protos.DeleteMonitorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteMonitorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.monitorId != null && message.hasOwnProperty("monitorId"))
                if (!$util.isString(message.monitorId))
                    return "monitorId: string expected";
            return null;
        };

        /**
         * Creates a DeleteMonitorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteMonitorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteMonitorRequest} DeleteMonitorRequest
         */
        DeleteMonitorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteMonitorRequest)
                return object;
            var message = new $root.protos.DeleteMonitorRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteMonitorRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.monitorId != null)
                message.monitorId = String(object.monitorId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteMonitorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteMonitorRequest
         * @static
         * @param {protos.DeleteMonitorRequest} message DeleteMonitorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteMonitorRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.monitorId = "";
                object.auth = null;
            }
            if (message.monitorId != null && message.hasOwnProperty("monitorId"))
                object.monitorId = message.monitorId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteMonitorRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteMonitorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteMonitorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteMonitorRequest;
    })();

    protos.DeleteMonitorResponse = (function() {

        /**
         * Properties of a DeleteMonitorResponse.
         * @memberof protos
         * @interface IDeleteMonitorResponse
         * @property {protos.common.IStatus|null} [status] DeleteMonitorResponse status
         */

        /**
         * Constructs a new DeleteMonitorResponse.
         * @memberof protos
         * @classdesc Represents a DeleteMonitorResponse.
         * @implements IDeleteMonitorResponse
         * @constructor
         * @param {protos.IDeleteMonitorResponse=} [properties] Properties to set
         */
        function DeleteMonitorResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteMonitorResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteMonitorResponse
         * @instance
         */
        DeleteMonitorResponse.prototype.status = null;

        /**
         * Creates a new DeleteMonitorResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteMonitorResponse
         * @static
         * @param {protos.IDeleteMonitorResponse=} [properties] Properties to set
         * @returns {protos.DeleteMonitorResponse} DeleteMonitorResponse instance
         */
        DeleteMonitorResponse.create = function create(properties) {
            return new DeleteMonitorResponse(properties);
        };

        /**
         * Encodes the specified DeleteMonitorResponse message. Does not implicitly {@link protos.DeleteMonitorResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteMonitorResponse
         * @static
         * @param {protos.IDeleteMonitorResponse} message DeleteMonitorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteMonitorResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteMonitorResponse message, length delimited. Does not implicitly {@link protos.DeleteMonitorResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteMonitorResponse
         * @static
         * @param {protos.IDeleteMonitorResponse} message DeleteMonitorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteMonitorResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteMonitorResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteMonitorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteMonitorResponse} DeleteMonitorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteMonitorResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteMonitorResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteMonitorResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteMonitorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteMonitorResponse} DeleteMonitorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteMonitorResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteMonitorResponse message.
         * @function verify
         * @memberof protos.DeleteMonitorResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteMonitorResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteMonitorResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteMonitorResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteMonitorResponse} DeleteMonitorResponse
         */
        DeleteMonitorResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteMonitorResponse)
                return object;
            var message = new $root.protos.DeleteMonitorResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteMonitorResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteMonitorResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteMonitorResponse
         * @static
         * @param {protos.DeleteMonitorResponse} message DeleteMonitorResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteMonitorResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteMonitorResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteMonitorResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteMonitorResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteMonitorResponse;
    })();

    protos.UpdateMonitorRequest = (function() {

        /**
         * Properties of an UpdateMonitorRequest.
         * @memberof protos
         * @interface IUpdateMonitorRequest
         * @property {protos.common.IAuth|null} [auth] UpdateMonitorRequest auth
         * @property {protos.opts.IMonitorOptions|null} [monitor] UpdateMonitorRequest monitor
         */

        /**
         * Constructs a new UpdateMonitorRequest.
         * @memberof protos
         * @classdesc Represents an UpdateMonitorRequest.
         * @implements IUpdateMonitorRequest
         * @constructor
         * @param {protos.IUpdateMonitorRequest=} [properties] Properties to set
         */
        function UpdateMonitorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateMonitorRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateMonitorRequest
         * @instance
         */
        UpdateMonitorRequest.prototype.auth = null;

        /**
         * UpdateMonitorRequest monitor.
         * @member {protos.opts.IMonitorOptions|null|undefined} monitor
         * @memberof protos.UpdateMonitorRequest
         * @instance
         */
        UpdateMonitorRequest.prototype.monitor = null;

        /**
         * Creates a new UpdateMonitorRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateMonitorRequest
         * @static
         * @param {protos.IUpdateMonitorRequest=} [properties] Properties to set
         * @returns {protos.UpdateMonitorRequest} UpdateMonitorRequest instance
         */
        UpdateMonitorRequest.create = function create(properties) {
            return new UpdateMonitorRequest(properties);
        };

        /**
         * Encodes the specified UpdateMonitorRequest message. Does not implicitly {@link protos.UpdateMonitorRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateMonitorRequest
         * @static
         * @param {protos.IUpdateMonitorRequest} message UpdateMonitorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMonitorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.monitor != null && Object.hasOwnProperty.call(message, "monitor"))
                $root.protos.opts.MonitorOptions.encode(message.monitor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateMonitorRequest message, length delimited. Does not implicitly {@link protos.UpdateMonitorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateMonitorRequest
         * @static
         * @param {protos.IUpdateMonitorRequest} message UpdateMonitorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMonitorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateMonitorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateMonitorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateMonitorRequest} UpdateMonitorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMonitorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateMonitorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.monitor = $root.protos.opts.MonitorOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateMonitorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateMonitorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateMonitorRequest} UpdateMonitorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMonitorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateMonitorRequest message.
         * @function verify
         * @memberof protos.UpdateMonitorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateMonitorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.monitor != null && message.hasOwnProperty("monitor")) {
                var error = $root.protos.opts.MonitorOptions.verify(message.monitor);
                if (error)
                    return "monitor." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateMonitorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateMonitorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateMonitorRequest} UpdateMonitorRequest
         */
        UpdateMonitorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateMonitorRequest)
                return object;
            var message = new $root.protos.UpdateMonitorRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateMonitorRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.monitor != null) {
                if (typeof object.monitor !== "object")
                    throw TypeError(".protos.UpdateMonitorRequest.monitor: object expected");
                message.monitor = $root.protos.opts.MonitorOptions.fromObject(object.monitor);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateMonitorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateMonitorRequest
         * @static
         * @param {protos.UpdateMonitorRequest} message UpdateMonitorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateMonitorRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.monitor = null;
                object.auth = null;
            }
            if (message.monitor != null && message.hasOwnProperty("monitor"))
                object.monitor = $root.protos.opts.MonitorOptions.toObject(message.monitor, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateMonitorRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateMonitorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateMonitorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateMonitorRequest;
    })();

    protos.UpdateMonitorResponse = (function() {

        /**
         * Properties of an UpdateMonitorResponse.
         * @memberof protos
         * @interface IUpdateMonitorResponse
         * @property {protos.opts.IMonitorOptions|null} [monitor] UpdateMonitorResponse monitor
         * @property {protos.common.IStatus|null} [status] UpdateMonitorResponse status
         */

        /**
         * Constructs a new UpdateMonitorResponse.
         * @memberof protos
         * @classdesc Represents an UpdateMonitorResponse.
         * @implements IUpdateMonitorResponse
         * @constructor
         * @param {protos.IUpdateMonitorResponse=} [properties] Properties to set
         */
        function UpdateMonitorResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateMonitorResponse monitor.
         * @member {protos.opts.IMonitorOptions|null|undefined} monitor
         * @memberof protos.UpdateMonitorResponse
         * @instance
         */
        UpdateMonitorResponse.prototype.monitor = null;

        /**
         * UpdateMonitorResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateMonitorResponse
         * @instance
         */
        UpdateMonitorResponse.prototype.status = null;

        /**
         * Creates a new UpdateMonitorResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateMonitorResponse
         * @static
         * @param {protos.IUpdateMonitorResponse=} [properties] Properties to set
         * @returns {protos.UpdateMonitorResponse} UpdateMonitorResponse instance
         */
        UpdateMonitorResponse.create = function create(properties) {
            return new UpdateMonitorResponse(properties);
        };

        /**
         * Encodes the specified UpdateMonitorResponse message. Does not implicitly {@link protos.UpdateMonitorResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateMonitorResponse
         * @static
         * @param {protos.IUpdateMonitorResponse} message UpdateMonitorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMonitorResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.monitor != null && Object.hasOwnProperty.call(message, "monitor"))
                $root.protos.opts.MonitorOptions.encode(message.monitor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateMonitorResponse message, length delimited. Does not implicitly {@link protos.UpdateMonitorResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateMonitorResponse
         * @static
         * @param {protos.IUpdateMonitorResponse} message UpdateMonitorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMonitorResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateMonitorResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateMonitorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateMonitorResponse} UpdateMonitorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMonitorResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateMonitorResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.monitor = $root.protos.opts.MonitorOptions.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateMonitorResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateMonitorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateMonitorResponse} UpdateMonitorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMonitorResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateMonitorResponse message.
         * @function verify
         * @memberof protos.UpdateMonitorResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateMonitorResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.monitor != null && message.hasOwnProperty("monitor")) {
                var error = $root.protos.opts.MonitorOptions.verify(message.monitor);
                if (error)
                    return "monitor." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateMonitorResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateMonitorResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateMonitorResponse} UpdateMonitorResponse
         */
        UpdateMonitorResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateMonitorResponse)
                return object;
            var message = new $root.protos.UpdateMonitorResponse();
            if (object.monitor != null) {
                if (typeof object.monitor !== "object")
                    throw TypeError(".protos.UpdateMonitorResponse.monitor: object expected");
                message.monitor = $root.protos.opts.MonitorOptions.fromObject(object.monitor);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateMonitorResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateMonitorResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateMonitorResponse
         * @static
         * @param {protos.UpdateMonitorResponse} message UpdateMonitorResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateMonitorResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.monitor = null;
                object.status = null;
            }
            if (message.monitor != null && message.hasOwnProperty("monitor"))
                object.monitor = $root.protos.opts.MonitorOptions.toObject(message.monitor, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateMonitorResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateMonitorResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateMonitorResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateMonitorResponse;
    })();

    protos.GetValidationRequest = (function() {

        /**
         * Properties of a GetValidationRequest.
         * @memberof protos
         * @interface IGetValidationRequest
         * @property {protos.common.IAuth|null} [auth] GetValidationRequest auth
         * @property {string|null} [id] GetValidationRequest id
         */

        /**
         * Constructs a new GetValidationRequest.
         * @memberof protos
         * @classdesc Represents a GetValidationRequest.
         * @implements IGetValidationRequest
         * @constructor
         * @param {protos.IGetValidationRequest=} [properties] Properties to set
         */
        function GetValidationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetValidationRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetValidationRequest
         * @instance
         */
        GetValidationRequest.prototype.auth = null;

        /**
         * GetValidationRequest id.
         * @member {string} id
         * @memberof protos.GetValidationRequest
         * @instance
         */
        GetValidationRequest.prototype.id = "";

        /**
         * Creates a new GetValidationRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetValidationRequest
         * @static
         * @param {protos.IGetValidationRequest=} [properties] Properties to set
         * @returns {protos.GetValidationRequest} GetValidationRequest instance
         */
        GetValidationRequest.create = function create(properties) {
            return new GetValidationRequest(properties);
        };

        /**
         * Encodes the specified GetValidationRequest message. Does not implicitly {@link protos.GetValidationRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetValidationRequest
         * @static
         * @param {protos.IGetValidationRequest} message GetValidationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetValidationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetValidationRequest message, length delimited. Does not implicitly {@link protos.GetValidationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetValidationRequest
         * @static
         * @param {protos.IGetValidationRequest} message GetValidationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetValidationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetValidationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetValidationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetValidationRequest} GetValidationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetValidationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetValidationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetValidationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetValidationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetValidationRequest} GetValidationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetValidationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetValidationRequest message.
         * @function verify
         * @memberof protos.GetValidationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetValidationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a GetValidationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetValidationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetValidationRequest} GetValidationRequest
         */
        GetValidationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetValidationRequest)
                return object;
            var message = new $root.protos.GetValidationRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetValidationRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a GetValidationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetValidationRequest
         * @static
         * @param {protos.GetValidationRequest} message GetValidationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetValidationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetValidationRequest to JSON.
         * @function toJSON
         * @memberof protos.GetValidationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetValidationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetValidationRequest;
    })();

    protos.GetValidationResponse = (function() {

        /**
         * Properties of a GetValidationResponse.
         * @memberof protos
         * @interface IGetValidationResponse
         * @property {protos.common.IValidation|null} [validation] GetValidationResponse validation
         */

        /**
         * Constructs a new GetValidationResponse.
         * @memberof protos
         * @classdesc Represents a GetValidationResponse.
         * @implements IGetValidationResponse
         * @constructor
         * @param {protos.IGetValidationResponse=} [properties] Properties to set
         */
        function GetValidationResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetValidationResponse validation.
         * @member {protos.common.IValidation|null|undefined} validation
         * @memberof protos.GetValidationResponse
         * @instance
         */
        GetValidationResponse.prototype.validation = null;

        /**
         * Creates a new GetValidationResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetValidationResponse
         * @static
         * @param {protos.IGetValidationResponse=} [properties] Properties to set
         * @returns {protos.GetValidationResponse} GetValidationResponse instance
         */
        GetValidationResponse.create = function create(properties) {
            return new GetValidationResponse(properties);
        };

        /**
         * Encodes the specified GetValidationResponse message. Does not implicitly {@link protos.GetValidationResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetValidationResponse
         * @static
         * @param {protos.IGetValidationResponse} message GetValidationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetValidationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validation != null && Object.hasOwnProperty.call(message, "validation"))
                $root.protos.common.Validation.encode(message.validation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetValidationResponse message, length delimited. Does not implicitly {@link protos.GetValidationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetValidationResponse
         * @static
         * @param {protos.IGetValidationResponse} message GetValidationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetValidationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetValidationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetValidationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetValidationResponse} GetValidationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetValidationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetValidationResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.validation = $root.protos.common.Validation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetValidationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetValidationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetValidationResponse} GetValidationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetValidationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetValidationResponse message.
         * @function verify
         * @memberof protos.GetValidationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetValidationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.validation != null && message.hasOwnProperty("validation")) {
                var error = $root.protos.common.Validation.verify(message.validation);
                if (error)
                    return "validation." + error;
            }
            return null;
        };

        /**
         * Creates a GetValidationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetValidationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetValidationResponse} GetValidationResponse
         */
        GetValidationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetValidationResponse)
                return object;
            var message = new $root.protos.GetValidationResponse();
            if (object.validation != null) {
                if (typeof object.validation !== "object")
                    throw TypeError(".protos.GetValidationResponse.validation: object expected");
                message.validation = $root.protos.common.Validation.fromObject(object.validation);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetValidationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetValidationResponse
         * @static
         * @param {protos.GetValidationResponse} message GetValidationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetValidationResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.validation = null;
            if (message.validation != null && message.hasOwnProperty("validation"))
                object.validation = $root.protos.common.Validation.toObject(message.validation, options);
            return object;
        };

        /**
         * Converts this GetValidationResponse to JSON.
         * @function toJSON
         * @memberof protos.GetValidationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetValidationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetValidationResponse;
    })();

    protos.GetAllValidationsRequest = (function() {

        /**
         * Properties of a GetAllValidationsRequest.
         * @memberof protos
         * @interface IGetAllValidationsRequest
         * @property {protos.common.IAuth|null} [auth] GetAllValidationsRequest auth
         * @property {string|null} [id] GetAllValidationsRequest id
         */

        /**
         * Constructs a new GetAllValidationsRequest.
         * @memberof protos
         * @classdesc Represents a GetAllValidationsRequest.
         * @implements IGetAllValidationsRequest
         * @constructor
         * @param {protos.IGetAllValidationsRequest=} [properties] Properties to set
         */
        function GetAllValidationsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllValidationsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllValidationsRequest
         * @instance
         */
        GetAllValidationsRequest.prototype.auth = null;

        /**
         * GetAllValidationsRequest id.
         * @member {string} id
         * @memberof protos.GetAllValidationsRequest
         * @instance
         */
        GetAllValidationsRequest.prototype.id = "";

        /**
         * Creates a new GetAllValidationsRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllValidationsRequest
         * @static
         * @param {protos.IGetAllValidationsRequest=} [properties] Properties to set
         * @returns {protos.GetAllValidationsRequest} GetAllValidationsRequest instance
         */
        GetAllValidationsRequest.create = function create(properties) {
            return new GetAllValidationsRequest(properties);
        };

        /**
         * Encodes the specified GetAllValidationsRequest message. Does not implicitly {@link protos.GetAllValidationsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllValidationsRequest
         * @static
         * @param {protos.IGetAllValidationsRequest} message GetAllValidationsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllValidationsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllValidationsRequest message, length delimited. Does not implicitly {@link protos.GetAllValidationsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllValidationsRequest
         * @static
         * @param {protos.IGetAllValidationsRequest} message GetAllValidationsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllValidationsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllValidationsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllValidationsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllValidationsRequest} GetAllValidationsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllValidationsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllValidationsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllValidationsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllValidationsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllValidationsRequest} GetAllValidationsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllValidationsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllValidationsRequest message.
         * @function verify
         * @memberof protos.GetAllValidationsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllValidationsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a GetAllValidationsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllValidationsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllValidationsRequest} GetAllValidationsRequest
         */
        GetAllValidationsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllValidationsRequest)
                return object;
            var message = new $root.protos.GetAllValidationsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllValidationsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a GetAllValidationsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllValidationsRequest
         * @static
         * @param {protos.GetAllValidationsRequest} message GetAllValidationsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllValidationsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllValidationsRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllValidationsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllValidationsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllValidationsRequest;
    })();

    protos.GetAllValidationsResponse = (function() {

        /**
         * Properties of a GetAllValidationsResponse.
         * @memberof protos
         * @interface IGetAllValidationsResponse
         * @property {Array.<protos.common.IValidation>|null} [validations] GetAllValidationsResponse validations
         */

        /**
         * Constructs a new GetAllValidationsResponse.
         * @memberof protos
         * @classdesc Represents a GetAllValidationsResponse.
         * @implements IGetAllValidationsResponse
         * @constructor
         * @param {protos.IGetAllValidationsResponse=} [properties] Properties to set
         */
        function GetAllValidationsResponse(properties) {
            this.validations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllValidationsResponse validations.
         * @member {Array.<protos.common.IValidation>} validations
         * @memberof protos.GetAllValidationsResponse
         * @instance
         */
        GetAllValidationsResponse.prototype.validations = $util.emptyArray;

        /**
         * Creates a new GetAllValidationsResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllValidationsResponse
         * @static
         * @param {protos.IGetAllValidationsResponse=} [properties] Properties to set
         * @returns {protos.GetAllValidationsResponse} GetAllValidationsResponse instance
         */
        GetAllValidationsResponse.create = function create(properties) {
            return new GetAllValidationsResponse(properties);
        };

        /**
         * Encodes the specified GetAllValidationsResponse message. Does not implicitly {@link protos.GetAllValidationsResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllValidationsResponse
         * @static
         * @param {protos.IGetAllValidationsResponse} message GetAllValidationsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllValidationsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validations != null && message.validations.length)
                for (var i = 0; i < message.validations.length; ++i)
                    $root.protos.common.Validation.encode(message.validations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllValidationsResponse message, length delimited. Does not implicitly {@link protos.GetAllValidationsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllValidationsResponse
         * @static
         * @param {protos.IGetAllValidationsResponse} message GetAllValidationsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllValidationsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllValidationsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllValidationsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllValidationsResponse} GetAllValidationsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllValidationsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllValidationsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.validations && message.validations.length))
                        message.validations = [];
                    message.validations.push($root.protos.common.Validation.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllValidationsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllValidationsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllValidationsResponse} GetAllValidationsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllValidationsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllValidationsResponse message.
         * @function verify
         * @memberof protos.GetAllValidationsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllValidationsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.validations != null && message.hasOwnProperty("validations")) {
                if (!Array.isArray(message.validations))
                    return "validations: array expected";
                for (var i = 0; i < message.validations.length; ++i) {
                    var error = $root.protos.common.Validation.verify(message.validations[i]);
                    if (error)
                        return "validations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetAllValidationsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllValidationsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllValidationsResponse} GetAllValidationsResponse
         */
        GetAllValidationsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllValidationsResponse)
                return object;
            var message = new $root.protos.GetAllValidationsResponse();
            if (object.validations) {
                if (!Array.isArray(object.validations))
                    throw TypeError(".protos.GetAllValidationsResponse.validations: array expected");
                message.validations = [];
                for (var i = 0; i < object.validations.length; ++i) {
                    if (typeof object.validations[i] !== "object")
                        throw TypeError(".protos.GetAllValidationsResponse.validations: object expected");
                    message.validations[i] = $root.protos.common.Validation.fromObject(object.validations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllValidationsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllValidationsResponse
         * @static
         * @param {protos.GetAllValidationsResponse} message GetAllValidationsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllValidationsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.validations = [];
            if (message.validations && message.validations.length) {
                object.validations = [];
                for (var j = 0; j < message.validations.length; ++j)
                    object.validations[j] = $root.protos.common.Validation.toObject(message.validations[j], options);
            }
            return object;
        };

        /**
         * Converts this GetAllValidationsResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllValidationsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllValidationsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllValidationsResponse;
    })();

    protos.CreateValidationRequest = (function() {

        /**
         * Properties of a CreateValidationRequest.
         * @memberof protos
         * @interface ICreateValidationRequest
         * @property {protos.common.IAuth|null} [auth] CreateValidationRequest auth
         * @property {protos.common.IValidation|null} [validation] CreateValidationRequest validation
         */

        /**
         * Constructs a new CreateValidationRequest.
         * @memberof protos
         * @classdesc Represents a CreateValidationRequest.
         * @implements ICreateValidationRequest
         * @constructor
         * @param {protos.ICreateValidationRequest=} [properties] Properties to set
         */
        function CreateValidationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateValidationRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateValidationRequest
         * @instance
         */
        CreateValidationRequest.prototype.auth = null;

        /**
         * CreateValidationRequest validation.
         * @member {protos.common.IValidation|null|undefined} validation
         * @memberof protos.CreateValidationRequest
         * @instance
         */
        CreateValidationRequest.prototype.validation = null;

        /**
         * Creates a new CreateValidationRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateValidationRequest
         * @static
         * @param {protos.ICreateValidationRequest=} [properties] Properties to set
         * @returns {protos.CreateValidationRequest} CreateValidationRequest instance
         */
        CreateValidationRequest.create = function create(properties) {
            return new CreateValidationRequest(properties);
        };

        /**
         * Encodes the specified CreateValidationRequest message. Does not implicitly {@link protos.CreateValidationRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateValidationRequest
         * @static
         * @param {protos.ICreateValidationRequest} message CreateValidationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateValidationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validation != null && Object.hasOwnProperty.call(message, "validation"))
                $root.protos.common.Validation.encode(message.validation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateValidationRequest message, length delimited. Does not implicitly {@link protos.CreateValidationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateValidationRequest
         * @static
         * @param {protos.ICreateValidationRequest} message CreateValidationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateValidationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateValidationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateValidationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateValidationRequest} CreateValidationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateValidationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateValidationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.validation = $root.protos.common.Validation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateValidationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateValidationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateValidationRequest} CreateValidationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateValidationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateValidationRequest message.
         * @function verify
         * @memberof protos.CreateValidationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateValidationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.validation != null && message.hasOwnProperty("validation")) {
                var error = $root.protos.common.Validation.verify(message.validation);
                if (error)
                    return "validation." + error;
            }
            return null;
        };

        /**
         * Creates a CreateValidationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateValidationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateValidationRequest} CreateValidationRequest
         */
        CreateValidationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateValidationRequest)
                return object;
            var message = new $root.protos.CreateValidationRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateValidationRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.validation != null) {
                if (typeof object.validation !== "object")
                    throw TypeError(".protos.CreateValidationRequest.validation: object expected");
                message.validation = $root.protos.common.Validation.fromObject(object.validation);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateValidationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateValidationRequest
         * @static
         * @param {protos.CreateValidationRequest} message CreateValidationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateValidationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.validation = null;
                object.auth = null;
            }
            if (message.validation != null && message.hasOwnProperty("validation"))
                object.validation = $root.protos.common.Validation.toObject(message.validation, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateValidationRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateValidationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateValidationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateValidationRequest;
    })();

    protos.CreateValidationResponse = (function() {

        /**
         * Properties of a CreateValidationResponse.
         * @memberof protos
         * @interface ICreateValidationResponse
         * @property {protos.common.IStatus|null} [status] CreateValidationResponse status
         * @property {protos.common.IValidation|null} [validation] CreateValidationResponse validation
         */

        /**
         * Constructs a new CreateValidationResponse.
         * @memberof protos
         * @classdesc Represents a CreateValidationResponse.
         * @implements ICreateValidationResponse
         * @constructor
         * @param {protos.ICreateValidationResponse=} [properties] Properties to set
         */
        function CreateValidationResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateValidationResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.CreateValidationResponse
         * @instance
         */
        CreateValidationResponse.prototype.status = null;

        /**
         * CreateValidationResponse validation.
         * @member {protos.common.IValidation|null|undefined} validation
         * @memberof protos.CreateValidationResponse
         * @instance
         */
        CreateValidationResponse.prototype.validation = null;

        /**
         * Creates a new CreateValidationResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateValidationResponse
         * @static
         * @param {protos.ICreateValidationResponse=} [properties] Properties to set
         * @returns {protos.CreateValidationResponse} CreateValidationResponse instance
         */
        CreateValidationResponse.create = function create(properties) {
            return new CreateValidationResponse(properties);
        };

        /**
         * Encodes the specified CreateValidationResponse message. Does not implicitly {@link protos.CreateValidationResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateValidationResponse
         * @static
         * @param {protos.ICreateValidationResponse} message CreateValidationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateValidationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validation != null && Object.hasOwnProperty.call(message, "validation"))
                $root.protos.common.Validation.encode(message.validation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateValidationResponse message, length delimited. Does not implicitly {@link protos.CreateValidationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateValidationResponse
         * @static
         * @param {protos.ICreateValidationResponse} message CreateValidationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateValidationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateValidationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateValidationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateValidationResponse} CreateValidationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateValidationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateValidationResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.validation = $root.protos.common.Validation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateValidationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateValidationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateValidationResponse} CreateValidationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateValidationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateValidationResponse message.
         * @function verify
         * @memberof protos.CreateValidationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateValidationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.validation != null && message.hasOwnProperty("validation")) {
                var error = $root.protos.common.Validation.verify(message.validation);
                if (error)
                    return "validation." + error;
            }
            return null;
        };

        /**
         * Creates a CreateValidationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateValidationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateValidationResponse} CreateValidationResponse
         */
        CreateValidationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateValidationResponse)
                return object;
            var message = new $root.protos.CreateValidationResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.CreateValidationResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.validation != null) {
                if (typeof object.validation !== "object")
                    throw TypeError(".protos.CreateValidationResponse.validation: object expected");
                message.validation = $root.protos.common.Validation.fromObject(object.validation);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateValidationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateValidationResponse
         * @static
         * @param {protos.CreateValidationResponse} message CreateValidationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateValidationResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.validation = null;
                object.status = null;
            }
            if (message.validation != null && message.hasOwnProperty("validation"))
                object.validation = $root.protos.common.Validation.toObject(message.validation, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this CreateValidationResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateValidationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateValidationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateValidationResponse;
    })();

    protos.UpdateValidationRequest = (function() {

        /**
         * Properties of an UpdateValidationRequest.
         * @memberof protos
         * @interface IUpdateValidationRequest
         * @property {protos.common.IAuth|null} [auth] UpdateValidationRequest auth
         * @property {string|null} [id] UpdateValidationRequest id
         * @property {protos.common.IValidation|null} [validation] UpdateValidationRequest validation
         */

        /**
         * Constructs a new UpdateValidationRequest.
         * @memberof protos
         * @classdesc Represents an UpdateValidationRequest.
         * @implements IUpdateValidationRequest
         * @constructor
         * @param {protos.IUpdateValidationRequest=} [properties] Properties to set
         */
        function UpdateValidationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateValidationRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateValidationRequest
         * @instance
         */
        UpdateValidationRequest.prototype.auth = null;

        /**
         * UpdateValidationRequest id.
         * @member {string} id
         * @memberof protos.UpdateValidationRequest
         * @instance
         */
        UpdateValidationRequest.prototype.id = "";

        /**
         * UpdateValidationRequest validation.
         * @member {protos.common.IValidation|null|undefined} validation
         * @memberof protos.UpdateValidationRequest
         * @instance
         */
        UpdateValidationRequest.prototype.validation = null;

        /**
         * Creates a new UpdateValidationRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateValidationRequest
         * @static
         * @param {protos.IUpdateValidationRequest=} [properties] Properties to set
         * @returns {protos.UpdateValidationRequest} UpdateValidationRequest instance
         */
        UpdateValidationRequest.create = function create(properties) {
            return new UpdateValidationRequest(properties);
        };

        /**
         * Encodes the specified UpdateValidationRequest message. Does not implicitly {@link protos.UpdateValidationRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateValidationRequest
         * @static
         * @param {protos.IUpdateValidationRequest} message UpdateValidationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateValidationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.validation != null && Object.hasOwnProperty.call(message, "validation"))
                $root.protos.common.Validation.encode(message.validation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateValidationRequest message, length delimited. Does not implicitly {@link protos.UpdateValidationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateValidationRequest
         * @static
         * @param {protos.IUpdateValidationRequest} message UpdateValidationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateValidationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateValidationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateValidationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateValidationRequest} UpdateValidationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateValidationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateValidationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.validation = $root.protos.common.Validation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateValidationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateValidationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateValidationRequest} UpdateValidationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateValidationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateValidationRequest message.
         * @function verify
         * @memberof protos.UpdateValidationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateValidationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.validation != null && message.hasOwnProperty("validation")) {
                var error = $root.protos.common.Validation.verify(message.validation);
                if (error)
                    return "validation." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateValidationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateValidationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateValidationRequest} UpdateValidationRequest
         */
        UpdateValidationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateValidationRequest)
                return object;
            var message = new $root.protos.UpdateValidationRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateValidationRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.validation != null) {
                if (typeof object.validation !== "object")
                    throw TypeError(".protos.UpdateValidationRequest.validation: object expected");
                message.validation = $root.protos.common.Validation.fromObject(object.validation);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateValidationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateValidationRequest
         * @static
         * @param {protos.UpdateValidationRequest} message UpdateValidationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateValidationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.validation = null;
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.validation != null && message.hasOwnProperty("validation"))
                object.validation = $root.protos.common.Validation.toObject(message.validation, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateValidationRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateValidationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateValidationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateValidationRequest;
    })();

    protos.UpdateValidationResponse = (function() {

        /**
         * Properties of an UpdateValidationResponse.
         * @memberof protos
         * @interface IUpdateValidationResponse
         * @property {protos.common.IStatus|null} [status] UpdateValidationResponse status
         * @property {protos.common.IValidation|null} [validation] UpdateValidationResponse validation
         */

        /**
         * Constructs a new UpdateValidationResponse.
         * @memberof protos
         * @classdesc Represents an UpdateValidationResponse.
         * @implements IUpdateValidationResponse
         * @constructor
         * @param {protos.IUpdateValidationResponse=} [properties] Properties to set
         */
        function UpdateValidationResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateValidationResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateValidationResponse
         * @instance
         */
        UpdateValidationResponse.prototype.status = null;

        /**
         * UpdateValidationResponse validation.
         * @member {protos.common.IValidation|null|undefined} validation
         * @memberof protos.UpdateValidationResponse
         * @instance
         */
        UpdateValidationResponse.prototype.validation = null;

        /**
         * Creates a new UpdateValidationResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateValidationResponse
         * @static
         * @param {protos.IUpdateValidationResponse=} [properties] Properties to set
         * @returns {protos.UpdateValidationResponse} UpdateValidationResponse instance
         */
        UpdateValidationResponse.create = function create(properties) {
            return new UpdateValidationResponse(properties);
        };

        /**
         * Encodes the specified UpdateValidationResponse message. Does not implicitly {@link protos.UpdateValidationResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateValidationResponse
         * @static
         * @param {protos.IUpdateValidationResponse} message UpdateValidationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateValidationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validation != null && Object.hasOwnProperty.call(message, "validation"))
                $root.protos.common.Validation.encode(message.validation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateValidationResponse message, length delimited. Does not implicitly {@link protos.UpdateValidationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateValidationResponse
         * @static
         * @param {protos.IUpdateValidationResponse} message UpdateValidationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateValidationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateValidationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateValidationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateValidationResponse} UpdateValidationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateValidationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateValidationResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.validation = $root.protos.common.Validation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateValidationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateValidationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateValidationResponse} UpdateValidationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateValidationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateValidationResponse message.
         * @function verify
         * @memberof protos.UpdateValidationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateValidationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.validation != null && message.hasOwnProperty("validation")) {
                var error = $root.protos.common.Validation.verify(message.validation);
                if (error)
                    return "validation." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateValidationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateValidationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateValidationResponse} UpdateValidationResponse
         */
        UpdateValidationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateValidationResponse)
                return object;
            var message = new $root.protos.UpdateValidationResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateValidationResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.validation != null) {
                if (typeof object.validation !== "object")
                    throw TypeError(".protos.UpdateValidationResponse.validation: object expected");
                message.validation = $root.protos.common.Validation.fromObject(object.validation);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateValidationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateValidationResponse
         * @static
         * @param {protos.UpdateValidationResponse} message UpdateValidationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateValidationResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.validation = null;
                object.status = null;
            }
            if (message.validation != null && message.hasOwnProperty("validation"))
                object.validation = $root.protos.common.Validation.toObject(message.validation, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateValidationResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateValidationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateValidationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateValidationResponse;
    })();

    protos.DeleteValidationRequest = (function() {

        /**
         * Properties of a DeleteValidationRequest.
         * @memberof protos
         * @interface IDeleteValidationRequest
         * @property {protos.common.IAuth|null} [auth] DeleteValidationRequest auth
         * @property {string|null} [id] DeleteValidationRequest id
         */

        /**
         * Constructs a new DeleteValidationRequest.
         * @memberof protos
         * @classdesc Represents a DeleteValidationRequest.
         * @implements IDeleteValidationRequest
         * @constructor
         * @param {protos.IDeleteValidationRequest=} [properties] Properties to set
         */
        function DeleteValidationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteValidationRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteValidationRequest
         * @instance
         */
        DeleteValidationRequest.prototype.auth = null;

        /**
         * DeleteValidationRequest id.
         * @member {string} id
         * @memberof protos.DeleteValidationRequest
         * @instance
         */
        DeleteValidationRequest.prototype.id = "";

        /**
         * Creates a new DeleteValidationRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteValidationRequest
         * @static
         * @param {protos.IDeleteValidationRequest=} [properties] Properties to set
         * @returns {protos.DeleteValidationRequest} DeleteValidationRequest instance
         */
        DeleteValidationRequest.create = function create(properties) {
            return new DeleteValidationRequest(properties);
        };

        /**
         * Encodes the specified DeleteValidationRequest message. Does not implicitly {@link protos.DeleteValidationRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteValidationRequest
         * @static
         * @param {protos.IDeleteValidationRequest} message DeleteValidationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteValidationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteValidationRequest message, length delimited. Does not implicitly {@link protos.DeleteValidationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteValidationRequest
         * @static
         * @param {protos.IDeleteValidationRequest} message DeleteValidationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteValidationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteValidationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteValidationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteValidationRequest} DeleteValidationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteValidationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteValidationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteValidationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteValidationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteValidationRequest} DeleteValidationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteValidationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteValidationRequest message.
         * @function verify
         * @memberof protos.DeleteValidationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteValidationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a DeleteValidationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteValidationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteValidationRequest} DeleteValidationRequest
         */
        DeleteValidationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteValidationRequest)
                return object;
            var message = new $root.protos.DeleteValidationRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteValidationRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a DeleteValidationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteValidationRequest
         * @static
         * @param {protos.DeleteValidationRequest} message DeleteValidationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteValidationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.auth = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteValidationRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteValidationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteValidationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteValidationRequest;
    })();

    protos.DeleteValidationResponse = (function() {

        /**
         * Properties of a DeleteValidationResponse.
         * @memberof protos
         * @interface IDeleteValidationResponse
         * @property {protos.common.IStatus|null} [status] DeleteValidationResponse status
         */

        /**
         * Constructs a new DeleteValidationResponse.
         * @memberof protos
         * @classdesc Represents a DeleteValidationResponse.
         * @implements IDeleteValidationResponse
         * @constructor
         * @param {protos.IDeleteValidationResponse=} [properties] Properties to set
         */
        function DeleteValidationResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteValidationResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteValidationResponse
         * @instance
         */
        DeleteValidationResponse.prototype.status = null;

        /**
         * Creates a new DeleteValidationResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteValidationResponse
         * @static
         * @param {protos.IDeleteValidationResponse=} [properties] Properties to set
         * @returns {protos.DeleteValidationResponse} DeleteValidationResponse instance
         */
        DeleteValidationResponse.create = function create(properties) {
            return new DeleteValidationResponse(properties);
        };

        /**
         * Encodes the specified DeleteValidationResponse message. Does not implicitly {@link protos.DeleteValidationResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteValidationResponse
         * @static
         * @param {protos.IDeleteValidationResponse} message DeleteValidationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteValidationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteValidationResponse message, length delimited. Does not implicitly {@link protos.DeleteValidationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteValidationResponse
         * @static
         * @param {protos.IDeleteValidationResponse} message DeleteValidationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteValidationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteValidationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteValidationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteValidationResponse} DeleteValidationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteValidationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteValidationResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteValidationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteValidationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteValidationResponse} DeleteValidationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteValidationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteValidationResponse message.
         * @function verify
         * @memberof protos.DeleteValidationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteValidationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteValidationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteValidationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteValidationResponse} DeleteValidationResponse
         */
        DeleteValidationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteValidationResponse)
                return object;
            var message = new $root.protos.DeleteValidationResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteValidationResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteValidationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteValidationResponse
         * @static
         * @param {protos.DeleteValidationResponse} message DeleteValidationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteValidationResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteValidationResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteValidationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteValidationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteValidationResponse;
    })();

    return protos;
})();

module.exports = $root;
