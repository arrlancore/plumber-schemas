syntax = "proto3";

package protos;

import "x_read.proto";
import "common/auth.proto";
import "common/status.proto";
import "encoding/options.proto";
import "records/base.proto";

option go_package = "github.com/batchcorp/plumber-schemas/build/go/protos";

message ReadSampleOptions {
    // @gotags: kong:"help='How many events to fetch during a sample interval',default=100"
    uint32 sample_rate = 1;

    // @gotags: kong:"help='Sample interval seconds',enum:'1,60',default=60"
     uint32 sample_interval_seconds = 2;
}

enum ConvertOption {
    UNSET = 0;
    BASE64 = 1;
    GZIP = 2;
}

message ReadCLIConfig {
    // @gotags: kong:"help='Display consumer offset stats during read'"
    bool display_offset_stats = 1;

    // @gotags: kong:"help='Convert output before it is printed to STDOUT (1 = base64, 2 = gzip)',enum"
    repeated ConvertOption convert_output = 2;

    // @gotags: kong:"help='Display more verbose information during reads (varies by backend)'"
    bool verbose_output = 3;

    // @gotags: kong:"group=stats,help='Display periodic read stats'"
    bool stats_enable = 4;

    // @gotags: kong:"group=stats,help='How often to print stats',default=5"
    int32 stats_report_interval_sec = 5;
}

message ReadConfig {
    // Required; friendly name for the read
    // @gotags: kong:"-"
    string name = 1;

    // Required for desktop; ignored in CLI.
    // @gotags: kong:"-"
    string connection_id = 2;

    // Required; specify if a read is continuous or not (default: false)
    // @gotags: short:"f" default: "false"
    bool continuous = 3;

    // Optional; specify if reading should utilize sampling
    // @gotags: kong:"embed,group=sampling"
    ReadSampleOptions sample_options = 4;

    // Optional; decode_options specify how to decode the _value_ in a message.
    // If left unset, plumber will still populate records.ReadRecord.Decoded
    // with the (untouched) value.
    // @gotags: kong:"embed,group=decode"
    encoding.DecodeOptions decode_options = 5;

    // Any extra args that can differ between reads (topics, read offset, etc.).
    // NOTE: Desktop can leave conn unset - an existing connection will be used
    // by looking up connection_id.
    // @gotags: kong:"embed"
    ReadArgs read_args = 6;

    ////////////////////////////////////////////////////////
    ////////////// "Private" fields 1000+ ////////////////
    ////////////////////////////////////////////////////////

    // Automatically set by plumber when a new read is created
    // @gotags: kong:"-"
    string _id = 1000;

    // Used by plumber to set read state
    // @gotags: kong:"-"
    bool _active = 1001;

    // Contains options/fields specific to the CLI
    // @gotags: kong:"embed"
    ReadCLIConfig _cli_config = 1002;
}


message CreateReadRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    ReadConfig config = 1;
}

message CreateReadResponse {
    common.Status status = 1000;

    // Assigned and returned by plumber-server to identify a successful read request
    string read_id = 1;
}

///////////////////////////////////////////////////////////////////////////////

message StopReadRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string read_id = 1;
}

message StopReadResponse {
    common.Status status = 1000;
}

///////////////////////////////////////////////////////////////////////////////

message ResumeReadRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string read_id = 1;
}

message ResumeReadResponse {
    common.Status status = 1000;
}

///////////////////////////////////////////////////////////////////////////////

message DeleteReadRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string read_id = 1;
}

message DeleteReadResponse {
    common.Status status = 1000;
}

///////////////////////////////////////////////////////////////////////////////

message StartReadRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string read_id = 1;
}

message StartReadResponse {
    repeated records.ReadRecord records = 1;

    common.Status status = 1000;
}

///////////////////////////////////////////////////////////////////////////////

message GetAllReadsRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;
}

message GetAllReadsResponse {
    repeated ReadConfig read = 1;

    common.Status status = 1000;
}
