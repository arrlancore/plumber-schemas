syntax = "proto3";

package protos;

import "common/auth.proto";
import "common/status.proto";
import "args/kafka.proto";
import "encoding/options.proto";
import "records/base.proto";

option go_package = "github.com/batchcorp/plumber-schemas/build/go/protos";

message ReadOptions {
    enum Type {
        ONE_TIME = 0;
        CONTINUOUS = 1;
    }
}

message SampleOptions {
    enum Interval {
        SECOND = 0;
        MINUTE = 1;
    }

    uint32 sample_rate = 1;
    Interval sample_interval = 2;
}

message Read {
    string id = 1;

    string connection_id = 2;

    ReadOptions read_options = 3;

    SampleOptions sample_options = 4;

    encoding.Options decode_options = 5;

    oneof Args {
        args.Kafka kafka = 100;
    }
}


message StartReadRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    Read read = 1;
}

message StartReadResponse {
    common.Status status = 1000;

    // Assigned and returned by plumber-server to identify a successful read request
    string read_id = 1;
}

///////////////////////////////////////////////////////////////////////////////

message StopReadRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string read_id = 1;
}

message StopReadResponse {
    common.Status status = 1000;
}

///////////////////////////////////////////////////////////////////////////////

message StreamReadRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string read_id = 1;
}

message StreamReadResponse {
    repeated records.Message messages = 1;

    common.Status status = 1000;
}

///////////////////////////////////////////////////////////////////////////////

message GetAllReadsRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;
}

message GetAllReadsResponse {
    repeated Read read = 1;

    common.Status status = 1000;
}