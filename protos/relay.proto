syntax = "proto3";

package protos;

import "backends/backends.proto";
import "backends/kafka.proto";
import "backends/aws-sqs.proto";
import "backends/mongo.proto";
import "backends/nsq.proto";
import "backends/postgres.proto";
import "backends/rabbit.proto";
import "backends/redis-pubsub.proto";
import "backends/redis-streams.proto";
import "backends/azure-service-bus.proto";
import "backends/mqtt.proto";
import "backends/gcp-pubsub.proto";
import "backends/kubemq-queue.proto";
import "common/auth.proto";
import "common/status.proto";

option go_package = "github.com/batchcorp/plumber-schemas/build/go/protos";

message CLIRelayConfig {
    string http_listen_address = 1;

    // Used by CLI to inform components, which backend to use; server uses
    // ReadConfig.connection_id.
    // @gotags: kong:"-"
    backends.Type _backend_type = 2;

    // @gotags: kong:"embed,group=relay"
    RelayBackend _relay_backend = 3;

    message RelayBackend {
        // @gotags: kong:"cmd,help='Apache Kafka'"
        Kafka kafka = 1;

        // @gotags: kong:"cmd,help='AWS Simple Queue System'"
        AWSSQS awssqs = 2;

        // @gotags: kong:"cmd,help='MongoDB (CDC)'"
        Mongo mongo = 3;

        // @gotags: kong:"cmd,help='NSQ'"
        NSQ nsq = 4;

        // @gotags: kong:"cmd,help='MQTT'"
        Rabbit rabbit = 5;

        // @gotags: kong:"cmd,help='MQTT'"
        MQTT mqtt = 6;

        // @gotags: kong:"cmd,help='Azure Service Bus'"
        AzureServiceBus azure_service_bus = 7;

        // @gotags: kong:"cmd,help='Google Cloud Platform Pub/Sub'"
        GCPPubSub gcp_pubsub = 8;

        // @gotags: kong:"cmd,help='KubeMQ Queue'"
        KubeMQQueue kubemq_queue = 9;

        // @gotags: kong:"cmd,help='Redis PubSub'"
        RedisPubSub redis_pubsub = 10;

        // @gotags: kong:"cmd,help='Redis Streams'"
        RedisStreams redis_streams = 11;

        // @gotags: kong:"cmd,help='PostgreSQL (CDC)'"
        Postgres postgres = 12;

        message Kafka {
            // @gotags: kong:"embed"
            backends.KafkaConn conn = 1;
            // @gotags: kong:"embed"
            backends.KafkaReadArgs args = 2;
        }

        message AWSSQS {
            // @gotags: kong:"embed"
            backends.AWSSQSConn conn = 1;
            // @gotags: kong:"embed"
            backends.AWSSQSReadArgs args = 2;
        }

        message Mongo {
            // @gotags: kong:"embed"
            backends.MongoConn conn = 1;
            // @gotags: kong:"embed"
            backends.MongoReadArgs args = 2;
        }

        message NSQ {
            // @gotags: kong:"embed"
            backends.NSQConn conn = 1;
            // @gotags: kong:"embed"
            backends.NSQReadArgs args = 2;
        }

        message Postgres {
            // @gotags: kong:"embed"
            backends.PostgresConn conn = 1;
            // @gotags: kong:"embed"
            backends.PostgresReadArgs args = 2;
        }

        message Rabbit {
            // @gotags: kong:"embed"
            backends.RabbitConn conn = 1;
            // @gotags: kong:"embed"
            backends.RabbitReadArgs args = 2;
        }

        message RedisPubSub {
            // @gotags: kong:"embed"
            backends.RedisPubSubConn conn = 1;
            // @gotags: kong:"embed"
            backends.RedisPubSubReadArgs args = 2;
        }

        message RedisStreams {
            // @gotags: kong:"embed"
            backends.RedisStreamsConn conn = 1;
            // @gotags: kong:"embed"
            backends.RedisStreamsReadArgs args = 2;
        }

        message AzureServiceBus {
            // @gotags: kong:"embed"
            backends.AzureServiceBusConn conn = 1;
            // @gotags: kong:"embed"
            backends.AzureServiceBusReadArgs args = 2;
        }

        message MQTT {
            // @gotags: kong:"embed"
            backends.MQTTConn conn = 1;
            // @gotags: kong:"embed"
            backends.MQTTReadArgs args = 2;
        }

        message GCPPubSub {
            // @gotags: kong:"embed"
            backends.GCPPubSubConn conn = 1;
            // @gotags: kong:"embed"
            backends.GCPPubSubReadArgs args = 2;
        }

        message KubeMQQueue {
            // @gotags: kong:"embed"
            backends.KubeMQQueueConn conn = 1;
            // @gotags: kong:"embed"
            backends.KubeMQQueueReadArgs args = 2;
        }
    }
}

message RelayConfig {
    // Required
    // @gotags: name:"token"
    string collection_token = 1;

    // Optional; how many messages to send in a single batch (default: 1000)
    // @gotags: name:"batch-size"
    int32 batch_size = 2;

    // Optional; how many times plumber will try re-sending a batch (default: 3)
    // @gotags: name:"batch-max-retry"
    int32 batch_max_retry = 3;

    // Required for server mode; ignored in CLI mode.
    // @gotags: kong:"-"
    string connection_id = 4;

    // How many workers to launch per relay (default: 10)
    // @gotags: name:"name-workers"
    int32 num_workers = 5;

    // Optional; where to send events to (default: grpc-collector.batch.sh:9000)
    // @gotags: name:"grpc-address"
    string _batchsh_grpc_address = 6;

    // Optional; whether to use TLS for gRPC (default: true)
    // @gotags: name="grpc-disable-tls"
    bool _batchsh_grpc_disable_tls = 7;

    // Optional: how long to wait before giving up talking to the gRPC collector (default: 10)
    // @gotags: name="grpc-timeout-seconds"
    int32 _batchsh_grpc_timeout_seconds = 8;

    // ID of the created relay entry; populated by plumber.
    // @gotags: kong:"-"
    string _relay_id = 9;

    // @gotags: kong:"embed"
    CLIRelayConfig _cli_config = 10;
}

message GetAllRelaysRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;
}

message GetAllRelaysResponse {
    common.Status status = 1000;

    // Will be set as empty []Relay if no relays are configured
    repeated RelayConfig configs = 1;
}

///////////////////////////////////////////////////////////////////////////////

message GetRelayRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string relay_id = 1;
}

message GetRelayResponse {
    common.Status status = 1000;

    // Set only if status is OK
    RelayConfig config = 1;
}

///////////////////////////////////////////////////////////////////////////////

message CreateRelayRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    RelayConfig config = 1;

    oneof Backends {
        backends.KafkaReadArgs kafka = 100;
        backends.MQTTReadArgs mqtt = 101;
        backends.AWSSQSReadArgs awssqs = 102;
        backends.MongoReadArgs mongo = 104;
        backends.GCPPubSubReadArgs gcp_pubsub = 105;
        backends.AzureServiceBusReadArgs azure_service_bus = 106;
        backends.NSQReadArgs nsq = 107;
        backends.PostgresReadArgs postgres = 108;
        backends.RabbitReadArgs rabbit = 109;
        backends.RedisPubSubReadArgs redis_pubsub = 111;
        backends.RedisStreamsReadArgs redis_streams = 112;
    }
}

message CreateRelayResponse {
    common.Status status = 1000;

    // ID of the created relay entry
    string relay_id = 1;
}

///////////////////////////////////////////////////////////////////////////////

// WARNING: Any in-progress relay will be interrupted/restarted
message UpdateRelayRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string relay_id = 1;

    RelayConfig config = 2;
}

message UpdateRelayResponse {
    common.Status status = 1000;
}

///////////////////////////////////////////////////////////////////////////////

// Resume a paused relay
message ResumeRelayRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string relay_id = 1;
}

message ResumeRelayResponse {
    common.Status status = 1000;
}

///////////////////////////////////////////////////////////////////////////////

// Temporarily stop/pause a relay
message StopRelayRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string relay_id = 1;
}

message StopRelayResponse {
    common.Status status = 1000;
}

///////////////////////////////////////////////////////////////////////////////

message DeleteRelayRequest {
    // Every gRPC request must have a valid auth config
    common.Auth auth = 9999;

    string relay_id = 1;
}

message DeleteRelayResponse {
    common.Status status = 1000;
}
